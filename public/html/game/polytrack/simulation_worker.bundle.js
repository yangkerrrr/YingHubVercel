( () => {
    var e = {
        1312: (e, t, n) => {
            var i;
            /**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.11.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2024
 * @license MIT
 */
            !function() {
                "use strict";
                var t = "input is invalid type"
                  , r = "object" == typeof window
                  , a = r ? window : {};
                a.JS_SHA256_NO_WINDOW && (r = !1);
                var s = !r && "object" == typeof self
                  , o = !a.JS_SHA256_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                o ? a = n.g : s && (a = self);
                var l = !a.JS_SHA256_NO_COMMON_JS && e.exports
                  , c = n.amdO
                  , h = !a.JS_SHA256_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer
                  , d = "0123456789abcdef".split("")
                  , u = [-2147483648, 8388608, 32768, 128]
                  , f = [24, 16, 8, 0]
                  , p = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
                  , m = ["hex", "array", "digest", "arrayBuffer"]
                  , g = [];
                !a.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }
                ),
                !h || !a.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                }
                );
                var A = function(e, t) {
                    return function(n) {
                        return new x(t,!0).update(n)[e]()
                    }
                }
                  , _ = function(e) {
                    var t = A("hex", e);
                    o && (t = v(t, e)),
                    t.create = function() {
                        return new x(e)
                    }
                    ,
                    t.update = function(e) {
                        return t.create().update(e)
                    }
                    ;
                    for (var n = 0; n < m.length; ++n) {
                        var i = m[n];
                        t[i] = A(i, e)
                    }
                    return t
                }
                  , v = function(e, i) {
                    var r, s = n(4394), o = n(1903).Buffer, l = i ? "sha224" : "sha256";
                    r = o.from && !a.JS_SHA256_NO_BUFFER_FROM ? o.from : function(e) {
                        return new o(e)
                    }
                    ;
                    return function(n) {
                        if ("string" == typeof n)
                            return s.createHash(l).update(n, "utf8").digest("hex");
                        if (null == n)
                            throw new Error(t);
                        return n.constructor === ArrayBuffer && (n = new Uint8Array(n)),
                        Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === o ? s.createHash(l).update(r(n)).digest("hex") : e(n)
                    }
                }
                  , w = function(e, t) {
                    return function(n, i) {
                        return new b(n,t,!0).update(i)[e]()
                    }
                }
                  , y = function(e) {
                    var t = w("hex", e);
                    t.create = function(t) {
                        return new b(t,e)
                    }
                    ,
                    t.update = function(e, n) {
                        return t.create(e).update(n)
                    }
                    ;
                    for (var n = 0; n < m.length; ++n) {
                        var i = m[n];
                        t[i] = w(i, e)
                    }
                    return t
                };
                function x(e, t) {
                    t ? (g[0] = g[16] = g[1] = g[2] = g[3] = g[4] = g[5] = g[6] = g[7] = g[8] = g[9] = g[10] = g[11] = g[12] = g[13] = g[14] = g[15] = 0,
                    this.blocks = g) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    e ? (this.h0 = 3238371032,
                    this.h1 = 914150663,
                    this.h2 = 812702999,
                    this.h3 = 4144912697,
                    this.h4 = 4290775857,
                    this.h5 = 1750603025,
                    this.h6 = 1694076839,
                    this.h7 = 3204075428) : (this.h0 = 1779033703,
                    this.h1 = 3144134277,
                    this.h2 = 1013904242,
                    this.h3 = 2773480762,
                    this.h4 = 1359893119,
                    this.h5 = 2600822924,
                    this.h6 = 528734635,
                    this.h7 = 1541459225),
                    this.block = this.start = this.bytes = this.hBytes = 0,
                    this.finalized = this.hashed = !1,
                    this.first = !0,
                    this.is224 = e
                }
                function b(e, n, i) {
                    var r, a = typeof e;
                    if ("string" === a) {
                        var s, o = [], l = e.length, c = 0;
                        for (r = 0; r < l; ++r)
                            (s = e.charCodeAt(r)) < 128 ? o[c++] = s : s < 2048 ? (o[c++] = 192 | s >>> 6,
                            o[c++] = 128 | 63 & s) : s < 55296 || s >= 57344 ? (o[c++] = 224 | s >>> 12,
                            o[c++] = 128 | s >>> 6 & 63,
                            o[c++] = 128 | 63 & s) : (s = 65536 + ((1023 & s) << 10 | 1023 & e.charCodeAt(++r)),
                            o[c++] = 240 | s >>> 18,
                            o[c++] = 128 | s >>> 12 & 63,
                            o[c++] = 128 | s >>> 6 & 63,
                            o[c++] = 128 | 63 & s);
                        e = o
                    } else {
                        if ("object" !== a)
                            throw new Error(t);
                        if (null === e)
                            throw new Error(t);
                        if (h && e.constructor === ArrayBuffer)
                            e = new Uint8Array(e);
                        else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                            throw new Error(t)
                    }
                    e.length > 64 && (e = new x(n,!0).update(e).array());
                    var d = []
                      , u = [];
                    for (r = 0; r < 64; ++r) {
                        var f = e[r] || 0;
                        d[r] = 92 ^ f,
                        u[r] = 54 ^ f
                    }
                    x.call(this, n, i),
                    this.update(u),
                    this.oKeyPad = d,
                    this.inner = !0,
                    this.sharedMemory = i
                }
                x.prototype.update = function(e) {
                    if (!this.finalized) {
                        var n, i = typeof e;
                        if ("string" !== i) {
                            if ("object" !== i)
                                throw new Error(t);
                            if (null === e)
                                throw new Error(t);
                            if (h && e.constructor === ArrayBuffer)
                                e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                throw new Error(t);
                            n = !0
                        }
                        for (var r, a, s = 0, o = e.length, l = this.blocks; s < o; ) {
                            if (this.hashed && (this.hashed = !1,
                            l[0] = this.block,
                            this.block = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0),
                            n)
                                for (a = this.start; s < o && a < 64; ++s)
                                    l[a >>> 2] |= e[s] << f[3 & a++];
                            else
                                for (a = this.start; s < o && a < 64; ++s)
                                    (r = e.charCodeAt(s)) < 128 ? l[a >>> 2] |= r << f[3 & a++] : r < 2048 ? (l[a >>> 2] |= (192 | r >>> 6) << f[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]) : r < 55296 || r >= 57344 ? (l[a >>> 2] |= (224 | r >>> 12) << f[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 6 & 63) << f[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++s)),
                                    l[a >>> 2] |= (240 | r >>> 18) << f[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 12 & 63) << f[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 6 & 63) << f[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]);
                            this.lastByteIndex = a,
                            this.bytes += a - this.start,
                            a >= 64 ? (this.block = l[16],
                            this.start = a - 64,
                            this.hash(),
                            this.hashed = !0) : this.start = a
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0,
                        this.bytes = this.bytes % 4294967296),
                        this
                    }
                }
                ,
                x.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks
                          , t = this.lastByteIndex;
                        e[16] = this.block,
                        e[t >>> 2] |= u[3 & t],
                        this.block = e[16],
                        t >= 56 && (this.hashed || this.hash(),
                        e[0] = this.block,
                        e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0),
                        e[14] = this.hBytes << 3 | this.bytes >>> 29,
                        e[15] = this.bytes << 3,
                        this.hash()
                    }
                }
                ,
                x.prototype.hash = function() {
                    var e, t, n, i, r, a, s, o, l, c = this.h0, h = this.h1, d = this.h2, u = this.h3, f = this.h4, m = this.h5, g = this.h6, A = this.h7, _ = this.blocks;
                    for (e = 16; e < 64; ++e)
                        t = ((r = _[e - 15]) >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3,
                        n = ((r = _[e - 2]) >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10,
                        _[e] = _[e - 16] + t + _[e - 7] + n | 0;
                    for (l = h & d,
                    e = 0; e < 64; e += 4)
                        this.first ? (this.is224 ? (a = 300032,
                        A = (r = _[0] - 1413257819) - 150054599 | 0,
                        u = r + 24177077 | 0) : (a = 704751109,
                        A = (r = _[0] - 210244248) - 1521486534 | 0,
                        u = r + 143694565 | 0),
                        this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10),
                        i = (a = c & h) ^ c & d ^ l,
                        A = u + (r = A + (n = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7)) + (f & m ^ ~f & g) + p[e] + _[e]) | 0,
                        u = r + (t + i) | 0),
                        t = (u >>> 2 | u << 30) ^ (u >>> 13 | u << 19) ^ (u >>> 22 | u << 10),
                        i = (s = u & c) ^ u & h ^ a,
                        g = d + (r = g + (n = (A >>> 6 | A << 26) ^ (A >>> 11 | A << 21) ^ (A >>> 25 | A << 7)) + (A & f ^ ~A & m) + p[e + 1] + _[e + 1]) | 0,
                        t = ((d = r + (t + i) | 0) >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10),
                        i = (o = d & u) ^ d & c ^ s,
                        m = h + (r = m + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & A ^ ~g & f) + p[e + 2] + _[e + 2]) | 0,
                        t = ((h = r + (t + i) | 0) >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10),
                        i = (l = h & d) ^ h & u ^ o,
                        f = c + (r = f + (n = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7)) + (m & g ^ ~m & A) + p[e + 3] + _[e + 3]) | 0,
                        c = r + (t + i) | 0,
                        this.chromeBugWorkAround = !0;
                    this.h0 = this.h0 + c | 0,
                    this.h1 = this.h1 + h | 0,
                    this.h2 = this.h2 + d | 0,
                    this.h3 = this.h3 + u | 0,
                    this.h4 = this.h4 + f | 0,
                    this.h5 = this.h5 + m | 0,
                    this.h6 = this.h6 + g | 0,
                    this.h7 = this.h7 + A | 0
                }
                ,
                x.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = d[e >>> 28 & 15] + d[e >>> 24 & 15] + d[e >>> 20 & 15] + d[e >>> 16 & 15] + d[e >>> 12 & 15] + d[e >>> 8 & 15] + d[e >>> 4 & 15] + d[15 & e] + d[t >>> 28 & 15] + d[t >>> 24 & 15] + d[t >>> 20 & 15] + d[t >>> 16 & 15] + d[t >>> 12 & 15] + d[t >>> 8 & 15] + d[t >>> 4 & 15] + d[15 & t] + d[n >>> 28 & 15] + d[n >>> 24 & 15] + d[n >>> 20 & 15] + d[n >>> 16 & 15] + d[n >>> 12 & 15] + d[n >>> 8 & 15] + d[n >>> 4 & 15] + d[15 & n] + d[i >>> 28 & 15] + d[i >>> 24 & 15] + d[i >>> 20 & 15] + d[i >>> 16 & 15] + d[i >>> 12 & 15] + d[i >>> 8 & 15] + d[i >>> 4 & 15] + d[15 & i] + d[r >>> 28 & 15] + d[r >>> 24 & 15] + d[r >>> 20 & 15] + d[r >>> 16 & 15] + d[r >>> 12 & 15] + d[r >>> 8 & 15] + d[r >>> 4 & 15] + d[15 & r] + d[a >>> 28 & 15] + d[a >>> 24 & 15] + d[a >>> 20 & 15] + d[a >>> 16 & 15] + d[a >>> 12 & 15] + d[a >>> 8 & 15] + d[a >>> 4 & 15] + d[15 & a] + d[s >>> 28 & 15] + d[s >>> 24 & 15] + d[s >>> 20 & 15] + d[s >>> 16 & 15] + d[s >>> 12 & 15] + d[s >>> 8 & 15] + d[s >>> 4 & 15] + d[15 & s];
                    return this.is224 || (l += d[o >>> 28 & 15] + d[o >>> 24 & 15] + d[o >>> 20 & 15] + d[o >>> 16 & 15] + d[o >>> 12 & 15] + d[o >>> 8 & 15] + d[o >>> 4 & 15] + d[15 & o]),
                    l
                }
                ,
                x.prototype.toString = x.prototype.hex,
                x.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = [e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s];
                    return this.is224 || l.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o),
                    l
                }
                ,
                x.prototype.array = x.prototype.digest,
                x.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(this.is224 ? 28 : 32)
                      , t = new DataView(e);
                    return t.setUint32(0, this.h0),
                    t.setUint32(4, this.h1),
                    t.setUint32(8, this.h2),
                    t.setUint32(12, this.h3),
                    t.setUint32(16, this.h4),
                    t.setUint32(20, this.h5),
                    t.setUint32(24, this.h6),
                    this.is224 || t.setUint32(28, this.h7),
                    e
                }
                ,
                b.prototype = new x,
                b.prototype.finalize = function() {
                    if (x.prototype.finalize.call(this),
                    this.inner) {
                        this.inner = !1;
                        var e = this.array();
                        x.call(this, this.is224, this.sharedMemory),
                        this.update(this.oKeyPad),
                        this.update(e),
                        x.prototype.finalize.call(this)
                    }
                }
                ;
                var S = _();
                S.sha256 = S,
                S.sha224 = _(!0),
                S.sha256.hmac = y(),
                S.sha224.hmac = y(!0),
                l ? e.exports = S : (a.sha256 = S.sha256,
                a.sha224 = S.sha224,
                c && (void 0 === (i = function() {
                    return S
                }
                .call(S, n, S, e)) || (e.exports = i)))
            }()
        }
        ,
        1903: () => {}
        ,
        4394: () => {}
    }
      , t = {};
    function n(i) {
        var r = t[i];
        if (void 0 !== r)
            return r.exports;
        var a = t[i] = {
            exports: {}
        };
        return e[i](a, a.exports, n),
        a.exports
    }
    n.amdO = {},
    n.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    ( () => {
        "use strict";
        /**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
        const e = "174"
          , t = 0
          , i = 1
          , r = 2
          , a = 100
          , s = 101
          , o = 102
          , l = 200
          , c = 201
          , h = 202
          , d = 203
          , u = 204
          , f = 205
          , p = 206
          , m = 207
          , g = 208
          , A = 209
          , _ = 210
          , v = 211
          , w = 212
          , y = 213
          , x = 214
          , b = 0
          , S = 1
          , E = 2
          , M = 3
          , T = 4
          , C = 5
          , I = 6
          , R = 7
          , P = "attached"
          , B = 301
          , D = 302
          , L = 303
          , U = 304
          , N = 306
          , k = 1e3
          , F = 1001
          , O = 1002
          , z = 1003
          , H = 1004
          , W = 1005
          , V = 1006
          , G = 1007
          , Q = 1008
          , X = 1009
          , j = 1010
          , q = 1011
          , Y = 1012
          , K = 1013
          , Z = 1014
          , J = 1015
          , $ = 1016
          , ee = 1017
          , te = 1018
          , ne = 1020
          , ie = 35902
          , re = 1023
          , ae = 1026
          , se = 1027
          , oe = 1028
          , le = 1029
          , ce = 1031
          , he = 1033
          , de = 33776
          , ue = 33777
          , fe = 33778
          , pe = 33779
          , me = 35840
          , ge = 35841
          , Ae = 35842
          , _e = 35843
          , ve = 36196
          , we = 37492
          , ye = 37496
          , xe = 37808
          , be = 37809
          , Se = 37810
          , Ee = 37811
          , Me = 37812
          , Te = 37813
          , Ce = 37814
          , Ie = 37815
          , Re = 37816
          , Pe = 37817
          , Be = 37818
          , De = 37819
          , Le = 37820
          , Ue = 37821
          , Ne = 36492
          , ke = 36494
          , Fe = 36495
          , Oe = 36284
          , ze = 36285
          , He = 36286
          , We = 2300
          , Ve = 2301
          , Ge = 2302
          , Qe = 2400
          , Xe = 2401
          , je = 2402
          , qe = ""
          , Ye = "srgb"
          , Ke = "srgb-linear"
          , Ze = "linear"
          , Je = "srgb"
          , $e = 7680
          , et = 512
          , tt = 513
          , nt = 514
          , it = 515
          , rt = 516
          , at = 517
          , st = 518
          , ot = 519
          , lt = 35044
          , ct = "300 es"
          , ht = 2e3
          , dt = 2001;
        class ut {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []),
                -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                const n = this._listeners;
                return void 0 !== n && (void 0 !== n[e] && -1 !== n[e].indexOf(t))
            }
            removeEventListener(e, t) {
                const n = this._listeners;
                if (void 0 === n)
                    return;
                const i = n[e];
                if (void 0 !== i) {
                    const e = i.indexOf(t);
                    -1 !== e && i.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                const t = this._listeners;
                if (void 0 === t)
                    return;
                const n = t[e.type];
                if (void 0 !== n) {
                    e.target = this;
                    const t = n.slice(0);
                    for (let n = 0, i = t.length; n < i; n++)
                        t[n].call(this, e);
                    e.target = null
                }
            }
        }
        const ft = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let pt = 1234567;
        const mt = Math.PI / 180
          , gt = 180 / Math.PI;
        function At() {
            const e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (ft[255 & e] + ft[e >> 8 & 255] + ft[e >> 16 & 255] + ft[e >> 24 & 255] + "-" + ft[255 & t] + ft[t >> 8 & 255] + "-" + ft[t >> 16 & 15 | 64] + ft[t >> 24 & 255] + "-" + ft[63 & n | 128] + ft[n >> 8 & 255] + "-" + ft[n >> 16 & 255] + ft[n >> 24 & 255] + ft[255 & i] + ft[i >> 8 & 255] + ft[i >> 16 & 255] + ft[i >> 24 & 255]).toLowerCase()
        }
        function _t(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }
        function vt(e, t) {
            return (e % t + t) % t
        }
        function wt(e, t, n) {
            return (1 - n) * e + n * t
        }
        function yt(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return e / 4294967295;
            case Uint16Array:
                return e / 65535;
            case Uint8Array:
                return e / 255;
            case Int32Array:
                return Math.max(e / 2147483647, -1);
            case Int16Array:
                return Math.max(e / 32767, -1);
            case Int8Array:
                return Math.max(e / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function xt(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return Math.round(4294967295 * e);
            case Uint16Array:
                return Math.round(65535 * e);
            case Uint8Array:
                return Math.round(255 * e);
            case Int32Array:
                return Math.round(2147483647 * e);
            case Int16Array:
                return Math.round(32767 * e);
            case Int8Array:
                return Math.round(127 * e);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const bt = {
            DEG2RAD: mt,
            RAD2DEG: gt,
            generateUUID: At,
            clamp: _t,
            euclideanModulo: vt,
            mapLinear: function(e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: wt,
            damp: function(e, t, n, i) {
                return wt(e, t, 1 - Math.exp(-n * i))
            },
            pingpong: function(e, t=1) {
                return t - Math.abs(vt(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (pt = e);
                let t = pt += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t),
                t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * mt
            },
            radToDeg: function(e) {
                return e * gt
            },
            isPowerOfTwo: function(e) {
                return !(e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(e, t, n, i, r) {
                const a = Math.cos
                  , s = Math.sin
                  , o = a(n / 2)
                  , l = s(n / 2)
                  , c = a((t + i) / 2)
                  , h = s((t + i) / 2)
                  , d = a((t - i) / 2)
                  , u = s((t - i) / 2)
                  , f = a((i - t) / 2)
                  , p = s((i - t) / 2);
                switch (r) {
                case "XYX":
                    e.set(o * h, l * d, l * u, o * c);
                    break;
                case "YZY":
                    e.set(l * u, o * h, l * d, o * c);
                    break;
                case "ZXZ":
                    e.set(l * d, l * u, o * h, o * c);
                    break;
                case "XZX":
                    e.set(o * h, l * p, l * f, o * c);
                    break;
                case "YXY":
                    e.set(l * f, o * h, l * p, o * c);
                    break;
                case "ZYZ":
                    e.set(l * p, l * f, o * h, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: xt,
            denormalize: yt
        };
        class St {
            constructor(e=0, t=0) {
                St.prototype.isVector2 = !0,
                this.x = e,
                this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e,
                this.y = t,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6],
                this.y = i[1] * t + i[4] * n + i[7],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this
            }
            clamp(e, t) {
                return this.x = _t(this.x, e.x, t.x),
                this.y = _t(this.y, e.y, t.y),
                this
            }
            clampScalar(e, t) {
                return this.x = _t(this.x, e, t),
                this.y = _t(this.y, e, t),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(_t(n, e, t))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(_t(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this
            }
            rotateAround(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = this.x - e.x
                  , a = this.y - e.y;
                return this.x = r * n - a * i + e.x,
                this.y = r * i + a * n + e.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class Et {
            constructor(e, t, n, i, r, a, s, o, l) {
                Et.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, a, s, o, l)
            }
            set(e, t, n, i, r, a, s, o, l) {
                const c = this.elements;
                return c[0] = e,
                c[1] = i,
                c[2] = s,
                c[3] = t,
                c[4] = r,
                c[5] = o,
                c[6] = n,
                c[7] = a,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0),
                t.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , a = n[0]
                  , s = n[3]
                  , o = n[6]
                  , l = n[1]
                  , c = n[4]
                  , h = n[7]
                  , d = n[2]
                  , u = n[5]
                  , f = n[8]
                  , p = i[0]
                  , m = i[3]
                  , g = i[6]
                  , A = i[1]
                  , _ = i[4]
                  , v = i[7]
                  , w = i[2]
                  , y = i[5]
                  , x = i[8];
                return r[0] = a * p + s * A + o * w,
                r[3] = a * m + s * _ + o * y,
                r[6] = a * g + s * v + o * x,
                r[1] = l * p + c * A + h * w,
                r[4] = l * m + c * _ + h * y,
                r[7] = l * g + c * v + h * x,
                r[2] = d * p + u * A + f * w,
                r[5] = d * m + u * _ + f * y,
                r[8] = d * g + u * v + f * x,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[3] *= e,
                t[6] *= e,
                t[1] *= e,
                t[4] *= e,
                t[7] *= e,
                t[2] *= e,
                t[5] *= e,
                t[8] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8];
                return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , h = c * a - s * l
                  , d = s * o - c * r
                  , u = l * r - a * o
                  , f = t * h + n * d + i * u;
                if (0 === f)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / f;
                return e[0] = h * p,
                e[1] = (i * l - c * n) * p,
                e[2] = (s * n - i * a) * p,
                e[3] = d * p,
                e[4] = (c * t - i * o) * p,
                e[5] = (i * r - s * t) * p,
                e[6] = u * p,
                e[7] = (n * o - l * t) * p,
                e[8] = (a * t - n * r) * p,
                this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1],
                t[1] = t[3],
                t[3] = e,
                e = t[2],
                t[2] = t[6],
                t[6] = e,
                e = t[5],
                t[5] = t[7],
                t[7] = e,
                this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0],
                e[1] = t[3],
                e[2] = t[6],
                e[3] = t[1],
                e[4] = t[4],
                e[5] = t[7],
                e[6] = t[2],
                e[7] = t[5],
                e[8] = t[8],
                this
            }
            setUvTransform(e, t, n, i, r, a, s) {
                const o = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1),
                this
            }
            scale(e, t) {
                return this.premultiply(Mt.makeScale(e, t)),
                this
            }
            rotate(e) {
                return this.premultiply(Mt.makeRotation(-e)),
                this
            }
            translate(e, t) {
                return this.premultiply(Mt.makeTranslation(e, t)),
                this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                this
            }
            makeRotation(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 9; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Mt = new Et;
        function Tt(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535)
                    return !0;
            return !1
        }
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        function Ct(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }
        function It() {
            const e = Ct("canvas");
            return e.style.display = "block",
            e
        }
        const Rt = {};
        function Pt(e) {
            e in Rt || (Rt[e] = !0,
            console.warn(e))
        }
        const Bt = (new Et).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
          , Dt = (new Et).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
        function Lt() {
            const e = {
                enabled: !0,
                workingColorSpace: Ke,
                spaces: {},
                convert: function(e, t, n) {
                    return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === Je && (e.r = Nt(e.r),
                    e.g = Nt(e.g),
                    e.b = Nt(e.b)),
                    this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ),
                    e.applyMatrix3(this.spaces[n].fromXYZ)),
                    this.spaces[n].transfer === Je && (e.r = kt(e.r),
                    e.g = kt(e.g),
                    e.b = kt(e.b)),
                    e) : e
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this.workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this.workingColorSpace)
                },
                getPrimaries: function(e) {
                    return this.spaces[e].primaries
                },
                getTransfer: function(e) {
                    return e === qe ? Ze : this.spaces[e].transfer
                },
                getLuminanceCoefficients: function(e, t=this.workingColorSpace) {
                    return e.fromArray(this.spaces[t].luminanceCoefficients)
                },
                define: function(e) {
                    Object.assign(this.spaces, e)
                },
                _getMatrix: function(e, t, n) {
                    return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
                },
                _getDrawingBufferColorSpace: function(e) {
                    return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
                },
                _getUnpackColorSpace: function(e=this.workingColorSpace) {
                    return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
                }
            }
              , t = [.64, .33, .3, .6, .15, .06]
              , n = [.2126, .7152, .0722]
              , i = [.3127, .329];
            return e.define({
                [Ke]: {
                    primaries: t,
                    whitePoint: i,
                    transfer: Ze,
                    toXYZ: Bt,
                    fromXYZ: Dt,
                    luminanceCoefficients: n,
                    workingColorSpaceConfig: {
                        unpackColorSpace: Ye
                    },
                    outputColorSpaceConfig: {
                        drawingBufferColorSpace: Ye
                    }
                },
                [Ye]: {
                    primaries: t,
                    whitePoint: i,
                    transfer: Je,
                    toXYZ: Bt,
                    fromXYZ: Dt,
                    luminanceCoefficients: n,
                    outputColorSpaceConfig: {
                        drawingBufferColorSpace: Ye
                    }
                }
            }),
            e
        }
        const Ut = Lt();
        function Nt(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }
        function kt(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        let Ft;
        class Ot {
            static getDataURL(e) {
                if (/^data:/i.test(e.src))
                    return e.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return e.src;
                let t;
                if (e instanceof HTMLCanvasElement)
                    t = e;
                else {
                    void 0 === Ft && (Ft = Ct("canvas")),
                    Ft.width = e.width,
                    Ft.height = e.height;
                    const n = Ft.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                    t = Ft
                }
                return t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = Ct("canvas");
                    t.width = e.width,
                    t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height)
                      , r = i.data;
                    for (let e = 0; e < r.length; e++)
                        r[e] = 255 * Nt(r[e] / 255);
                    return n.putImageData(i, 0, 0),
                    t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++)
                        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Nt(t[e] / 255)) : t[e] = Nt(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                e
            }
        }
        let zt = 0;
        class Ht {
            constructor(e=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: zt++
                }),
                this.uuid = At(),
                this.data = e,
                this.dataReady = !0,
                this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.images[this.uuid])
                    return e.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , i = this.data;
                if (null !== i) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? e.push(Wt(i[t].image)) : e.push(Wt(i[t]))
                    } else
                        e = Wt(i);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n),
                n
            }
        }
        function Wt(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Ot.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let Vt = 0;
        class Gt extends ut {
            constructor(e=Gt.DEFAULT_IMAGE, t=Gt.DEFAULT_MAPPING, n=1001, i=1001, r=1006, a=1008, s=1023, o=1009, l=Gt.DEFAULT_ANISOTROPY, c="") {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: Vt++
                }),
                this.uuid = At(),
                this.name = "",
                this.source = new Ht(e),
                this.mipmaps = [],
                this.mapping = t,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = a,
                this.anisotropy = l,
                this.format = s,
                this.internalFormat = null,
                this.type = o,
                this.offset = new St(0,0),
                this.repeat = new St(1,1),
                this.center = new St(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Et,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.colorSpace = c,
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.renderTarget = null,
                this.isRenderTargetTexture = !1,
                this.pmremVersion = 0
            }
            get image() {
                return this.source.data
            }
            set image(e=null) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name,
                this.source = e.source,
                this.mipmaps = e.mipmaps.slice(0),
                this.mapping = e.mapping,
                this.channel = e.channel,
                this.wrapS = e.wrapS,
                this.wrapT = e.wrapT,
                this.magFilter = e.magFilter,
                this.minFilter = e.minFilter,
                this.anisotropy = e.anisotropy,
                this.format = e.format,
                this.internalFormat = e.internalFormat,
                this.type = e.type,
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                this.rotation = e.rotation,
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrix.copy(e.matrix),
                this.generateMipmaps = e.generateMipmaps,
                this.premultiplyAlpha = e.premultiplyAlpha,
                this.flipY = e.flipY,
                this.unpackAlignment = e.unpackAlignment,
                this.colorSpace = e.colorSpace,
                this.renderTarget = e.renderTarget,
                this.isRenderTargetTexture = e.isRenderTargetTexture,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid])
                    return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t || (e.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (300 !== this.mapping)
                    return e;
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                    case k:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case F:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case O:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                    case k:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case F:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case O:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                return this.flipY && (e.y = 1 - e.y),
                e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++,
                this.source.needsUpdate = !0)
            }
            set needsPMREMUpdate(e) {
                !0 === e && this.pmremVersion++
            }
        }
        Gt.DEFAULT_IMAGE = null,
        Gt.DEFAULT_MAPPING = 300,
        Gt.DEFAULT_ANISOTROPY = 1;
        class Qt {
            constructor(e=0, t=0, n=0, i=1) {
                Qt.prototype.isVector4 = !0,
                this.x = e,
                this.y = t,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e,
                this.y = t,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this.w = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setW(e) {
                return this.w = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = void 0 !== e.w ? e.w : 1,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this.w += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this.w = e.w + t.w,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this.w += e.w * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this.w -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this.w = e.w - t.w,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , a = e.elements;
                return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r,
                this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r,
                this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r,
                this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this.w /= e.w,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = e.x / t,
                this.y = e.y / t,
                this.z = e.z / t),
                this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const a = .01
                  , s = .1
                  , o = e.elements
                  , l = o[0]
                  , c = o[4]
                  , h = o[8]
                  , d = o[1]
                  , u = o[5]
                  , f = o[9]
                  , p = o[2]
                  , m = o[6]
                  , g = o[10];
                if (Math.abs(c - d) < a && Math.abs(h - p) < a && Math.abs(f - m) < a) {
                    if (Math.abs(c + d) < s && Math.abs(h + p) < s && Math.abs(f + m) < s && Math.abs(l + u + g - 3) < s)
                        return this.set(1, 0, 0, 0),
                        this;
                    t = Math.PI;
                    const e = (l + 1) / 2
                      , o = (u + 1) / 2
                      , A = (g + 1) / 2
                      , _ = (c + d) / 4
                      , v = (h + p) / 4
                      , w = (f + m) / 4;
                    return e > o && e > A ? e < a ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(e),
                    i = _ / n,
                    r = v / n) : o > A ? o < a ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(o),
                    n = _ / i,
                    r = w / i) : A < a ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(A),
                    n = v / r,
                    i = w / r),
                    this.set(n, i, r, t),
                    this
                }
                let A = Math.sqrt((m - f) * (m - f) + (h - p) * (h - p) + (d - c) * (d - c));
                return Math.abs(A) < .001 && (A = 1),
                this.x = (m - f) / A,
                this.y = (h - p) / A,
                this.z = (d - c) / A,
                this.w = Math.acos((l + u + g - 1) / 2),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this.w = t[15],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this.w = Math.min(this.w, e.w),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this.w = Math.max(this.w, e.w),
                this
            }
            clamp(e, t) {
                return this.x = _t(this.x, e.x, t.x),
                this.y = _t(this.y, e.y, t.y),
                this.z = _t(this.z, e.z, t.z),
                this.w = _t(this.w, e.w, t.w),
                this
            }
            clampScalar(e, t) {
                return this.x = _t(this.x, e, t),
                this.y = _t(this.y, e, t),
                this.z = _t(this.z, e, t),
                this.w = _t(this.w, e, t),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(_t(n, e, t))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this.w += (e.w - this.w) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this.w = e.w + (t.w - e.w) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e[t + 3] = this.w,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this.w = e.getW(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class Xt extends ut {
            constructor(e=1, t=1, n={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = e,
                this.height = t,
                this.depth = 1,
                this.scissor = new Qt(0,0,e,t),
                this.scissorTest = !1,
                this.viewport = new Qt(0,0,e,t);
                const i = {
                    width: e,
                    height: t,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: V,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    resolveDepthBuffer: !0,
                    resolveStencilBuffer: !0,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const r = new Gt(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
                r.flipY = !1,
                r.generateMipmaps = n.generateMipmaps,
                r.internalFormat = n.internalFormat,
                this.textures = [];
                const a = n.count;
                for (let e = 0; e < a; e++)
                    this.textures[e] = r.clone(),
                    this.textures[e].isRenderTargetTexture = !0,
                    this.textures[e].renderTarget = this;
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.resolveDepthBuffer = n.resolveDepthBuffer,
                this.resolveStencilBuffer = n.resolveStencilBuffer,
                this._depthTexture = null,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            get texture() {
                return this.textures[0]
            }
            set texture(e) {
                this.textures[0] = e
            }
            set depthTexture(e) {
                null !== this._depthTexture && (this._depthTexture.renderTarget = null),
                null !== e && (e.renderTarget = this),
                this._depthTexture = e
            }
            get depthTexture() {
                return this._depthTexture
            }
            setSize(e, t, n=1) {
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e,
                    this.height = t,
                    this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++)
                        this.textures[i].image.width = e,
                        this.textures[i].image.height = t,
                        this.textures[i].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, e, t),
                this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.scissor.copy(e.scissor),
                this.scissorTest = e.scissorTest,
                this.viewport.copy(e.viewport),
                this.textures.length = 0;
                for (let t = 0, n = e.textures.length; t < n; t++) {
                    this.textures[t] = e.textures[t].clone(),
                    this.textures[t].isRenderTargetTexture = !0,
                    this.textures[t].renderTarget = this;
                    const n = Object.assign({}, e.textures[t].image);
                    this.textures[t].source = new Ht(n)
                }
                return this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                this.resolveDepthBuffer = e.resolveDepthBuffer,
                this.resolveStencilBuffer = e.resolveStencilBuffer,
                null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                this.samples = e.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class jt extends Xt {
            constructor(e=1, t=1, n={}) {
                super(e, t, n),
                this.isWebGLRenderTarget = !0
            }
        }
        class qt extends Gt {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = z,
                this.minFilter = z,
                this.wrapR = F,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.layerUpdates = new Set
            }
            addLayerUpdate(e) {
                this.layerUpdates.add(e)
            }
            clearLayerUpdates() {
                this.layerUpdates.clear()
            }
        }
        class Yt extends Gt {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = z,
                this.minFilter = z,
                this.wrapR = F,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class Kt {
            constructor(e=0, t=0, n=0, i=1) {
                this.isQuaternion = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._w = i
            }
            static slerpFlat(e, t, n, i, r, a, s) {
                let o = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , h = n[i + 3];
                const d = r[a + 0]
                  , u = r[a + 1]
                  , f = r[a + 2]
                  , p = r[a + 3];
                if (0 === s)
                    return e[t + 0] = o,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    void (e[t + 3] = h);
                if (1 === s)
                    return e[t + 0] = d,
                    e[t + 1] = u,
                    e[t + 2] = f,
                    void (e[t + 3] = p);
                if (h !== p || o !== d || l !== u || c !== f) {
                    let e = 1 - s;
                    const t = o * d + l * u + c * f + h * p
                      , n = t >= 0 ? 1 : -1
                      , i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , a = Math.atan2(r, t * n);
                        e = Math.sin(e * a) / r,
                        s = Math.sin(s * a) / r
                    }
                    const r = s * n;
                    if (o = o * e + d * r,
                    l = l * e + u * r,
                    c = c * e + f * r,
                    h = h * e + p * r,
                    e === 1 - s) {
                        const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                        o *= e,
                        l *= e,
                        c *= e,
                        h *= e
                    }
                }
                e[t] = o,
                e[t + 1] = l,
                e[t + 2] = c,
                e[t + 3] = h
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                const s = n[i]
                  , o = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , h = r[a]
                  , d = r[a + 1]
                  , u = r[a + 2]
                  , f = r[a + 3];
                return e[t] = s * f + c * h + o * u - l * d,
                e[t + 1] = o * f + c * d + l * h - s * u,
                e[t + 2] = l * f + c * u + s * d - o * h,
                e[t + 3] = c * f - s * h - o * d - l * u,
                e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(e) {
                return this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = e.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(e, t=!0) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , a = e._order
                  , s = Math.cos
                  , o = Math.sin
                  , l = s(n / 2)
                  , c = s(i / 2)
                  , h = s(r / 2)
                  , d = o(n / 2)
                  , u = o(i / 2)
                  , f = o(r / 2);
                switch (a) {
                case "XYZ":
                    this._x = d * c * h + l * u * f,
                    this._y = l * u * h - d * c * f,
                    this._z = l * c * f + d * u * h,
                    this._w = l * c * h - d * u * f;
                    break;
                case "YXZ":
                    this._x = d * c * h + l * u * f,
                    this._y = l * u * h - d * c * f,
                    this._z = l * c * f - d * u * h,
                    this._w = l * c * h + d * u * f;
                    break;
                case "ZXY":
                    this._x = d * c * h - l * u * f,
                    this._y = l * u * h + d * c * f,
                    this._z = l * c * f + d * u * h,
                    this._w = l * c * h - d * u * f;
                    break;
                case "ZYX":
                    this._x = d * c * h - l * u * f,
                    this._y = l * u * h + d * c * f,
                    this._z = l * c * f - d * u * h,
                    this._w = l * c * h + d * u * f;
                    break;
                case "YZX":
                    this._x = d * c * h + l * u * f,
                    this._y = l * u * h + d * c * f,
                    this._z = l * c * f - d * u * h,
                    this._w = l * c * h - d * u * f;
                    break;
                case "XZY":
                    this._x = d * c * h - l * u * f,
                    this._y = l * u * h - d * c * f,
                    this._z = l * c * f + d * u * h,
                    this._w = l * c * h + d * u * f;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                }
                return !0 === t && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2
                  , i = Math.sin(n);
                return this._x = e.x * i,
                this._y = e.y * i,
                this._z = e.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                const t = e.elements
                  , n = t[0]
                  , i = t[4]
                  , r = t[8]
                  , a = t[1]
                  , s = t[5]
                  , o = t[9]
                  , l = t[2]
                  , c = t[6]
                  , h = t[10]
                  , d = n + s + h;
                if (d > 0) {
                    const e = .5 / Math.sqrt(d + 1);
                    this._w = .25 / e,
                    this._x = (c - o) * e,
                    this._y = (r - l) * e,
                    this._z = (a - i) * e
                } else if (n > s && n > h) {
                    const e = 2 * Math.sqrt(1 + n - s - h);
                    this._w = (c - o) / e,
                    this._x = .25 * e,
                    this._y = (i + a) / e,
                    this._z = (r + l) / e
                } else if (s > h) {
                    const e = 2 * Math.sqrt(1 + s - n - h);
                    this._w = (r - l) / e,
                    this._x = (i + a) / e,
                    this._y = .25 * e,
                    this._z = (o + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + h - n - s);
                    this._w = (a - i) / e,
                    this._x = (r + l) / e,
                    this._y = (o + c) / e,
                    this._z = .25 * e
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                this._y = e.z * t.x - e.x * t.z,
                this._z = e.x * t.y - e.y * t.x,
                this._w = n),
                this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(_t(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n)
                    return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (e = 1 / e,
                this._x = this._x * e,
                this._y = this._y * e,
                this._z = this._z * e,
                this._w = this._w * e),
                this._onChangeCallback(),
                this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , a = e._w
                  , s = t._x
                  , o = t._y
                  , l = t._z
                  , c = t._w;
                return this._x = n * c + a * s + i * l - r * o,
                this._y = i * c + a * o + r * s - n * l,
                this._z = r * c + a * l + n * o - i * s,
                this._w = a * c - n * s - i * o - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(e, t) {
                if (0 === t)
                    return this;
                if (1 === t)
                    return this.copy(e);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , a = this._w;
                let s = a * e._w + n * e._x + i * e._y + r * e._z;
                if (s < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                s = -s) : this.copy(e),
                s >= 1)
                    return this._w = a,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const o = 1 - s * s;
                if (o <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * a + t * this._w,
                    this._x = e * n + t * this._x,
                    this._y = e * i + t * this._y,
                    this._z = e * r + t * this._z,
                    this.normalize(),
                    this
                }
                const l = Math.sqrt(o)
                  , c = Math.atan2(l, s)
                  , h = Math.sin((1 - t) * c) / l
                  , d = Math.sin(t * c) / l;
                return this._w = a * h + this._w * d,
                this._x = n * h + this._x * d,
                this._y = i * h + this._y * d,
                this._z = r * h + this._z * d,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = 2 * Math.PI * Math.random()
                  , t = 2 * Math.PI * Math.random()
                  , n = Math.random()
                  , i = Math.sqrt(1 - n)
                  , r = Math.sqrt(n);
                return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t=0) {
                return this._x = e[t],
                this._y = e[t + 1],
                this._z = e[t + 2],
                this._w = e[t + 3],
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._w,
                e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t),
                this._y = e.getY(t),
                this._z = e.getZ(t),
                this._w = e.getW(t),
                this._onChangeCallback(),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class Zt {
            constructor(e=0, t=0, n=0) {
                Zt.prototype.isVector3 = !0,
                this.x = e,
                this.y = t,
                this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z),
                this.x = e,
                this.y = t,
                this.z = n,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x,
                this.y = e.y * t.y,
                this.z = e.z * t.z,
                this
            }
            applyEuler(e) {
                return this.applyQuaternion($t.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion($t.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i,
                this.y = r[1] * t + r[4] * n + r[7] * i,
                this.z = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements
                  , a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a,
                this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a,
                this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a,
                this
            }
            applyQuaternion(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.x
                  , a = e.y
                  , s = e.z
                  , o = e.w
                  , l = 2 * (a * i - s * n)
                  , c = 2 * (s * t - r * i)
                  , h = 2 * (r * n - a * t);
                return this.x = t + o * l + a * h - s * c,
                this.y = n + o * c + s * l - r * h,
                this.z = i + o * h + r * c - a * l,
                this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i,
                this.y = r[1] * t + r[5] * n + r[9] * i,
                this.z = r[2] * t + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this
            }
            clamp(e, t) {
                return this.x = _t(this.x, e.x, t.x),
                this.y = _t(this.y, e.y, t.y),
                this.z = _t(this.z, e.z, t.z),
                this
            }
            clampScalar(e, t) {
                return this.x = _t(this.x, e, t),
                this.y = _t(this.y, e, t),
                this.z = _t(this.z, e, t),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(_t(n, e, t))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x
                  , i = e.y
                  , r = e.z
                  , a = t.x
                  , s = t.y
                  , o = t.z;
                return this.x = i * o - r * s,
                this.y = r * a - n * o,
                this.z = n * s - i * a,
                this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t)
                    return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return Jt.copy(this).projectOnVector(e),
                this.sub(Jt)
            }
            reflect(e) {
                return this.sub(Jt.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(_t(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y
                  , i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(t) * e,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t),
                this.y = n,
                this.z = e * Math.cos(t),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length()
                  , n = this.setFromMatrixColumn(e, 1).length()
                  , i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x,
                this.y = e._y,
                this.z = e._z,
                this
            }
            setFromColor(e) {
                return this.x = e.r,
                this.y = e.g,
                this.z = e.b,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const e = Math.random() * Math.PI * 2
                  , t = 2 * Math.random() - 1
                  , n = Math.sqrt(1 - t * t);
                return this.x = n * Math.cos(e),
                this.y = t,
                this.z = n * Math.sin(e),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const Jt = new Zt
          , $t = new Kt;
        class en {
            constructor(e=new Zt(1 / 0,1 / 0,1 / 0), t=new Zt(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3)
                    this.expandByPoint(nn.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++)
                    this.expandByPoint(nn.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = nn.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            setFromObject(e, t=!1) {
                return this.makeEmpty(),
                this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            expandByObject(e, t=!1) {
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = i.count; t < n; t++)
                            !0 === e.isMesh ? e.getVertexPosition(t, nn) : nn.fromBufferAttribute(i, t),
                            nn.applyMatrix4(e.matrixWorld),
                            this.expandByPoint(nn);
                    else
                        void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                        rn.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                        rn.copy(n.boundingBox)),
                        rn.applyMatrix4(e.matrixWorld),
                        this.union(rn)
                }
                const i = e.children;
                for (let e = 0, n = i.length; e < n; e++)
                    this.expandByObject(i[e], t);
                return this
            }
            containsPoint(e) {
                return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, nn),
                nn.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                n = e.normal.x * this.min.x),
                e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                n += e.normal.y * this.min.y),
                e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                n += e.normal.z * this.min.z),
                t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(dn),
                un.subVectors(this.max, dn),
                an.subVectors(e.a, dn),
                sn.subVectors(e.b, dn),
                on.subVectors(e.c, dn),
                ln.subVectors(sn, an),
                cn.subVectors(on, sn),
                hn.subVectors(an, on);
                let t = [0, -ln.z, ln.y, 0, -cn.z, cn.y, 0, -hn.z, hn.y, ln.z, 0, -ln.x, cn.z, 0, -cn.x, hn.z, 0, -hn.x, -ln.y, ln.x, 0, -cn.y, cn.x, 0, -hn.y, hn.x, 0];
                return !!mn(t, an, sn, on, un) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!mn(t, an, sn, on, un) && (fn.crossVectors(ln, cn),
                t = [fn.x, fn.y, fn.z],
                mn(t, an, sn, on, un)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, nn).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                e.radius = .5 * this.getSize(nn).length()),
                e
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (tn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                tn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                tn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                tn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                tn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                tn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                tn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                tn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(tn)),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const tn = [new Zt, new Zt, new Zt, new Zt, new Zt, new Zt, new Zt, new Zt]
          , nn = new Zt
          , rn = new en
          , an = new Zt
          , sn = new Zt
          , on = new Zt
          , ln = new Zt
          , cn = new Zt
          , hn = new Zt
          , dn = new Zt
          , un = new Zt
          , fn = new Zt
          , pn = new Zt;
        function mn(e, t, n, i, r) {
            for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                pn.fromArray(e, a);
                const s = r.x * Math.abs(pn.x) + r.y * Math.abs(pn.y) + r.z * Math.abs(pn.z)
                  , o = t.dot(pn)
                  , l = n.dot(pn)
                  , c = i.dot(pn);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                    return !1
            }
            return !0
        }
        const gn = new en
          , An = new Zt
          , _n = new Zt;
        class vn {
            constructor(e=new Zt, t=-1) {
                this.isSphere = !0,
                this.center = e,
                this.radius = t
            }
            set(e, t) {
                return this.center.copy(e),
                this.radius = t,
                this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : gn.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++)
                    i = Math.max(i, n.distanceToSquared(e[t]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.radius = e.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e),
                n > this.radius * this.radius && (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
                t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(),
                e) : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e),
                this.radius = this.radius * e.getMaxScaleOnAxis(),
                this
            }
            translate(e) {
                return this.center.add(e),
                this
            }
            expandByPoint(e) {
                if (this.isEmpty())
                    return this.center.copy(e),
                    this.radius = 0,
                    this;
                An.subVectors(e, this.center);
                const t = An.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t)
                      , n = .5 * (e - this.radius);
                    this.center.addScaledVector(An, n / e),
                    this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (_n.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(An.copy(e.center).add(_n)),
                this.expandByPoint(An.copy(e.center).sub(_n))),
                this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const wn = new Zt
          , yn = new Zt
          , xn = new Zt
          , bn = new Zt
          , Sn = new Zt
          , En = new Zt
          , Mn = new Zt;
        class Tn {
            constructor(e=new Zt, t=new Zt(0,0,-1)) {
                this.origin = e,
                this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e),
                this.direction.copy(t),
                this
            }
            copy(e) {
                return this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(),
                this
            }
            recast(e) {
                return this.origin.copy(this.at(e, wn)),
                this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = wn.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (wn.copy(this.origin).addScaledVector(this.direction, t),
                wn.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                yn.copy(e).add(t).multiplyScalar(.5),
                xn.copy(t).sub(e).normalize(),
                bn.copy(this.origin).sub(yn);
                const r = .5 * e.distanceTo(t)
                  , a = -this.direction.dot(xn)
                  , s = bn.dot(this.direction)
                  , o = -bn.dot(xn)
                  , l = bn.lengthSq()
                  , c = Math.abs(1 - a * a);
                let h, d, u, f;
                if (c > 0)
                    if (h = a * o - s,
                    d = a * s - o,
                    f = r * c,
                    h >= 0)
                        if (d >= -f)
                            if (d <= f) {
                                const e = 1 / c;
                                h *= e,
                                d *= e,
                                u = h * (h + a * d + 2 * s) + d * (a * h + d + 2 * o) + l
                            } else
                                d = r,
                                h = Math.max(0, -(a * d + s)),
                                u = -h * h + d * (d + 2 * o) + l;
                        else
                            d = -r,
                            h = Math.max(0, -(a * d + s)),
                            u = -h * h + d * (d + 2 * o) + l;
                    else
                        d <= -f ? (h = Math.max(0, -(-a * r + s)),
                        d = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                        u = -h * h + d * (d + 2 * o) + l) : d <= f ? (h = 0,
                        d = Math.min(Math.max(-r, -o), r),
                        u = d * (d + 2 * o) + l) : (h = Math.max(0, -(a * r + s)),
                        d = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                        u = -h * h + d * (d + 2 * o) + l);
                else
                    d = a > 0 ? -r : r,
                    h = Math.max(0, -(a * d + s)),
                    u = -h * h + d * (d + 2 * o) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, h),
                i && i.copy(yn).addScaledVector(xn, d),
                u
            }
            intersectSphere(e, t) {
                wn.subVectors(e.center, this.origin);
                const n = wn.dot(this.direction)
                  , i = wn.dot(wn) - n * n
                  , r = e.radius * e.radius;
                if (i > r)
                    return null;
                const a = Math.sqrt(r - i)
                  , s = n - a
                  , o = n + a;
                return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t)
                    return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t)
                    return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, a, s, o;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , h = 1 / this.direction.z
                  , d = this.origin;
                return l >= 0 ? (n = (e.min.x - d.x) * l,
                i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                i = (e.min.x - d.x) * l),
                c >= 0 ? (r = (e.min.y - d.y) * c,
                a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c,
                a = (e.min.y - d.y) * c),
                n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                (a < i || isNaN(i)) && (i = a),
                h >= 0 ? (s = (e.min.z - d.z) * h,
                o = (e.max.z - d.z) * h) : (s = (e.max.z - d.z) * h,
                o = (e.min.z - d.z) * h),
                n > o || s > i ? null : ((s > n || n != n) && (n = s),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, wn)
            }
            intersectTriangle(e, t, n, i, r) {
                Sn.subVectors(t, e),
                En.subVectors(n, e),
                Mn.crossVectors(Sn, En);
                let a, s = this.direction.dot(Mn);
                if (s > 0) {
                    if (i)
                        return null;
                    a = 1
                } else {
                    if (!(s < 0))
                        return null;
                    a = -1,
                    s = -s
                }
                bn.subVectors(this.origin, e);
                const o = a * this.direction.dot(En.crossVectors(bn, En));
                if (o < 0)
                    return null;
                const l = a * this.direction.dot(Sn.cross(bn));
                if (l < 0)
                    return null;
                if (o + l > s)
                    return null;
                const c = -a * bn.dot(Mn);
                return c < 0 ? null : this.at(c / s, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Cn {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, f, p, m) {
                Cn.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, a, s, o, l, c, h, d, u, f, p, m)
            }
            set(e, t, n, i, r, a, s, o, l, c, h, d, u, f, p, m) {
                const g = this.elements;
                return g[0] = e,
                g[4] = t,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = a,
                g[9] = s,
                g[13] = o,
                g[2] = l,
                g[6] = c,
                g[10] = h,
                g[14] = d,
                g[3] = u,
                g[7] = f,
                g[11] = p,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Cn).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                t[9] = n[9],
                t[10] = n[10],
                t[11] = n[11],
                t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                t[15] = n[15],
                this
            }
            copyPosition(e) {
                const t = this.elements
                  , n = e.elements;
                return t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0),
                t.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(e) {
                const t = this.elements
                  , n = e.elements
                  , i = 1 / In.setFromMatrixColumn(e, 0).length()
                  , r = 1 / In.setFromMatrixColumn(e, 1).length()
                  , a = 1 / In.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i,
                t[1] = n[1] * i,
                t[2] = n[2] * i,
                t[3] = 0,
                t[4] = n[4] * r,
                t[5] = n[5] * r,
                t[6] = n[6] * r,
                t[7] = 0,
                t[8] = n[8] * a,
                t[9] = n[9] * a,
                t[10] = n[10] * a,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromEuler(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z
                  , a = Math.cos(n)
                  , s = Math.sin(n)
                  , o = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , h = Math.sin(r);
                if ("XYZ" === e.order) {
                    const e = a * c
                      , n = a * h
                      , i = s * c
                      , r = s * h;
                    t[0] = o * c,
                    t[4] = -o * h,
                    t[8] = l,
                    t[1] = n + i * l,
                    t[5] = e - r * l,
                    t[9] = -s * o,
                    t[2] = r - e * l,
                    t[6] = i + n * l,
                    t[10] = a * o
                } else if ("YXZ" === e.order) {
                    const e = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    t[0] = e + r * s,
                    t[4] = i * s - n,
                    t[8] = a * l,
                    t[1] = a * h,
                    t[5] = a * c,
                    t[9] = -s,
                    t[2] = n * s - i,
                    t[6] = r + e * s,
                    t[10] = a * o
                } else if ("ZXY" === e.order) {
                    const e = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    t[0] = e - r * s,
                    t[4] = -a * h,
                    t[8] = i + n * s,
                    t[1] = n + i * s,
                    t[5] = a * c,
                    t[9] = r - e * s,
                    t[2] = -a * l,
                    t[6] = s,
                    t[10] = a * o
                } else if ("ZYX" === e.order) {
                    const e = a * c
                      , n = a * h
                      , i = s * c
                      , r = s * h;
                    t[0] = o * c,
                    t[4] = i * l - n,
                    t[8] = e * l + r,
                    t[1] = o * h,
                    t[5] = r * l + e,
                    t[9] = n * l - i,
                    t[2] = -l,
                    t[6] = s * o,
                    t[10] = a * o
                } else if ("YZX" === e.order) {
                    const e = a * o
                      , n = a * l
                      , i = s * o
                      , r = s * l;
                    t[0] = o * c,
                    t[4] = r - e * h,
                    t[8] = i * h + n,
                    t[1] = h,
                    t[5] = a * c,
                    t[9] = -s * c,
                    t[2] = -l * c,
                    t[6] = n * h + i,
                    t[10] = e - r * h
                } else if ("XZY" === e.order) {
                    const e = a * o
                      , n = a * l
                      , i = s * o
                      , r = s * l;
                    t[0] = o * c,
                    t[4] = -h,
                    t[8] = l * c,
                    t[1] = e * h + r,
                    t[5] = a * c,
                    t[9] = n * h - i,
                    t[2] = i * h - n,
                    t[6] = s * c,
                    t[10] = r * h + e
                }
                return t[3] = 0,
                t[7] = 0,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(Pn, e, Bn)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return Un.subVectors(e, t),
                0 === Un.lengthSq() && (Un.z = 1),
                Un.normalize(),
                Dn.crossVectors(n, Un),
                0 === Dn.lengthSq() && (1 === Math.abs(n.z) ? Un.x += 1e-4 : Un.z += 1e-4,
                Un.normalize(),
                Dn.crossVectors(n, Un)),
                Dn.normalize(),
                Ln.crossVectors(Un, Dn),
                i[0] = Dn.x,
                i[4] = Ln.x,
                i[8] = Un.x,
                i[1] = Dn.y,
                i[5] = Ln.y,
                i[9] = Un.y,
                i[2] = Dn.z,
                i[6] = Ln.z,
                i[10] = Un.z,
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , a = n[0]
                  , s = n[4]
                  , o = n[8]
                  , l = n[12]
                  , c = n[1]
                  , h = n[5]
                  , d = n[9]
                  , u = n[13]
                  , f = n[2]
                  , p = n[6]
                  , m = n[10]
                  , g = n[14]
                  , A = n[3]
                  , _ = n[7]
                  , v = n[11]
                  , w = n[15]
                  , y = i[0]
                  , x = i[4]
                  , b = i[8]
                  , S = i[12]
                  , E = i[1]
                  , M = i[5]
                  , T = i[9]
                  , C = i[13]
                  , I = i[2]
                  , R = i[6]
                  , P = i[10]
                  , B = i[14]
                  , D = i[3]
                  , L = i[7]
                  , U = i[11]
                  , N = i[15];
                return r[0] = a * y + s * E + o * I + l * D,
                r[4] = a * x + s * M + o * R + l * L,
                r[8] = a * b + s * T + o * P + l * U,
                r[12] = a * S + s * C + o * B + l * N,
                r[1] = c * y + h * E + d * I + u * D,
                r[5] = c * x + h * M + d * R + u * L,
                r[9] = c * b + h * T + d * P + u * U,
                r[13] = c * S + h * C + d * B + u * N,
                r[2] = f * y + p * E + m * I + g * D,
                r[6] = f * x + p * M + m * R + g * L,
                r[10] = f * b + p * T + m * P + g * U,
                r[14] = f * S + p * C + m * B + g * N,
                r[3] = A * y + _ * E + v * I + w * D,
                r[7] = A * x + _ * M + v * R + w * L,
                r[11] = A * b + _ * T + v * P + w * U,
                r[15] = A * S + _ * C + v * B + w * N,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[4] *= e,
                t[8] *= e,
                t[12] *= e,
                t[1] *= e,
                t[5] *= e,
                t[9] *= e,
                t[13] *= e,
                t[2] *= e,
                t[6] *= e,
                t[10] *= e,
                t[14] *= e,
                t[3] *= e,
                t[7] *= e,
                t[11] *= e,
                t[15] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[4]
                  , i = e[8]
                  , r = e[12]
                  , a = e[1]
                  , s = e[5]
                  , o = e[9]
                  , l = e[13]
                  , c = e[2]
                  , h = e[6]
                  , d = e[10]
                  , u = e[14];
                return e[3] * (+r * o * h - i * l * h - r * s * d + n * l * d + i * s * u - n * o * u) + e[7] * (+t * o * u - t * l * d + r * a * d - i * a * u + i * l * c - r * o * c) + e[11] * (+t * l * h - t * s * u - r * a * h + n * a * u + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * h + t * s * d + i * a * h - n * a * d + n * o * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z) : (i[12] = e,
                i[13] = t,
                i[14] = n),
                this
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , h = e[9]
                  , d = e[10]
                  , u = e[11]
                  , f = e[12]
                  , p = e[13]
                  , m = e[14]
                  , g = e[15]
                  , A = h * m * l - p * d * l + p * o * u - s * m * u - h * o * g + s * d * g
                  , _ = f * d * l - c * m * l - f * o * u + a * m * u + c * o * g - a * d * g
                  , v = c * p * l - f * h * l + f * s * u - a * p * u - c * s * g + a * h * g
                  , w = f * h * o - c * p * o - f * s * d + a * p * d + c * s * m - a * h * m
                  , y = t * A + n * _ + i * v + r * w;
                if (0 === y)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const x = 1 / y;
                return e[0] = A * x,
                e[1] = (p * d * r - h * m * r - p * i * u + n * m * u + h * i * g - n * d * g) * x,
                e[2] = (s * m * r - p * o * r + p * i * l - n * m * l - s * i * g + n * o * g) * x,
                e[3] = (h * o * r - s * d * r - h * i * l + n * d * l + s * i * u - n * o * u) * x,
                e[4] = _ * x,
                e[5] = (c * m * r - f * d * r + f * i * u - t * m * u - c * i * g + t * d * g) * x,
                e[6] = (f * o * r - a * m * r - f * i * l + t * m * l + a * i * g - t * o * g) * x,
                e[7] = (a * d * r - c * o * r + c * i * l - t * d * l - a * i * u + t * o * u) * x,
                e[8] = v * x,
                e[9] = (f * h * r - c * p * r - f * n * u + t * p * u + c * n * g - t * h * g) * x,
                e[10] = (a * p * r - f * s * r + f * n * l - t * p * l - a * n * g + t * s * g) * x,
                e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * u - t * s * u) * x,
                e[12] = w * x,
                e[13] = (c * p * i - f * h * i + f * n * d - t * p * d - c * n * m + t * h * m) * x,
                e[14] = (f * s * i - a * p * i - f * n * o + t * p * o + a * n * m - t * s * m) * x,
                e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * d + t * s * d) * x,
                this
            }
            scale(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z;
                return t[0] *= n,
                t[4] *= i,
                t[8] *= r,
                t[1] *= n,
                t[5] *= i,
                t[9] *= r,
                t[2] *= n,
                t[6] *= i,
                t[10] *= r,
                t[3] *= n,
                t[7] *= i,
                t[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const e = this.elements
                  , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                  , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                  , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = 1 - n
                  , a = e.x
                  , s = e.y
                  , o = e.z
                  , l = r * a
                  , c = r * s;
                return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(e, t, n, i, r, a) {
                return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(e, t, n) {
                const i = this.elements
                  , r = t._x
                  , a = t._y
                  , s = t._z
                  , o = t._w
                  , l = r + r
                  , c = a + a
                  , h = s + s
                  , d = r * l
                  , u = r * c
                  , f = r * h
                  , p = a * c
                  , m = a * h
                  , g = s * h
                  , A = o * l
                  , _ = o * c
                  , v = o * h
                  , w = n.x
                  , y = n.y
                  , x = n.z;
                return i[0] = (1 - (p + g)) * w,
                i[1] = (u + v) * w,
                i[2] = (f - _) * w,
                i[3] = 0,
                i[4] = (u - v) * y,
                i[5] = (1 - (d + g)) * y,
                i[6] = (m + A) * y,
                i[7] = 0,
                i[8] = (f + _) * x,
                i[9] = (m - A) * x,
                i[10] = (1 - (d + p)) * x,
                i[11] = 0,
                i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z,
                i[15] = 1,
                this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = In.set(i[0], i[1], i[2]).length();
                const a = In.set(i[4], i[5], i[6]).length()
                  , s = In.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                e.x = i[12],
                e.y = i[13],
                e.z = i[14],
                Rn.copy(this);
                const o = 1 / r
                  , l = 1 / a
                  , c = 1 / s;
                return Rn.elements[0] *= o,
                Rn.elements[1] *= o,
                Rn.elements[2] *= o,
                Rn.elements[4] *= l,
                Rn.elements[5] *= l,
                Rn.elements[6] *= l,
                Rn.elements[8] *= c,
                Rn.elements[9] *= c,
                Rn.elements[10] *= c,
                t.setFromRotationMatrix(Rn),
                n.x = r,
                n.y = a,
                n.z = s,
                this
            }
            makePerspective(e, t, n, i, r, a, s=2e3) {
                const o = this.elements
                  , l = 2 * r / (t - e)
                  , c = 2 * r / (n - i)
                  , h = (t + e) / (t - e)
                  , d = (n + i) / (n - i);
                let u, f;
                if (s === ht)
                    u = -(a + r) / (a - r),
                    f = -2 * a * r / (a - r);
                else {
                    if (s !== dt)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                    u = -a / (a - r),
                    f = -a * r / (a - r)
                }
                return o[0] = l,
                o[4] = 0,
                o[8] = h,
                o[12] = 0,
                o[1] = 0,
                o[5] = c,
                o[9] = d,
                o[13] = 0,
                o[2] = 0,
                o[6] = 0,
                o[10] = u,
                o[14] = f,
                o[3] = 0,
                o[7] = 0,
                o[11] = -1,
                o[15] = 0,
                this
            }
            makeOrthographic(e, t, n, i, r, a, s=2e3) {
                const o = this.elements
                  , l = 1 / (t - e)
                  , c = 1 / (n - i)
                  , h = 1 / (a - r)
                  , d = (t + e) * l
                  , u = (n + i) * c;
                let f, p;
                if (s === ht)
                    f = (a + r) * h,
                    p = -2 * h;
                else {
                    if (s !== dt)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                    f = r * h,
                    p = -1 * h
                }
                return o[0] = 2 * l,
                o[4] = 0,
                o[8] = 0,
                o[12] = -d,
                o[1] = 0,
                o[5] = 2 * c,
                o[9] = 0,
                o[13] = -u,
                o[2] = 0,
                o[6] = 0,
                o[10] = p,
                o[14] = -f,
                o[3] = 0,
                o[7] = 0,
                o[11] = 0,
                o[15] = 1,
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 16; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e[t + 9] = n[9],
                e[t + 10] = n[10],
                e[t + 11] = n[11],
                e[t + 12] = n[12],
                e[t + 13] = n[13],
                e[t + 14] = n[14],
                e[t + 15] = n[15],
                e
            }
        }
        const In = new Zt
          , Rn = new Cn
          , Pn = new Zt(0,0,0)
          , Bn = new Zt(1,1,1)
          , Dn = new Zt
          , Ln = new Zt
          , Un = new Zt
          , Nn = new Cn
          , kn = new Kt;
        class Fn {
            constructor(e=0, t=0, n=0, i=Fn.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e,
                this._onChangeCallback()
            }
            set(e, t, n, i=this._order) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._order = e._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e, t=this._order, n=!0) {
                const i = e.elements
                  , r = i[0]
                  , a = i[4]
                  , s = i[8]
                  , o = i[1]
                  , l = i[5]
                  , c = i[9]
                  , h = i[2]
                  , d = i[6]
                  , u = i[10];
                switch (t) {
                case "XYZ":
                    this._y = Math.asin(_t(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u),
                    this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-_t(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u),
                    this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(_t(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u),
                    this._z = Math.atan2(-a, l)) : (this._y = 0,
                    this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-_t(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u),
                    this._z = Math.atan2(o, r)) : (this._x = 0,
                    this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(_t(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-h, r)) : (this._x = 0,
                    this._y = Math.atan2(s, u));
                    break;
                case "XZY":
                    this._z = Math.asin(-_t(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                    this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(e, t, n) {
                return Nn.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(Nn, t, n)
            }
            setFromVector3(e, t=this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return kn.setFromEuler(this),
                this.setFromQuaternion(kn, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0],
                this._y = e[1],
                this._z = e[2],
                void 0 !== e[3] && (this._order = e[3]),
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._order,
                e
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        Fn.DEFAULT_ORDER = "XYZ";
        class On {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = 1 << e >>> 0
            }
            enable(e) {
                this.mask |= 1 << e
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e
            }
            disable(e) {
                this.mask &= ~(1 << e)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return !!(this.mask & e.mask)
            }
            isEnabled(e) {
                return !!(this.mask & 1 << e)
            }
        }
        let zn = 0;
        const Hn = new Zt
          , Wn = new Kt
          , Vn = new Cn
          , Gn = new Zt
          , Qn = new Zt
          , Xn = new Zt
          , jn = new Kt
          , qn = new Zt(1,0,0)
          , Yn = new Zt(0,1,0)
          , Kn = new Zt(0,0,1)
          , Zn = {
            type: "added"
        }
          , Jn = {
            type: "removed"
        }
          , $n = {
            type: "childadded",
            child: null
        }
          , ei = {
            type: "childremoved",
            child: null
        };
        class ti extends ut {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: zn++
                }),
                this.uuid = At(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = ti.DEFAULT_UP.clone();
                const e = new Zt
                  , t = new Fn
                  , n = new Kt
                  , i = new Zt(1,1,1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                }
                )),
                n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Cn
                    },
                    normalMatrix: {
                        value: new Et
                    }
                }),
                this.matrix = new Cn,
                this.matrixWorld = new Cn,
                this.matrixAutoUpdate = ti.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldAutoUpdate = ti.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new On,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e),
                this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return Wn.setFromAxisAngle(e, t),
                this.quaternion.multiply(Wn),
                this
            }
            rotateOnWorldAxis(e, t) {
                return Wn.setFromAxisAngle(e, t),
                this.quaternion.premultiply(Wn),
                this
            }
            rotateX(e) {
                return this.rotateOnAxis(qn, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(Yn, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(Kn, e)
            }
            translateOnAxis(e, t) {
                return Hn.copy(e).applyQuaternion(this.quaternion),
                this.position.add(Hn.multiplyScalar(t)),
                this
            }
            translateX(e) {
                return this.translateOnAxis(qn, e)
            }
            translateY(e) {
                return this.translateOnAxis(Yn, e)
            }
            translateZ(e) {
                return this.translateOnAxis(Kn, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(Vn.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? Gn.copy(e) : Gn.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                Qn.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Vn.lookAt(Qn, Gn, this.up) : Vn.lookAt(Gn, Qn, this.up),
                this.quaternion.setFromRotationMatrix(Vn),
                i && (Vn.extractRotation(i.matrixWorld),
                Wn.setFromRotationMatrix(Vn),
                this.quaternion.premultiply(Wn.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                this) : (e && e.isObject3D ? (e.removeFromParent(),
                e.parent = this,
                this.children.push(e),
                e.dispatchEvent(Zn),
                $n.child = e,
                this.dispatchEvent($n),
                $n.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null,
                this.children.splice(t, 1),
                e.dispatchEvent(Jn),
                ei.child = e,
                this.dispatchEvent(ei),
                ei.child = null),
                this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1),
                Vn.copy(this.matrixWorld).invert(),
                null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                Vn.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(Vn),
                e.removeFromParent(),
                e.parent = this,
                this.children.push(e),
                e.updateWorldMatrix(!1, !0),
                e.dispatchEvent(Zn),
                $n.child = e,
                this.dispatchEvent($n),
                $n.child = null,
                this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i)
                        return i
                }
            }
            getObjectsByProperty(e, t, n=[]) {
                this[e] === t && n.push(this);
                const i = this.children;
                for (let r = 0, a = i.length; r < a; r++)
                    i[r].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Qn, e, Xn),
                e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Qn, jn, e),
                e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible)
                    return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t),
                t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                this.matrixWorldNeedsUpdate = !1,
                e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) {
                    t[n].updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        e[t].updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e
                  , n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                i.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isBatchedMesh && (i.type = "BatchedMesh",
                i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                i.sortObjects = this.sortObjects,
                i.drawRanges = this._drawRanges,
                i.reservedRanges = this._reservedRanges,
                i.visibility = this._visibility,
                i.active = this._active,
                i.bounds = this._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    boxMin: e.box.min.toArray(),
                    boxMax: e.box.max.toArray(),
                    sphereInitialized: e.sphereInitialized,
                    sphereRadius: e.sphere.radius,
                    sphereCenter: e.sphere.center.toArray()
                }))),
                i.maxInstanceCount = this._maxInstanceCount,
                i.maxVertexCount = this._maxVertexCount,
                i.maxIndexCount = this._maxIndexCount,
                i.geometryInitialized = this._geometryInitialized,
                i.geometryCount = this._geometryCount,
                i.matricesTexture = this._matricesTexture.toJSON(e),
                null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)),
                null !== this.boundingSphere && (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius
                }),
                null !== this.boundingBox && (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray()
                })),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(e.shapes, i)
                            }
                        else
                            r(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            t.push(r(e.materials, this.material[n]));
                        i.material = t
                    } else
                        i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++)
                        i.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(e.animations, n))
                    }
                }
                if (t) {
                    const t = a(e.geometries)
                      , i = a(e.materials)
                      , r = a(e.textures)
                      , s = a(e.images)
                      , o = a(e.shapes)
                      , l = a(e.skeletons)
                      , c = a(e.animations)
                      , h = a(e.nodes);
                    t.length > 0 && (n.geometries = t),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    s.length > 0 && (n.images = s),
                    o.length > 0 && (n.shapes = o),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c),
                    h.length > 0 && (n.nodes = h)
                }
                return n.object = i,
                n;
                function a(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e, t=!0) {
                if (this.name = e.name,
                this.up.copy(e.up),
                this.position.copy(e.position),
                this.rotation.order = e.rotation.order,
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                this.layers.mask = e.layers.mask,
                this.visible = e.visible,
                this.castShadow = e.castShadow,
                this.receiveShadow = e.receiveShadow,
                this.frustumCulled = e.frustumCulled,
                this.renderOrder = e.renderOrder,
                this.animations = e.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                !0 === t)
                    for (let t = 0; t < e.children.length; t++) {
                        const n = e.children[t];
                        this.add(n.clone())
                    }
                return this
            }
        }
        ti.DEFAULT_UP = new Zt(0,1,0),
        ti.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        ti.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const ni = new Zt
          , ii = new Zt
          , ri = new Zt
          , ai = new Zt
          , si = new Zt
          , oi = new Zt
          , li = new Zt
          , ci = new Zt
          , hi = new Zt
          , di = new Zt
          , ui = new Qt
          , fi = new Qt
          , pi = new Qt;
        class mi {
            constructor(e=new Zt, t=new Zt, n=new Zt) {
                this.a = e,
                this.b = t,
                this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t),
                ni.subVectors(e, t),
                i.cross(ni);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                ni.subVectors(i, t),
                ii.subVectors(n, t),
                ri.subVectors(e, t);
                const a = ni.dot(ni)
                  , s = ni.dot(ii)
                  , o = ni.dot(ri)
                  , l = ii.dot(ii)
                  , c = ii.dot(ri)
                  , h = a * l - s * s;
                if (0 === h)
                    return r.set(0, 0, 0),
                    null;
                const d = 1 / h
                  , u = (l * o - s * c) * d
                  , f = (a * c - s * o) * d;
                return r.set(1 - u - f, f, u)
            }
            static containsPoint(e, t, n, i) {
                return null !== this.getBarycoord(e, t, n, i, ai) && (ai.x >= 0 && ai.y >= 0 && ai.x + ai.y <= 1)
            }
            static getInterpolation(e, t, n, i, r, a, s, o) {
                return null === this.getBarycoord(e, t, n, i, ai) ? (o.x = 0,
                o.y = 0,
                "z"in o && (o.z = 0),
                "w"in o && (o.w = 0),
                null) : (o.setScalar(0),
                o.addScaledVector(r, ai.x),
                o.addScaledVector(a, ai.y),
                o.addScaledVector(s, ai.z),
                o)
            }
            static getInterpolatedAttribute(e, t, n, i, r, a) {
                return ui.setScalar(0),
                fi.setScalar(0),
                pi.setScalar(0),
                ui.fromBufferAttribute(e, t),
                fi.fromBufferAttribute(e, n),
                pi.fromBufferAttribute(e, i),
                a.setScalar(0),
                a.addScaledVector(ui, r.x),
                a.addScaledVector(fi, r.y),
                a.addScaledVector(pi, r.z),
                a
            }
            static isFrontFacing(e, t, n, i) {
                return ni.subVectors(n, t),
                ii.subVectors(e, t),
                ni.cross(ii).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e),
                this.b.copy(t),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]),
                this.b.copy(e[n]),
                this.c.copy(e[i]),
                this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t),
                this.b.fromBufferAttribute(e, n),
                this.c.fromBufferAttribute(e, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a),
                this.b.copy(e.b),
                this.c.copy(e.c),
                this
            }
            getArea() {
                return ni.subVectors(this.c, this.b),
                ii.subVectors(this.a, this.b),
                .5 * ni.cross(ii).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return mi.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return mi.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getInterpolation(e, t, n, i, r) {
                return mi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return mi.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return mi.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let a, s;
                si.subVectors(i, n),
                oi.subVectors(r, n),
                ci.subVectors(e, n);
                const o = si.dot(ci)
                  , l = oi.dot(ci);
                if (o <= 0 && l <= 0)
                    return t.copy(n);
                hi.subVectors(e, i);
                const c = si.dot(hi)
                  , h = oi.dot(hi);
                if (c >= 0 && h <= c)
                    return t.copy(i);
                const d = o * h - c * l;
                if (d <= 0 && o >= 0 && c <= 0)
                    return a = o / (o - c),
                    t.copy(n).addScaledVector(si, a);
                di.subVectors(e, r);
                const u = si.dot(di)
                  , f = oi.dot(di);
                if (f >= 0 && u <= f)
                    return t.copy(r);
                const p = u * l - o * f;
                if (p <= 0 && l >= 0 && f <= 0)
                    return s = l / (l - f),
                    t.copy(n).addScaledVector(oi, s);
                const m = c * f - u * h;
                if (m <= 0 && h - c >= 0 && u - f >= 0)
                    return li.subVectors(r, i),
                    s = (h - c) / (h - c + (u - f)),
                    t.copy(i).addScaledVector(li, s);
                const g = 1 / (m + p + d);
                return a = p * g,
                s = d * g,
                t.copy(n).addScaledVector(si, a).addScaledVector(oi, s)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const gi = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Ai = {
            h: 0,
            s: 0,
            l: 0
        }
          , _i = {
            h: 0,
            s: 0,
            l: 0
        };
        function vi(e, t, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class wi {
            constructor(e, t, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                } else
                    this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e,
                this.g = e,
                this.b = e,
                this
            }
            setHex(e, t=Ye) {
                return e = Math.floor(e),
                this.r = (e >> 16 & 255) / 255,
                this.g = (e >> 8 & 255) / 255,
                this.b = (255 & e) / 255,
                Ut.toWorkingColorSpace(this, t),
                this
            }
            setRGB(e, t, n, i=Ut.workingColorSpace) {
                return this.r = e,
                this.g = t,
                this.b = n,
                Ut.toWorkingColorSpace(this, i),
                this
            }
            setHSL(e, t, n, i=Ut.workingColorSpace) {
                if (e = vt(e, 1),
                t = _t(t, 0, 1),
                n = _t(n, 0, 1),
                0 === t)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t
                      , r = 2 * n - i;
                    this.r = vi(r, i, e + 1 / 3),
                    this.g = vi(r, i, e),
                    this.b = vi(r, i, e - 1 / 3)
                }
                return Ut.toWorkingColorSpace(this, i),
                this
            }
            setStyle(e, t=Ye) {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let r;
                    const a = i[1]
                      , s = i[2];
                    switch (a) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const n = i[1]
                      , r = n.length;
                    if (3 === r)
                        return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                    if (6 === r)
                        return this.setHex(parseInt(n, 16), t);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0)
                    return this.setColorName(e, t);
                return this
            }
            setColorName(e, t=Ye) {
                const n = gi[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copySRGBToLinear(e) {
                return this.r = Nt(e.r),
                this.g = Nt(e.g),
                this.b = Nt(e.b),
                this
            }
            copyLinearToSRGB(e) {
                return this.r = kt(e.r),
                this.g = kt(e.g),
                this.b = kt(e.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(e=Ye) {
                return Ut.fromWorkingColorSpace(yi.copy(this), e),
                65536 * Math.round(_t(255 * yi.r, 0, 255)) + 256 * Math.round(_t(255 * yi.g, 0, 255)) + Math.round(_t(255 * yi.b, 0, 255))
            }
            getHexString(e=Ye) {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, t=Ut.workingColorSpace) {
                Ut.fromWorkingColorSpace(yi.copy(this), t);
                const n = yi.r
                  , i = yi.g
                  , r = yi.b
                  , a = Math.max(n, i, r)
                  , s = Math.min(n, i, r);
                let o, l;
                const c = (s + a) / 2;
                if (s === a)
                    o = 0,
                    l = 0;
                else {
                    const e = a - s;
                    switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s),
                    a) {
                    case n:
                        o = (i - r) / e + (i < r ? 6 : 0);
                        break;
                    case i:
                        o = (r - n) / e + 2;
                        break;
                    case r:
                        o = (n - i) / e + 4
                    }
                    o /= 6
                }
                return e.h = o,
                e.s = l,
                e.l = c,
                e
            }
            getRGB(e, t=Ut.workingColorSpace) {
                return Ut.fromWorkingColorSpace(yi.copy(this), t),
                e.r = yi.r,
                e.g = yi.g,
                e.b = yi.b,
                e
            }
            getStyle(e=Ye) {
                Ut.fromWorkingColorSpace(yi.copy(this), e);
                const t = yi.r
                  , n = yi.g
                  , i = yi.b;
                return e !== Ye ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(Ai),
                this.setHSL(Ai.h + e, Ai.s + t, Ai.l + n)
            }
            add(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addColors(e, t) {
                return this.r = e.r + t.r,
                this.g = e.g + t.g,
                this.b = e.b + t.b,
                this
            }
            addScalar(e) {
                return this.r += e,
                this.g += e,
                this.b += e,
                this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r),
                this.g = Math.max(0, this.g - e.g),
                this.b = Math.max(0, this.b - e.b),
                this
            }
            multiply(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyScalar(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t,
                this.g += (e.g - this.g) * t,
                this.b += (e.b - this.b) * t,
                this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n,
                this.g = e.g + (t.g - e.g) * n,
                this.b = e.b + (t.b - e.b) * n,
                this
            }
            lerpHSL(e, t) {
                this.getHSL(Ai),
                e.getHSL(_i);
                const n = wt(Ai.h, _i.h, t)
                  , i = wt(Ai.s, _i.s, t)
                  , r = wt(Ai.l, _i.l, t);
                return this.setHSL(n, i, r),
                this
            }
            setFromVector3(e) {
                return this.r = e.x,
                this.g = e.y,
                this.b = e.z,
                this
            }
            applyMatrix3(e) {
                const t = this.r
                  , n = this.g
                  , i = this.b
                  , r = e.elements;
                return this.r = r[0] * t + r[3] * n + r[6] * i,
                this.g = r[1] * t + r[4] * n + r[7] * i,
                this.b = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t=0) {
                return this.r = e[t],
                this.g = e[t + 1],
                this.b = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t),
                this.g = e.getY(t),
                this.b = e.getZ(t),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const yi = new wi;
        wi.NAMES = gi;
        let xi = 0;
        class bi extends ut {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: xi++
                }),
                this.uuid = At(),
                this.name = "",
                this.type = "Material",
                this.blending = 1,
                this.side = 0,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = 204,
                this.blendDst = 205,
                this.blendEquation = a,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.blendColor = new wi(0,0,0),
                this.blendAlpha = 0,
                this.depthFunc = 3,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = 519,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = $e,
                this.stencilZFail = $e,
                this.stencilZPass = $e,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++,
                this._alphaTest = e
            }
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.dispersion && (n.dispersion = this.dispersion),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                0 !== this.side && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
                205 !== this.blendDst && (n.blendDst = this.blendDst),
                this.blendEquation !== a && (n.blendEquation = this.blendEquation),
                null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
                !1 === this.depthTest && (n.depthTest = this.depthTest),
                !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                this.stencilFail !== $e && (n.stencilFail = this.stencilFail),
                this.stencilZFail !== $e && (n.stencilZFail = this.stencilZFail),
                this.stencilZPass !== $e && (n.stencilZPass = this.stencilZPass),
                !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t) {
                    const t = i(e.textures)
                      , r = i(e.images);
                    t.length > 0 && (n.textures = t),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name,
                this.blending = e.blending,
                this.side = e.side,
                this.vertexColors = e.vertexColors,
                this.opacity = e.opacity,
                this.transparent = e.transparent,
                this.blendSrc = e.blendSrc,
                this.blendDst = e.blendDst,
                this.blendEquation = e.blendEquation,
                this.blendSrcAlpha = e.blendSrcAlpha,
                this.blendDstAlpha = e.blendDstAlpha,
                this.blendEquationAlpha = e.blendEquationAlpha,
                this.blendColor.copy(e.blendColor),
                this.blendAlpha = e.blendAlpha,
                this.depthFunc = e.depthFunc,
                this.depthTest = e.depthTest,
                this.depthWrite = e.depthWrite,
                this.stencilWriteMask = e.stencilWriteMask,
                this.stencilFunc = e.stencilFunc,
                this.stencilRef = e.stencilRef,
                this.stencilFuncMask = e.stencilFuncMask,
                this.stencilFail = e.stencilFail,
                this.stencilZFail = e.stencilZFail,
                this.stencilZPass = e.stencilZPass,
                this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let i = 0; i !== e; ++i)
                        n[i] = t[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = e.clipIntersection,
                this.clipShadows = e.clipShadows,
                this.shadowSide = e.shadowSide,
                this.colorWrite = e.colorWrite,
                this.precision = e.precision,
                this.polygonOffset = e.polygonOffset,
                this.polygonOffsetFactor = e.polygonOffsetFactor,
                this.polygonOffsetUnits = e.polygonOffsetUnits,
                this.dithering = e.dithering,
                this.alphaTest = e.alphaTest,
                this.alphaHash = e.alphaHash,
                this.alphaToCoverage = e.alphaToCoverage,
                this.premultipliedAlpha = e.premultipliedAlpha,
                this.forceSinglePass = e.forceSinglePass,
                this.visible = e.visible,
                this.toneMapped = e.toneMapped,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            onBuild() {
                console.warn("Material: onBuild() has been removed.")
            }
        }
        class Si extends bi {
            constructor(e) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new wi(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new Fn,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        const Ei = new Zt
          , Mi = new St;
        let Ti = 0;
        class Ci {
            constructor(e, t, n=!1) {
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                Object.defineProperty(this, "id", {
                    value: Ti++
                }),
                this.name = "",
                this.array = e,
                this.itemSize = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.normalized = n,
                this.usage = lt,
                this.updateRanges = [],
                this.gpuType = J,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name,
                this.array = new e.array.constructor(e.array),
                this.itemSize = e.itemSize,
                this.count = e.count,
                this.normalized = e.normalized,
                this.usage = e.usage,
                this.gpuType = e.gpuType,
                this
            }
            copyAt(e, t, n) {
                e *= this.itemSize,
                n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e),
                this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Mi.fromBufferAttribute(this, t),
                        Mi.applyMatrix3(e),
                        this.setXY(t, Mi.x, Mi.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Ei.fromBufferAttribute(this, t),
                        Ei.applyMatrix3(e),
                        this.setXYZ(t, Ei.x, Ei.y, Ei.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Ei.fromBufferAttribute(this, t),
                    Ei.applyMatrix4(e),
                    this.setXYZ(t, Ei.x, Ei.y, Ei.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Ei.fromBufferAttribute(this, t),
                    Ei.applyNormalMatrix(e),
                    this.setXYZ(t, Ei.x, Ei.y, Ei.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Ei.fromBufferAttribute(this, t),
                    Ei.transformDirection(e),
                    this.setXYZ(t, Ei.x, Ei.y, Ei.z);
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = yt(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = xt(n, this.array)),
                this.array[e * this.itemSize + t] = n,
                this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            setX(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.array[e * this.itemSize] = t,
                this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            setY(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.array[e * this.itemSize + 1] = t,
                this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            setZ(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.array[e * this.itemSize + 2] = t,
                this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            setW(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.array[e * this.itemSize + 3] = t,
                this
            }
            setXY(e, t, n) {
                return e *= this.itemSize,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array),
                i = xt(i, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array),
                i = xt(i, this.array),
                r = xt(r, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this.array[e + 3] = r,
                this
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name),
                this.usage !== lt && (e.usage = this.usage),
                e
            }
        }
        class Ii extends Ci {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class Ri extends Ci {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class Pi extends Ci {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let Bi = 0;
        const Di = new Cn
          , Li = new ti
          , Ui = new Zt
          , Ni = new en
          , ki = new en
          , Fi = new Zt;
        class Oi extends ut {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: Bi++
                }),
                this.uuid = At(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.indirect = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new (Tt(e) ? Ri : Ii)(e,1) : this.index = e,
                this
            }
            setIndirect(e) {
                return this.indirect = e,
                this
            }
            getIndirect() {
                return this.indirect
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t,
                this
            }
            deleteAttribute(e) {
                return delete this.attributes[e],
                this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t, n=0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e,
                this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e),
                t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new Et).getNormalMatrix(e);
                    n.applyNormalMatrix(t),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(e) {
                return Di.makeRotationFromQuaternion(e),
                this.applyMatrix4(Di),
                this
            }
            rotateX(e) {
                return Di.makeRotationX(e),
                this.applyMatrix4(Di),
                this
            }
            rotateY(e) {
                return Di.makeRotationY(e),
                this.applyMatrix4(Di),
                this
            }
            rotateZ(e) {
                return Di.makeRotationZ(e),
                this.applyMatrix4(Di),
                this
            }
            translate(e, t, n) {
                return Di.makeTranslation(e, t, n),
                this.applyMatrix4(Di),
                this
            }
            scale(e, t, n) {
                return Di.makeScale(e, t, n),
                this.applyMatrix4(Di),
                this
            }
            lookAt(e) {
                return Li.lookAt(e),
                Li.updateMatrix(),
                this.applyMatrix4(Li.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Ui).negate(),
                this.translate(Ui.x, Ui.y, Ui.z),
                this
            }
            setFromPoints(e) {
                const t = this.getAttribute("position");
                if (void 0 === t) {
                    const t = [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    this.setAttribute("position", new Pi(t,3))
                } else {
                    const n = Math.min(e.length, t.count);
                    for (let i = 0; i < n; i++) {
                        const n = e[i];
                        t.setXYZ(i, n.x, n.y, n.z || 0)
                    }
                    e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                    t.needsUpdate = !0
                }
                return this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new en);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                    void this.boundingBox.set(new Zt(-1 / 0,-1 / 0,-1 / 0), new Zt(1 / 0,1 / 0,1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Ni.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Fi.addVectors(this.boundingBox.min, Ni.min),
                            this.boundingBox.expandByPoint(Fi),
                            Fi.addVectors(this.boundingBox.max, Ni.max),
                            this.boundingBox.expandByPoint(Fi)) : (this.boundingBox.expandByPoint(Ni.min),
                            this.boundingBox.expandByPoint(Ni.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new vn);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                    void this.boundingSphere.set(new Zt, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (Ni.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            ki.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Fi.addVectors(Ni.min, ki.min),
                            Ni.expandByPoint(Fi),
                            Fi.addVectors(Ni.max, ki.max),
                            Ni.expandByPoint(Fi)) : (Ni.expandByPoint(ki.min),
                            Ni.expandByPoint(ki.max))
                        }
                    Ni.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.count; t < r; t++)
                        Fi.fromBufferAttribute(e, t),
                        i = Math.max(i, n.distanceToSquared(Fi));
                    if (t)
                        for (let r = 0, a = t.length; r < a; r++) {
                            const a = t[r]
                              , s = this.morphTargetsRelative;
                            for (let t = 0, r = a.count; t < r; t++)
                                Fi.fromBufferAttribute(a, t),
                                s && (Ui.fromBufferAttribute(e, t),
                                Fi.add(Ui)),
                                i = Math.max(i, n.distanceToSquared(Fi))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index
                  , t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.position
                  , i = t.normal
                  , r = t.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ci(new Float32Array(4 * n.count),4));
                const a = this.getAttribute("tangent")
                  , s = []
                  , o = [];
                for (let e = 0; e < n.count; e++)
                    s[e] = new Zt,
                    o[e] = new Zt;
                const l = new Zt
                  , c = new Zt
                  , h = new Zt
                  , d = new St
                  , u = new St
                  , f = new St
                  , p = new Zt
                  , m = new Zt;
                function g(e, t, i) {
                    l.fromBufferAttribute(n, e),
                    c.fromBufferAttribute(n, t),
                    h.fromBufferAttribute(n, i),
                    d.fromBufferAttribute(r, e),
                    u.fromBufferAttribute(r, t),
                    f.fromBufferAttribute(r, i),
                    c.sub(l),
                    h.sub(l),
                    u.sub(d),
                    f.sub(d);
                    const a = 1 / (u.x * f.y - f.x * u.y);
                    isFinite(a) && (p.copy(c).multiplyScalar(f.y).addScaledVector(h, -u.y).multiplyScalar(a),
                    m.copy(h).multiplyScalar(u.x).addScaledVector(c, -f.x).multiplyScalar(a),
                    s[e].add(p),
                    s[t].add(p),
                    s[i].add(p),
                    o[e].add(m),
                    o[t].add(m),
                    o[i].add(m))
                }
                let A = this.groups;
                0 === A.length && (A = [{
                    start: 0,
                    count: e.count
                }]);
                for (let t = 0, n = A.length; t < n; ++t) {
                    const n = A[t]
                      , i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                }
                const _ = new Zt
                  , v = new Zt
                  , w = new Zt
                  , y = new Zt;
                function x(e) {
                    w.fromBufferAttribute(i, e),
                    y.copy(w);
                    const t = s[e];
                    _.copy(t),
                    _.sub(w.multiplyScalar(w.dot(t))).normalize(),
                    v.crossVectors(y, t);
                    const n = v.dot(o[e]) < 0 ? -1 : 1;
                    a.setXYZW(e, _.x, _.y, _.z, n)
                }
                for (let t = 0, n = A.length; t < n; ++t) {
                    const n = A[t]
                      , i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        x(e.getX(t + 0)),
                        x(e.getX(t + 1)),
                        x(e.getX(t + 2))
                }
            }
            computeVertexNormals() {
                const e = this.index
                  , t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Ci(new Float32Array(3 * t.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++)
                            n.setXYZ(e, 0, 0, 0);
                    const i = new Zt
                      , r = new Zt
                      , a = new Zt
                      , s = new Zt
                      , o = new Zt
                      , l = new Zt
                      , c = new Zt
                      , h = new Zt;
                    if (e)
                        for (let d = 0, u = e.count; d < u; d += 3) {
                            const u = e.getX(d + 0)
                              , f = e.getX(d + 1)
                              , p = e.getX(d + 2);
                            i.fromBufferAttribute(t, u),
                            r.fromBufferAttribute(t, f),
                            a.fromBufferAttribute(t, p),
                            c.subVectors(a, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            s.fromBufferAttribute(n, u),
                            o.fromBufferAttribute(n, f),
                            l.fromBufferAttribute(n, p),
                            s.add(c),
                            o.add(c),
                            l.add(c),
                            n.setXYZ(u, s.x, s.y, s.z),
                            n.setXYZ(f, o.x, o.y, o.z),
                            n.setXYZ(p, l.x, l.y, l.z)
                        }
                    else
                        for (let e = 0, s = t.count; e < s; e += 3)
                            i.fromBufferAttribute(t, e + 0),
                            r.fromBufferAttribute(t, e + 1),
                            a.fromBufferAttribute(t, e + 2),
                            c.subVectors(a, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            n.setXYZ(e + 0, c.x, c.y, c.z),
                            n.setXYZ(e + 1, c.x, c.y, c.z),
                            n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++)
                    Fi.fromBufferAttribute(e, t),
                    Fi.normalize(),
                    e.setXYZ(t, Fi.x, Fi.y, Fi.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array
                      , i = e.itemSize
                      , r = e.normalized
                      , a = new n.constructor(t.length * i);
                    let s = 0
                      , o = 0;
                    for (let r = 0, l = t.length; r < l; r++) {
                        s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                        for (let e = 0; e < i; e++)
                            a[o++] = n[s++]
                    }
                    return new Ci(a,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const t = new Oi
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const a = e(i[r], n);
                    t.setAttribute(r, a)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const a = []
                      , s = r[i];
                    for (let t = 0, i = s.length; t < i; t++) {
                        const i = e(s[t], n);
                        a.push(i)
                    }
                    t.morphAttributes[i] = a
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const a = this.groups;
                for (let e = 0, n = a.length; e < n; e++) {
                    const n = a[e];
                    t.addGroup(n.start, n.count, n.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid,
                e.type = this.type,
                "" !== this.name && (e.name = this.name),
                Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t)
                        void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    e.data.attributes[t] = i.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t]
                      , a = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        a.push(i.toJSON(e.data))
                    }
                    a.length > 0 && (i[t] = a,
                    r = !0)
                }
                r && (e.data.morphAttributes = i,
                e.data.morphTargetsRelative = this.morphTargetsRelative);
                const a = this.groups;
                a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                const s = this.boundingSphere;
                return null !== s && (e.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }),
                e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const e in i) {
                    const n = i[e];
                    this.setAttribute(e, n.clone(t))
                }
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = []
                      , i = r[e];
                    for (let e = 0, r = i.length; e < r; e++)
                        n.push(i[e].clone(t));
                    this.morphAttributes[e] = n
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const a = e.groups;
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = a[e];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const s = e.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const o = e.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = e.drawRange.start,
                this.drawRange.count = e.drawRange.count,
                this.userData = e.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const zi = new Cn
          , Hi = new Tn
          , Wi = new vn
          , Vi = new Zt
          , Gi = new Zt
          , Qi = new Zt
          , Xi = new Zt
          , ji = new Zt
          , qi = new Zt
          , Yi = new Zt
          , Ki = new Zt;
        class Zi extends ti {
            constructor(e=new Oi, t=new Si) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = e,
                this.material = t,
                this.morphTargetDictionary = void 0,
                this.morphTargetInfluences = void 0,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry
                  , i = n.attributes.position
                  , r = n.morphAttributes.position
                  , a = n.morphTargetsRelative;
                t.fromBufferAttribute(i, e);
                const s = this.morphTargetInfluences;
                if (r && s) {
                    qi.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = s[n]
                          , o = r[n];
                        0 !== i && (ji.fromBufferAttribute(o, e),
                        a ? qi.addScaledVector(ji, i) : qi.addScaledVector(ji.sub(t), i))
                    }
                    t.add(qi)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Wi.copy(n.boundingSphere),
                    Wi.applyMatrix4(r),
                    Hi.copy(e.ray).recast(e.near),
                    !1 === Wi.containsPoint(Hi.origin)) {
                        if (null === Hi.intersectSphere(Wi, Vi))
                            return;
                        if (Hi.origin.distanceToSquared(Vi) > (e.far - e.near) ** 2)
                            return
                    }
                    zi.copy(r).invert(),
                    Hi.copy(e.ray).applyMatrix4(zi),
                    null !== n.boundingBox && !1 === Hi.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Hi)
                }
            }
            _computeIntersections(e, t, n) {
                let i;
                const r = this.geometry
                  , a = this.material
                  , s = r.index
                  , o = r.attributes.position
                  , l = r.attributes.uv
                  , c = r.attributes.uv1
                  , h = r.attributes.normal
                  , d = r.groups
                  , u = r.drawRange;
                if (null !== s)
                    if (Array.isArray(a))
                        for (let r = 0, o = d.length; r < o; r++) {
                            const o = d[r]
                              , f = a[o.materialIndex];
                            for (let r = Math.max(o.start, u.start), a = Math.min(s.count, Math.min(o.start + o.count, u.start + u.count)); r < a; r += 3) {
                                i = Ji(this, f, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = o.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, u.start), o = Math.min(s.count, u.start + u.count); r < o; r += 3) {
                            i = Ji(this, a, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
                else if (void 0 !== o)
                    if (Array.isArray(a))
                        for (let r = 0, s = d.length; r < s; r++) {
                            const s = d[r]
                              , f = a[s.materialIndex];
                            for (let r = Math.max(s.start, u.start), a = Math.min(o.count, Math.min(s.start + s.count, u.start + u.count)); r < a; r += 3) {
                                i = Ji(this, f, e, n, l, c, h, r, r + 1, r + 2),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = s.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); r < s; r += 3) {
                            i = Ji(this, a, e, n, l, c, h, r, r + 1, r + 2),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
            }
        }
        function Ji(e, t, n, i, r, a, s, o, l, c) {
            e.getVertexPosition(o, Gi),
            e.getVertexPosition(l, Qi),
            e.getVertexPosition(c, Xi);
            const h = function(e, t, n, i, r, a, s, o) {
                let l;
                if (l = 1 === t.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 0 === t.side, o),
                null === l)
                    return null;
                Ki.copy(o),
                Ki.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(Ki);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Ki.clone(),
                    object: e
                }
            }(e, t, n, i, Gi, Qi, Xi, Yi);
            if (h) {
                const e = new Zt;
                mi.getBarycoord(Yi, Gi, Qi, Xi, e),
                r && (h.uv = mi.getInterpolatedAttribute(r, o, l, c, e, new St)),
                a && (h.uv1 = mi.getInterpolatedAttribute(a, o, l, c, e, new St)),
                s && (h.normal = mi.getInterpolatedAttribute(s, o, l, c, e, new Zt),
                h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
                const t = {
                    a: o,
                    b: l,
                    c,
                    normal: new Zt,
                    materialIndex: 0
                };
                mi.getNormal(Gi, Qi, Xi, t.normal),
                h.face = t,
                h.barycoord = e
            }
            return h
        }
        class $i extends Oi {
            constructor(e=1, t=1, n=1, i=1, r=1, a=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                const s = this;
                i = Math.floor(i),
                r = Math.floor(r),
                a = Math.floor(a);
                const o = []
                  , l = []
                  , c = []
                  , h = [];
                let d = 0
                  , u = 0;
                function f(e, t, n, i, r, a, f, p, m, g, A) {
                    const _ = a / m
                      , v = f / g
                      , w = a / 2
                      , y = f / 2
                      , x = p / 2
                      , b = m + 1
                      , S = g + 1;
                    let E = 0
                      , M = 0;
                    const T = new Zt;
                    for (let a = 0; a < S; a++) {
                        const s = a * v - y;
                        for (let o = 0; o < b; o++) {
                            const d = o * _ - w;
                            T[e] = d * i,
                            T[t] = s * r,
                            T[n] = x,
                            l.push(T.x, T.y, T.z),
                            T[e] = 0,
                            T[t] = 0,
                            T[n] = p > 0 ? 1 : -1,
                            c.push(T.x, T.y, T.z),
                            h.push(o / m),
                            h.push(1 - a / g),
                            E += 1
                        }
                    }
                    for (let e = 0; e < g; e++)
                        for (let t = 0; t < m; t++) {
                            const n = d + t + b * e
                              , i = d + t + b * (e + 1)
                              , r = d + (t + 1) + b * (e + 1)
                              , a = d + (t + 1) + b * e;
                            o.push(n, i, a),
                            o.push(i, r, a),
                            M += 6
                        }
                    s.addGroup(u, M, A),
                    u += M,
                    d += E
                }
                f("z", "y", "x", -1, -1, n, t, e, a, r, 0),
                f("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
                f("x", "z", "y", 1, 1, e, n, t, i, a, 2),
                f("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
                f("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                f("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                this.setIndex(o),
                this.setAttribute("position", new Pi(l,3)),
                this.setAttribute("normal", new Pi(c,3)),
                this.setAttribute("uv", new Pi(h,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new $i(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
            }
        }
        function er(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const i in e[n]) {
                    const r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            }
            return t
        }
        function tr(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const i = er(e[n]);
                for (const e in i)
                    t[e] = i[e]
            }
            return t
        }
        function nr(e) {
            const t = e.getRenderTarget();
            return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : Ut.workingColorSpace
        }
        const ir = {
            clone: er,
            merge: tr
        };
        class rr extends bi {
            constructor(e) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    clipCullDistance: !1,
                    multiDraw: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = er(e.uniforms),
                this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }(e.uniformsGroups),
                this.defines = Object.assign({}, e.defines),
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.fog = e.fog,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.extensions = Object.assign({}, e.extensions),
                this.glslVersion = e.glslVersion,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion,
                t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                t.vertexShader = this.vertexShader,
                t.fragmentShader = this.fragmentShader,
                t.lights = this.lights,
                t.clipping = this.clipping;
                const n = {};
                for (const e in this.extensions)
                    !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n),
                t
            }
        }
        class ar extends ti {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Cn,
                this.projectionMatrix = new Cn,
                this.projectionMatrixInverse = new Cn,
                this.coordinateSystem = ht
            }
            copy(e, t) {
                return super.copy(e, t),
                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                this.projectionMatrix.copy(e.projectionMatrix),
                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                this.coordinateSystem = e.coordinateSystem,
                this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const sr = new Zt
          , or = new St
          , lr = new St;
        class cr extends ar {
            constructor(e=50, t=1, n=.1, i=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = e,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = t,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.fov = e.fov,
                this.zoom = e.zoom,
                this.near = e.near,
                this.far = e.far,
                this.focus = e.focus,
                this.aspect = e.aspect,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this.filmGauge = e.filmGauge,
                this.filmOffset = e.filmOffset,
                this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * gt * Math.atan(t),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * mt * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * gt * Math.atan(Math.tan(.5 * mt * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(e, t, n) {
                sr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                t.set(sr.x, sr.y).multiplyScalar(-e / sr.z),
                sr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                n.set(sr.x, sr.y).multiplyScalar(-e / sr.z)
            }
            getViewSize(e, t) {
                return this.getViewBounds(e, or, lr),
                t.subVectors(lr, or)
            }
            setViewOffset(e, t, n, i, r, a) {
                this.aspect = e / t,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * mt * this.fov) / this.zoom
                  , n = 2 * t
                  , i = this.aspect * n
                  , r = -.5 * i;
                const a = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = a.fullWidth
                      , s = a.fullHeight;
                    r += a.offsetX * i / e,
                    t -= a.offsetY * n / s,
                    i *= a.width / e,
                    n *= a.height / s
                }
                const s = this.filmOffset;
                0 !== s && (r += e * s / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov,
                t.object.zoom = this.zoom,
                t.object.near = this.near,
                t.object.far = this.far,
                t.object.focus = this.focus,
                t.object.aspect = this.aspect,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t.object.filmGauge = this.filmGauge,
                t.object.filmOffset = this.filmOffset,
                t
            }
        }
        const hr = -90;
        class dr extends ti {
            constructor(e, t, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const i = new cr(hr,1,e,t);
                i.layers = this.layers,
                this.add(i);
                const r = new cr(hr,1,e,t);
                r.layers = this.layers,
                this.add(r);
                const a = new cr(hr,1,e,t);
                a.layers = this.layers,
                this.add(a);
                const s = new cr(hr,1,e,t);
                s.layers = this.layers,
                this.add(s);
                const o = new cr(hr,1,e,t);
                o.layers = this.layers,
                this.add(o);
                const l = new cr(hr,1,e,t);
                l.layers = this.layers,
                this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem
                  , t = this.children.concat()
                  , [n,i,r,a,s,o] = t;
                for (const e of t)
                    this.remove(e);
                if (e === ht)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    i.up.set(0, 1, 0),
                    i.lookAt(-1, 0, 0),
                    r.up.set(0, 0, -1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, 1),
                    a.lookAt(0, -1, 0),
                    s.up.set(0, 1, 0),
                    s.lookAt(0, 0, 1),
                    o.up.set(0, 1, 0),
                    o.lookAt(0, 0, -1);
                else {
                    if (e !== dt)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    i.up.set(0, -1, 0),
                    i.lookAt(1, 0, 0),
                    r.up.set(0, 0, 1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, -1),
                    a.lookAt(0, -1, 0),
                    s.up.set(0, -1, 0),
                    s.lookAt(0, 0, 1),
                    o.up.set(0, -1, 0),
                    o.lookAt(0, 0, -1)
                }
                for (const e of t)
                    this.add(e),
                    e.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: i} = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                this.updateCoordinateSystem());
                const [r,a,s,o,l,c] = this.children
                  , h = e.getRenderTarget()
                  , d = e.getActiveCubeFace()
                  , u = e.getActiveMipmapLevel()
                  , f = e.xr.enabled;
                e.xr.enabled = !1;
                const p = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                e.setRenderTarget(n, 0, i),
                e.render(t, r),
                e.setRenderTarget(n, 1, i),
                e.render(t, a),
                e.setRenderTarget(n, 2, i),
                e.render(t, s),
                e.setRenderTarget(n, 3, i),
                e.render(t, o),
                e.setRenderTarget(n, 4, i),
                e.render(t, l),
                n.texture.generateMipmaps = p,
                e.setRenderTarget(n, 5, i),
                e.render(t, c),
                e.setRenderTarget(h, d, u),
                e.xr.enabled = f,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class ur extends Gt {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : B, n, i, r, a, s, o, l, c),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class fr extends jt {
            constructor(e=1, t={}) {
                super(e, e, t),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: e,
                    height: e,
                    depth: 1
                }
                  , i = [n, n, n, n, n, n];
                this.texture = new ur(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : V
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type,
                this.texture.colorSpace = t.colorSpace,
                this.texture.generateMipmaps = t.generateMipmaps,
                this.texture.minFilter = t.minFilter,
                this.texture.magFilter = t.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new $i(5,5,5)
                  , r = new rr({
                    name: "CubemapFromEquirect",
                    uniforms: er(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
                r.uniforms.tEquirect.value = t;
                const a = new Zi(i,r)
                  , s = t.minFilter;
                t.minFilter === Q && (t.minFilter = V);
                return new dr(1,10,this).update(e, a),
                t.minFilter = s,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    e.setRenderTarget(this, r),
                    e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        class pr extends ti {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const mr = {
            type: "move"
        };
        class gr {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new pr,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new pr,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new Zt,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new Zt),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new pr,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new Zt,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new Zt),
                this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                null !== this._grip && this._grip.dispatchEvent(e),
                null !== this._hand && this._hand.dispatchEvent(e),
                this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values())
                            this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }),
                this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(e, t, n) {
                let i = null
                  , r = null
                  , a = null;
                const s = this._targetRay
                  , o = this._grip
                  , l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        a = !0;
                        for (const i of e.hand.values()) {
                            const e = t.getJointPose(i, n)
                              , r = this._getHandJoint(l, i);
                            null !== e && (r.matrix.fromArray(e.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.matrixWorldNeedsUpdate = !0,
                            r.jointRadius = e.radius),
                            r.visible = null !== e
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , s = i.position.distanceTo(r.position)
                          , o = .02
                          , c = .005;
                        l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else
                        null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                        null !== r && (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        o.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (o.hasLinearVelocity = !0,
                        o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                        r.angularVelocity ? (o.hasAngularVelocity = !0,
                        o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    null !== s && (i = t.getPose(e.targetRaySpace, n),
                    null === i && null !== r && (i = r),
                    null !== i && (s.matrix.fromArray(i.transform.matrix),
                    s.matrix.decompose(s.position, s.rotation, s.scale),
                    s.matrixWorldNeedsUpdate = !0,
                    i.linearVelocity ? (s.hasLinearVelocity = !0,
                    s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1,
                    i.angularVelocity ? (s.hasAngularVelocity = !0,
                    s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1,
                    this.dispatchEvent(mr)))
                }
                return null !== s && (s.visible = null !== i),
                null !== o && (o.visible = null !== r),
                null !== l && (l.visible = null !== a),
                this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new pr;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    e.joints[t.jointName] = n,
                    e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class Ar {
            constructor(e, t=1, n=1e3) {
                this.isFog = !0,
                this.name = "",
                this.color = new wi(e),
                this.near = t,
                this.far = n
            }
            clone() {
                return new Ar(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class _r extends ti {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.backgroundRotation = new Fn,
                this.environmentIntensity = 1,
                this.environmentRotation = new Fn,
                this.overrideMaterial = null,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t),
                null !== e.background && (this.background = e.background.clone()),
                null !== e.environment && (this.environment = e.environment.clone()),
                null !== e.fog && (this.fog = e.fog.clone()),
                this.backgroundBlurriness = e.backgroundBlurriness,
                this.backgroundIntensity = e.backgroundIntensity,
                this.backgroundRotation.copy(e.backgroundRotation),
                this.environmentIntensity = e.environmentIntensity,
                this.environmentRotation.copy(e.environmentRotation),
                null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                t.object.backgroundRotation = this.backgroundRotation.toArray(),
                1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity),
                t.object.environmentRotation = this.environmentRotation.toArray(),
                t
            }
        }
        class vr {
            constructor(e, t) {
                this.isInterleavedBuffer = !0,
                this.array = e,
                this.stride = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.usage = lt,
                this.updateRanges = [],
                this.version = 0,
                this.uuid = At()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array),
                this.count = e.count,
                this.stride = e.stride,
                this.usage = e.usage,
                this
            }
            copyAt(e, t, n) {
                e *= this.stride,
                n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = At()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(t,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = At()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const wr = new Zt;
        class yr {
            constructor(e, t, n, i=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = e,
                this.itemSize = t,
                this.offset = n,
                this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++)
                    wr.fromBufferAttribute(this, t),
                    wr.applyMatrix4(e),
                    this.setXYZ(t, wr.x, wr.y, wr.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    wr.fromBufferAttribute(this, t),
                    wr.applyNormalMatrix(e),
                    this.setXYZ(t, wr.x, wr.y, wr.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    wr.fromBufferAttribute(this, t),
                    wr.transformDirection(e),
                    this.setXYZ(t, wr.x, wr.y, wr.z);
                return this
            }
            getComponent(e, t) {
                let n = this.array[e * this.data.stride + this.offset + t];
                return this.normalized && (n = yt(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = xt(n, this.array)),
                this.data.array[e * this.data.stride + this.offset + t] = n,
                this
            }
            setX(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset] = t,
                this
            }
            setY(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 1] = t,
                this
            }
            setZ(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 2] = t,
                this
            }
            setW(e, t) {
                return this.normalized && (t = xt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 3] = t,
                this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = yt(t, this.array)),
                t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array),
                i = xt(i, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = xt(t, this.array),
                n = xt(n, this.array),
                i = xt(i, this.array),
                r = xt(r, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this.data.array[e + 3] = r,
                this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return new Ci(new this.array.constructor(e),this.itemSize,this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new yr(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const xr = new Zt
          , br = new Qt
          , Sr = new Qt
          , Er = new Zt
          , Mr = new Cn
          , Tr = new Zt
          , Cr = new vn
          , Ir = new Cn
          , Rr = new Tn;
        class Pr extends Zi {
            constructor(e, t) {
                super(e, t),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = P,
                this.bindMatrix = new Cn,
                this.bindMatrixInverse = new Cn,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new en),
                this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Tr),
                    this.boundingBox.expandByPoint(Tr)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new vn),
                this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Tr),
                    this.boundingSphere.expandByPoint(Tr)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.bindMode = e.bindMode,
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                this.skeleton = e.skeleton,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            raycast(e, t) {
                const n = this.material
                  , i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                Cr.copy(this.boundingSphere),
                Cr.applyMatrix4(i),
                !1 !== e.ray.intersectsSphere(Cr) && (Ir.copy(i).invert(),
                Rr.copy(e.ray).applyMatrix4(Ir),
                null !== this.boundingBox && !1 === Rr.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Rr)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t),
                this.applyBoneTransform(e, t),
                t
            }
            bind(e, t) {
                this.skeleton = e,
                void 0 === t && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                t = this.matrixWorld),
                this.bindMatrix.copy(t),
                this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new Qt
                  , t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                    t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.bindMode === P ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton
                  , i = this.geometry;
                br.fromBufferAttribute(i.attributes.skinIndex, e),
                Sr.fromBufferAttribute(i.attributes.skinWeight, e),
                xr.copy(t).applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
                for (let e = 0; e < 4; e++) {
                    const i = Sr.getComponent(e);
                    if (0 !== i) {
                        const r = br.getComponent(e);
                        Mr.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        t.addScaledVector(Er.copy(xr).applyMatrix4(Mr), i)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class Br extends ti {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Dr extends Gt {
            constructor(e=null, t=1, n=1, i, r, a, s, o, l=1003, c=1003, h, d) {
                super(null, a, s, o, l, c, i, r, h, d),
                this.isDataTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Lr = new Cn
          , Ur = new Cn;
        class Nr {
            constructor(e=[], t=[]) {
                this.uuid = At(),
                this.bones = e.slice(0),
                this.boneInverses = t,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.init()
            }
            init() {
                const e = this.bones
                  , t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length),
                0 === t.length)
                    this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++)
                        this.boneInverses.push(new Cn)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new Cn;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                    t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                    t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones
                  , t = this.boneInverses
                  , n = this.boneMatrices
                  , i = this.boneTexture;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i] ? e[i].matrixWorld : Ur;
                    Lr.multiplyMatrices(r, t[i]),
                    Lr.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Nr(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4),
                e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new Dr(t,e,e,re,J);
                return n.needsUpdate = !0,
                this.boneMatrices = t,
                this.boneTexture = n,
                this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const i = e.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                    r = new Br),
                    this.bones.push(r),
                    this.boneInverses.push((new Cn).fromArray(e.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones
                  , n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    e.bones.push(r.uuid);
                    const a = n[i];
                    e.boneInverses.push(a.toArray())
                }
                return e
            }
        }
        class kr extends Ci {
            constructor(e, t, n, i=1) {
                super(e, t, n),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = i
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute,
                e.isInstancedBufferAttribute = !0,
                e
            }
        }
        const Fr = new Cn
          , Or = new Cn
          , zr = []
          , Hr = new en
          , Wr = new Cn
          , Vr = new Zi
          , Gr = new vn;
        class Qr extends Zi {
            constructor(e, t, n) {
                super(e, t),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new kr(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.morphTexture = null,
                this.count = n,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let e = 0; e < n; e++)
                    this.setMatrixAt(e, Wr)
            }
            computeBoundingBox() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingBox && (this.boundingBox = new en),
                null === e.boundingBox && e.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Fr),
                    Hr.copy(e.boundingBox).applyMatrix4(Fr),
                    this.boundingBox.union(Hr)
            }
            computeBoundingSphere() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new vn),
                null === e.boundingSphere && e.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Fr),
                    Gr.copy(e.boundingSphere).applyMatrix4(Fr),
                    this.boundingSphere.union(Gr)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.instanceMatrix.copy(e.instanceMatrix),
                null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()),
                null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                this.count = e.count,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            getMorphAt(e, t) {
                const n = t.morphTargetInfluences
                  , i = this.morphTexture.source.data.data
                  , r = e * (n.length + 1) + 1;
                for (let e = 0; e < n.length; e++)
                    n[e] = i[r + e]
            }
            raycast(e, t) {
                const n = this.matrixWorld
                  , i = this.count;
                if (Vr.geometry = this.geometry,
                Vr.material = this.material,
                void 0 !== Vr.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                Gr.copy(this.boundingSphere),
                Gr.applyMatrix4(n),
                !1 !== e.ray.intersectsSphere(Gr)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Fr),
                        Or.multiplyMatrices(n, Fr),
                        Vr.matrixWorld = Or,
                        Vr.raycast(e, zr);
                        for (let e = 0, n = zr.length; e < n; e++) {
                            const n = zr[e];
                            n.instanceId = r,
                            n.object = this,
                            t.push(n)
                        }
                        zr.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new kr(new Float32Array(3 * this.instanceMatrix.count).fill(1),3)),
                t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            setMorphAt(e, t) {
                const n = t.morphTargetInfluences
                  , i = n.length + 1;
                null === this.morphTexture && (this.morphTexture = new Dr(new Float32Array(i * this.count),i,this.count,oe,J));
                const r = this.morphTexture.source.data.data;
                let a = 0;
                for (let e = 0; e < n.length; e++)
                    a += n[e];
                const s = this.geometry.morphTargetsRelative ? 1 : 1 - a
                  , o = i * e;
                r[o] = s,
                r.set(n, o + 1)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                }),
                null !== this.morphTexture && (this.morphTexture.dispose(),
                this.morphTexture = null)
            }
        }
        const Xr = new Zt
          , jr = new Zt
          , qr = new Et;
        class Yr {
            constructor(e=new Zt(1,0,0), t=0) {
                this.isPlane = !0,
                this.normal = e,
                this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e),
                this.constant = t,
                this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e),
                this.constant = -t.dot(this.normal),
                this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Xr.subVectors(n, t).cross(jr.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e),
                this
            }
            copy(e) {
                return this.normal.copy(e.normal),
                this.constant = e.constant,
                this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e),
                this.constant *= e,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(Xr)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start)
                  , n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || qr.getNormalMatrix(e)
                  , i = this.coplanarPoint(Xr).applyMatrix4(e)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal),
                this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Kr = new vn
          , Zr = new Zt;
        class Jr {
            constructor(e=new Yr, t=new Yr, n=new Yr, i=new Yr, r=new Yr, a=new Yr) {
                this.planes = [e, t, n, i, r, a]
            }
            set(e, t, n, i, r, a) {
                const s = this.planes;
                return s[0].copy(e),
                s[1].copy(t),
                s[2].copy(n),
                s[3].copy(i),
                s[4].copy(r),
                s[5].copy(a),
                this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e, t=2e3) {
                const n = this.planes
                  , i = e.elements
                  , r = i[0]
                  , a = i[1]
                  , s = i[2]
                  , o = i[3]
                  , l = i[4]
                  , c = i[5]
                  , h = i[6]
                  , d = i[7]
                  , u = i[8]
                  , f = i[9]
                  , p = i[10]
                  , m = i[11]
                  , g = i[12]
                  , A = i[13]
                  , _ = i[14]
                  , v = i[15];
                if (n[0].setComponents(o - r, d - l, m - u, v - g).normalize(),
                n[1].setComponents(o + r, d + l, m + u, v + g).normalize(),
                n[2].setComponents(o + a, d + c, m + f, v + A).normalize(),
                n[3].setComponents(o - a, d - c, m - f, v - A).normalize(),
                n[4].setComponents(o - s, d - h, m - p, v - _).normalize(),
                t === ht)
                    n[5].setComponents(o + s, d + h, m + p, v + _).normalize();
                else {
                    if (t !== dt)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(s, h, p, _).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere)
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Kr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Kr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(Kr)
            }
            intersectsSprite(e) {
                return Kr.center.set(0, 0, 0),
                Kr.radius = .7071067811865476,
                Kr.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Kr)
            }
            intersectsSphere(e) {
                const t = this.planes
                  , n = e.center
                  , i = -e.radius;
                for (let e = 0; e < 6; e++) {
                    if (t[e].distanceToPoint(n) < i)
                        return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (Zr.x = i.normal.x > 0 ? e.max.x : e.min.x,
                    Zr.y = i.normal.y > 0 ? e.max.y : e.min.y,
                    Zr.z = i.normal.z > 0 ? e.max.z : e.min.z,
                    i.distanceToPoint(Zr) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class $r extends bi {
            constructor(e) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new wi(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.linewidth = e.linewidth,
                this.linecap = e.linecap,
                this.linejoin = e.linejoin,
                this.fog = e.fog,
                this
            }
        }
        const ea = new Zt
          , ta = new Zt
          , na = new Cn
          , ia = new Tn
          , ra = new vn
          , aa = new Zt
          , sa = new Zt;
        class oa extends ti {
            constructor(e=new Oi, t=new $r) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = e,
                this.material = t,
                this.morphTargetDictionary = void 0,
                this.morphTargetInfluences = void 0,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [0];
                    for (let e = 1, i = t.count; e < i; e++)
                        ea.fromBufferAttribute(t, e - 1),
                        ta.fromBufferAttribute(t, e),
                        n[e] = n[e - 1],
                        n[e] += ea.distanceTo(ta);
                    e.setAttribute("lineDistance", new Pi(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Line.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                ra.copy(n.boundingSphere),
                ra.applyMatrix4(i),
                ra.radius += r,
                !1 === e.ray.intersectsSphere(ra))
                    return;
                na.copy(i).invert(),
                ia.copy(e.ray).applyMatrix4(na);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = s * s
                  , l = this.isLineSegments ? 2 : 1
                  , c = n.index
                  , h = n.attributes.position;
                if (null !== c) {
                    const n = Math.max(0, a.start)
                      , i = Math.min(c.count, a.start + a.count);
                    for (let r = n, a = i - 1; r < a; r += l) {
                        const n = c.getX(r)
                          , i = c.getX(r + 1)
                          , a = la(this, e, ia, o, n, i, r);
                        a && t.push(a)
                    }
                    if (this.isLineLoop) {
                        const r = c.getX(i - 1)
                          , a = c.getX(n)
                          , s = la(this, e, ia, o, r, a, i - 1);
                        s && t.push(s)
                    }
                } else {
                    const n = Math.max(0, a.start)
                      , i = Math.min(h.count, a.start + a.count);
                    for (let r = n, a = i - 1; r < a; r += l) {
                        const n = la(this, e, ia, o, r, r + 1, r);
                        n && t.push(n)
                    }
                    if (this.isLineLoop) {
                        const r = la(this, e, ia, o, i - 1, n, i - 1);
                        r && t.push(r)
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function la(e, t, n, i, r, a, s) {
            const o = e.geometry.attributes.position;
            ea.fromBufferAttribute(o, r),
            ta.fromBufferAttribute(o, a);
            if (n.distanceSqToSegment(ea, ta, aa, sa) > i)
                return;
            aa.applyMatrix4(e.matrixWorld);
            const l = t.ray.origin.distanceTo(aa);
            return l < t.near || l > t.far ? void 0 : {
                distance: l,
                point: sa.clone().applyMatrix4(e.matrixWorld),
                index: s,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: e
            }
        }
        const ca = new Zt
          , ha = new Zt;
        class da extends oa {
            constructor(e, t) {
                super(e, t),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [];
                    for (let e = 0, i = t.count; e < i; e += 2)
                        ca.fromBufferAttribute(t, e),
                        ha.fromBufferAttribute(t, e + 1),
                        n[e] = 0 === e ? 0 : n[e - 1],
                        n[e + 1] = n[e] + ca.distanceTo(ha);
                    e.setAttribute("lineDistance", new Pi(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class ua extends oa {
            constructor(e, t) {
                super(e, t),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class fa extends bi {
            constructor(e) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new wi(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.size = e.size,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        const pa = new Cn
          , ma = new Tn
          , ga = new vn
          , Aa = new Zt;
        class _a extends ti {
            constructor(e=new Oi, t=new fa) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = e,
                this.material = t,
                this.morphTargetDictionary = void 0,
                this.morphTargetInfluences = void 0,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Points.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                ga.copy(n.boundingSphere),
                ga.applyMatrix4(i),
                ga.radius += r,
                !1 === e.ray.intersectsSphere(ga))
                    return;
                pa.copy(i).invert(),
                ma.copy(e.ray).applyMatrix4(pa);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = s * s
                  , l = n.index
                  , c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); n < r; n++) {
                        const r = l.getX(n);
                        Aa.fromBufferAttribute(c, r),
                        va(Aa, r, o, i, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); n < r; n++)
                        Aa.fromBufferAttribute(c, n),
                        va(Aa, n, o, i, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function va(e, t, n, i, r, a, s) {
            const o = ma.distanceSqToPoint(e);
            if (o < n) {
                const n = new Zt;
                ma.closestPointToPoint(e, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                a.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: t,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: s
                })
            }
        }
        class wa extends Gt {
            constructor(e, t, n, i, r, a, s, o, l, c=1026) {
                if (c !== ae && c !== se)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === ae && (n = Z),
                void 0 === n && c === se && (n = ne),
                super(null, i, r, a, s, o, c, n, l),
                this.isDepthTexture = !0,
                this.image = {
                    width: e,
                    height: t
                },
                this.magFilter = void 0 !== s ? s : z,
                this.minFilter = void 0 !== o ? o : z,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(e) {
                return super.copy(e),
                this.source = new Ht(Object.assign({}, e.image)),
                this.compareFunction = e.compareFunction,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                t
            }
        }
        class ya extends Oi {
            constructor(e=1, t=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2
                  , a = t / 2
                  , s = Math.floor(n)
                  , o = Math.floor(i)
                  , l = s + 1
                  , c = o + 1
                  , h = e / s
                  , d = t / o
                  , u = []
                  , f = []
                  , p = []
                  , m = [];
                for (let e = 0; e < c; e++) {
                    const t = e * d - a;
                    for (let n = 0; n < l; n++) {
                        const i = n * h - r;
                        f.push(i, -t, 0),
                        p.push(0, 0, 1),
                        m.push(n / s),
                        m.push(1 - e / o)
                    }
                }
                for (let e = 0; e < o; e++)
                    for (let t = 0; t < s; t++) {
                        const n = t + l * e
                          , i = t + l * (e + 1)
                          , r = t + 1 + l * (e + 1)
                          , a = t + 1 + l * e;
                        u.push(n, i, a),
                        u.push(i, r, a)
                    }
                this.setIndex(u),
                this.setAttribute("position", new Pi(f,3)),
                this.setAttribute("normal", new Pi(p,3)),
                this.setAttribute("uv", new Pi(m,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new ya(e.width,e.height,e.widthSegments,e.heightSegments)
            }
        }
        class xa extends bi {
            constructor(e) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.type = "MeshStandardMaterial",
                this.defines = {
                    STANDARD: ""
                },
                this.color = new wi(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new wi(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new St(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new Fn,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(e.color),
                this.roughness = e.roughness,
                this.metalness = e.metalness,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.roughnessMap = e.roughnessMap,
                this.metalnessMap = e.metalnessMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.envMapIntensity = e.envMapIntensity,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class ba extends xa {
            constructor(e) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new St(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return _t(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new wi(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new wi(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new wi(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._dispersion = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 != e > 0 && this.version++,
                this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++,
                this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++,
                this._iridescence = e
            }
            get dispersion() {
                return this._dispersion
            }
            set dispersion(e) {
                this._dispersion > 0 != e > 0 && this.version++,
                this._dispersion = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++,
                this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++,
                this._transmission = e
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = e.anisotropy,
                this.anisotropyRotation = e.anisotropyRotation,
                this.anisotropyMap = e.anisotropyMap,
                this.clearcoat = e.clearcoat,
                this.clearcoatMap = e.clearcoatMap,
                this.clearcoatRoughness = e.clearcoatRoughness,
                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                this.clearcoatNormalMap = e.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                this.dispersion = e.dispersion,
                this.ior = e.ior,
                this.iridescence = e.iridescence,
                this.iridescenceMap = e.iridescenceMap,
                this.iridescenceIOR = e.iridescenceIOR,
                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                this.sheen = e.sheen,
                this.sheenColor.copy(e.sheenColor),
                this.sheenColorMap = e.sheenColorMap,
                this.sheenRoughness = e.sheenRoughness,
                this.sheenRoughnessMap = e.sheenRoughnessMap,
                this.transmission = e.transmission,
                this.transmissionMap = e.transmissionMap,
                this.thickness = e.thickness,
                this.thicknessMap = e.thicknessMap,
                this.attenuationDistance = e.attenuationDistance,
                this.attenuationColor.copy(e.attenuationColor),
                this.specularIntensity = e.specularIntensity,
                this.specularIntensityMap = e.specularIntensityMap,
                this.specularColor.copy(e.specularColor),
                this.specularColorMap = e.specularColorMap,
                this
            }
        }
        class Sa extends bi {
            constructor(e) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.depthPacking = e.depthPacking,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this
            }
        }
        class Ea extends bi {
            constructor(e) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this
            }
        }
        function Ma(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }
        function Ta(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }
        function Ca(e) {
            const t = e.length
              , n = new Array(t);
            for (let e = 0; e !== t; ++e)
                n[e] = e;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            }
            )),
            n
        }
        function Ia(e, t, n) {
            const i = e.length
              , r = new e.constructor(i);
            for (let a = 0, s = 0; s !== i; ++a) {
                const i = n[a] * t;
                for (let n = 0; n !== t; ++n)
                    r[s++] = e[i + n]
            }
            return r
        }
        function Ra(e, t, n, i) {
            let r = 1
              , a = e[0];
            for (; void 0 !== a && void 0 === a[i]; )
                a = e[r++];
            if (void 0 === a)
                return;
            let s = a[i];
            if (void 0 !== s)
                if (Array.isArray(s))
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        n.push(...s)),
                        a = e[r++]
                    } while (void 0 !== a);
                else if (void 0 !== s.toArray)
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        s.toArray(n, n.length)),
                        a = e[r++]
                    } while (void 0 !== a);
                else
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        n.push(s)),
                        a = e[r++]
                    } while (void 0 !== a)
        }
        class Pa {
            constructor(e, t, n, i) {
                this.parameterPositions = e,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
                this.sampleValues = t,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex
                  , i = t[n]
                  , r = t[n - 1];
                e: {
                    t: {
                        let a;
                        n: {
                            i: if (!(e < i)) {
                                for (let a = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (e < r)
                                            break i;
                                        return n = t.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === a)
                                        break;
                                    if (r = i,
                                    i = t[++n],
                                    e < i)
                                        break t
                                }
                                a = t.length;
                                break n
                            }
                            if (e >= r)
                                break e;
                            {
                                const s = t[1];
                                e < s && (n = 2,
                                r = s);
                                for (let a = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === a)
                                        break;
                                    if (i = r,
                                    r = t[--n - 1],
                                    e >= r)
                                        break t
                                }
                                a = n,
                                n = 0
                            }
                        }
                        for (; n < a; ) {
                            const i = n + a >>> 1;
                            e < t[i] ? a = i : n = i + 1
                        }
                        if (i = t[n],
                        r = t[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = t.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i;
                for (let e = 0; e !== i; ++e)
                    t[e] = n[r + e];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class Ba extends Pa {
            constructor(e, t, n, i) {
                super(e, t, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: Qe,
                    endingEnd: Qe
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2
                  , a = e + 1
                  , s = i[r]
                  , o = i[a];
                if (void 0 === s)
                    switch (this.getSettings_().endingStart) {
                    case Xe:
                        r = e,
                        s = 2 * t - n;
                        break;
                    case je:
                        r = i.length - 2,
                        s = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e,
                        s = n
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case Xe:
                        a = e,
                        o = 2 * n - t;
                        break;
                    case je:
                        a = 1,
                        o = n + i[1] - i[0];
                        break;
                    default:
                        a = e - 1,
                        o = t
                    }
                const l = .5 * (n - t)
                  , c = this.valueSize;
                this._weightPrev = l / (t - s),
                this._weightNext = l / (o - n),
                this._offsetPrev = r * c,
                this._offsetNext = a * c
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = e * s
                  , l = o - s
                  , c = this._offsetPrev
                  , h = this._offsetNext
                  , d = this._weightPrev
                  , u = this._weightNext
                  , f = (n - t) / (i - t)
                  , p = f * f
                  , m = p * f
                  , g = -d * m + 2 * d * p - d * f
                  , A = (1 + d) * m + (-1.5 - 2 * d) * p + (-.5 + d) * f + 1
                  , _ = (-1 - u) * m + (1.5 + u) * p + .5 * f
                  , v = u * m - u * p;
                for (let e = 0; e !== s; ++e)
                    r[e] = g * a[c + e] + A * a[l + e] + _ * a[o + e] + v * a[h + e];
                return r
            }
        }
        class Da extends Pa {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = e * s
                  , l = o - s
                  , c = (n - t) / (i - t)
                  , h = 1 - c;
                for (let e = 0; e !== s; ++e)
                    r[e] = a[l + e] * h + a[o + e] * c;
                return r
            }
        }
        class La extends Pa {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class Ua {
            constructor(e, t, n, i) {
                if (void 0 === e)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e,
                this.times = Ma(t, this.TimeBufferType),
                this.values = Ma(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON)
                    n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: Ma(e.times, Array),
                        values: Ma(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new La(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new Da(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new Ba(this.times,this.values,this.getValueSize(),e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                case We:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Ve:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case Ge:
                    t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation)
                            throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t),
                    this
                }
                return this.createInterpolant = t,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return We;
                case this.InterpolantFactoryMethodLinear:
                    return Ve;
                case this.InterpolantFactoryMethodSmooth:
                    return Ge
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , a = i - 1;
                for (; r !== i && n[r] < e; )
                    ++r;
                for (; -1 !== a && n[a] > t; )
                    --a;
                if (++a,
                0 !== r || a !== i) {
                    r >= a && (a = Math.max(a, 1),
                    r = a - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(r, a),
                    this.values = this.values.slice(r * e, a * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                e = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                e = !1);
                let a = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i),
                        e = !1;
                        break
                    }
                    if (null !== a && a > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, a),
                        e = !1;
                        break
                    }
                    a = i
                }
                if (void 0 !== i && Ta(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                            e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === Ge
                  , r = e.length - 1;
                let a = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const o = e[s];
                    if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                        if (i)
                            r = !0;
                        else {
                            const e = s * n
                              , i = e - n
                              , a = e + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = t[e + s];
                                if (n !== t[i + s] || n !== t[a + s]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (s !== a) {
                            e[a] = e[s];
                            const i = s * n
                              , r = a * n;
                            for (let e = 0; e !== n; ++e)
                                t[r + e] = t[i + e]
                        }
                        ++a
                    }
                }
                if (r > 0) {
                    e[a] = e[r];
                    for (let e = r * n, i = a * n, s = 0; s !== n; ++s)
                        t[i + s] = t[e + s];
                    ++a
                }
                return a !== e.length ? (this.times = e.slice(0, a),
                this.values = t.slice(0, a * n)) : (this.times = e,
                this.values = t),
                this
            }
            clone() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = new (0,
                this.constructor)(this.name,e,t);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        Ua.prototype.TimeBufferType = Float32Array,
        Ua.prototype.ValueBufferType = Float32Array,
        Ua.prototype.DefaultInterpolation = Ve;
        class Na extends Ua {
            constructor(e, t, n) {
                super(e, t, n)
            }
        }
        Na.prototype.ValueTypeName = "bool",
        Na.prototype.ValueBufferType = Array,
        Na.prototype.DefaultInterpolation = We,
        Na.prototype.InterpolantFactoryMethodLinear = void 0,
        Na.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ka extends Ua {
        }
        ka.prototype.ValueTypeName = "color";
        class Fa extends Ua {
        }
        Fa.prototype.ValueTypeName = "number";
        class Oa extends Pa {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = (n - t) / (i - t);
                let l = e * s;
                for (let e = l + s; l !== e; l += 4)
                    Kt.slerpFlat(r, 0, a, l - s, a, l, o);
                return r
            }
        }
        class za extends Ua {
            InterpolantFactoryMethodLinear(e) {
                return new Oa(this.times,this.values,this.getValueSize(),e)
            }
        }
        za.prototype.ValueTypeName = "quaternion",
        za.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Ha extends Ua {
            constructor(e, t, n) {
                super(e, t, n)
            }
        }
        Ha.prototype.ValueTypeName = "string",
        Ha.prototype.ValueBufferType = Array,
        Ha.prototype.DefaultInterpolation = We,
        Ha.prototype.InterpolantFactoryMethodLinear = void 0,
        Ha.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Wa extends Ua {
        }
        Wa.prototype.ValueTypeName = "vector";
        class Va {
            constructor(e="", t=-1, n=[], i=2500) {
                this.name = e,
                this.tracks = n,
                this.duration = t,
                this.blendMode = i,
                this.uuid = At(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = []
                  , n = e.tracks
                  , i = 1 / (e.fps || 1);
                for (let e = 0, r = n.length; e !== r; ++e)
                    t.push(Ga(n[e]).scale(i));
                const r = new this(e.name,e.duration,t,e.blendMode);
                return r.uuid = e.uuid,
                r
            }
            static toJSON(e) {
                const t = []
                  , n = e.tracks
                  , i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
                for (let e = 0, i = n.length; e !== i; ++e)
                    t.push(Ua.toJSON(n[e]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length
                  , a = [];
                for (let e = 0; e < r; e++) {
                    let s = []
                      , o = [];
                    s.push((e + r - 1) % r, e, (e + 1) % r),
                    o.push(0, 1, 0);
                    const l = Ca(s);
                    s = Ia(s, 1, l),
                    o = Ia(o, 1, l),
                    i || 0 !== s[0] || (s.push(r),
                    o.push(o[0])),
                    a.push(new Fa(".morphTargetInfluences[" + t[e].name + "]",s,o).scale(1 / n))
                }
                return new this(e,-1,a)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let e = 0; e < n.length; e++)
                    if (n[e].name === t)
                        return n[e];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t]
                      , a = n.name.match(r);
                    if (a && a.length > 1) {
                        const e = a[1];
                        let t = i[e];
                        t || (i[e] = t = []),
                        t.push(n)
                    }
                }
                const a = [];
                for (const e in i)
                    a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                return a
            }
            static parseAnimation(e, t) {
                if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(e, t, n, i, r) {
                    if (0 !== n.length) {
                        const a = []
                          , s = [];
                        Ra(n, a, s, i),
                        0 !== a.length && r.push(new e(t,a,s))
                    }
                }
                  , i = []
                  , r = e.name || "default"
                  , a = e.fps || 30
                  , s = e.blendMode;
                let o = e.length || -1;
                const l = e.hierarchy || [];
                for (let e = 0; e < l.length; e++) {
                    const r = l[e].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const e = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++)
                                        e[r[t].morphTargets[n]] = -1;
                            for (const n in e) {
                                const e = []
                                  , a = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    e.push(i.time),
                                    a.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new Fa(".morphTargetInfluence[" + n + "]",e,a))
                            }
                            o = e.length * a
                        } else {
                            const a = ".bones[" + t[e].name + "]";
                            n(Wa, a + ".position", r, "pos", i),
                            n(za, a + ".quaternion", r, "rot", i),
                            n(Wa, a + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length)
                    return null;
                return new this(r,o,i,s)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e,
                this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                return new this.constructor(this.name,this.duration,e,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Ga(e) {
            if (void 0 === e.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Fa;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Wa;
                case "color":
                    return ka;
                case "quaternion":
                    return za;
                case "bool":
                case "boolean":
                    return Na;
                case "string":
                    return Ha
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = []
                  , n = [];
                Ra(e.keys, t, n, "value"),
                e.times = t,
                e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
        }
        const Qa = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled)
                    return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class Xa {
            constructor(e, t, n) {
                const i = this;
                let r, a = !1, s = 0, o = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = e,
                this.onProgress = t,
                this.onError = n,
                this.itemStart = function(e) {
                    o++,
                    !1 === a && void 0 !== i.onStart && i.onStart(e, s, o),
                    a = !0
                }
                ,
                this.itemEnd = function(e) {
                    s++,
                    void 0 !== i.onProgress && i.onProgress(e, s, o),
                    s === o && (a = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }
                ,
                this.resolveURL = function(e) {
                    return r ? r(e) : e
                }
                ,
                this.setURLModifier = function(e) {
                    return r = e,
                    this
                }
                ,
                this.addHandler = function(e, t) {
                    return l.push(e, t),
                    this
                }
                ,
                this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2),
                    this
                }
                ,
                this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t]
                          , i = l[t + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(e))
                            return i
                    }
                    return null
                }
            }
        }
        const ja = new Xa;
        class qa {
            constructor(e) {
                this.manager = void 0 !== e ? e : ja,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(e, i, t, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e,
                this
            }
            setWithCredentials(e) {
                return this.withCredentials = e,
                this
            }
            setPath(e) {
                return this.path = e,
                this
            }
            setResourcePath(e) {
                return this.resourcePath = e,
                this
            }
            setRequestHeader(e) {
                return this.requestHeader = e,
                this
            }
        }
        qa.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Ya = {};
        class Ka extends Error {
            constructor(e, t) {
                super(e),
                this.response = t
            }
        }
        class Za extends qa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = Qa.get(e);
                if (void 0 !== r)
                    return this.manager.itemStart(e),
                    setTimeout(( () => {
                        t && t(r),
                        this.manager.itemEnd(e)
                    }
                    ), 0),
                    r;
                if (void 0 !== Ya[e])
                    return void Ya[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                Ya[e] = [],
                Ya[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const a = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , s = this.mimeType
                  , o = this.responseType;
                fetch(a).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        const n = Ya[e]
                          , i = t.body.getReader()
                          , r = t.headers.get("X-File-Size") || t.headers.get("Content-Length")
                          , a = r ? parseInt(r) : 0
                          , s = 0 !== a;
                        let o = 0;
                        const l = new ReadableStream({
                            start(e) {
                                !function t() {
                                    i.read().then(( ({done: i, value: r}) => {
                                        if (i)
                                            e.close();
                                        else {
                                            o += r.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: s,
                                                loaded: o,
                                                total: a
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(i)
                                            }
                                            e.enqueue(r),
                                            t()
                                        }
                                    }
                                    ), (t => {
                                        e.error(t)
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Ka(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                }
                )).then((e => {
                    switch (o) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e => (new DOMParser).parseFromString(e, s)));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === s)
                            return e.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(s)
                              , n = t && t[1] ? t[1].toLowerCase() : void 0
                              , i = new TextDecoder(n);
                            return e.arrayBuffer().then((e => i.decode(e)))
                        }
                    }
                }
                )).then((t => {
                    Qa.add(e, t);
                    const n = Ya[e];
                    delete Ya[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onLoad && i.onLoad(t)
                    }
                }
                )).catch((t => {
                    const n = Ya[e];
                    if (void 0 === n)
                        throw this.manager.itemError(e),
                        t;
                    delete Ya[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    this.manager.itemError(e)
                }
                )).finally(( () => {
                    this.manager.itemEnd(e)
                }
                )),
                this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e,
                this
            }
            setMimeType(e) {
                return this.mimeType = e,
                this
            }
        }
        class Ja extends qa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , a = Qa.get(e);
                if (void 0 !== a)
                    return r.manager.itemStart(e),
                    setTimeout((function() {
                        t && t(a),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    a;
                const s = Ct("img");
                function o() {
                    c(),
                    Qa.add(e, this),
                    t && t(this),
                    r.manager.itemEnd(e)
                }
                function l(t) {
                    c(),
                    i && i(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                function c() {
                    s.removeEventListener("load", o, !1),
                    s.removeEventListener("error", l, !1)
                }
                return s.addEventListener("load", o, !1),
                s.addEventListener("error", l, !1),
                "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                r.manager.itemStart(e),
                s.src = e,
                s
            }
        }
        class $a extends qa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new Gt
                  , a = new Ja(this.manager);
                return a.setCrossOrigin(this.crossOrigin),
                a.setPath(this.path),
                a.load(e, (function(e) {
                    r.image = e,
                    r.needsUpdate = !0,
                    void 0 !== t && t(r)
                }
                ), n, i),
                r
            }
        }
        class es extends ti {
            constructor(e, t=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new wi(e),
                this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t),
                this.color.copy(e.color),
                this.intensity = e.intensity,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(),
                t.object.intensity = this.intensity,
                void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (t.object.distance = this.distance),
                void 0 !== this.angle && (t.object.angle = this.angle),
                void 0 !== this.decay && (t.object.decay = this.decay),
                void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                void 0 !== this.target && (t.object.target = this.target.uuid),
                t
            }
        }
        class ts extends es {
            constructor(e, t, n) {
                super(e, n),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(ti.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new wi(t)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.groundColor.copy(e.groundColor),
                this
            }
        }
        const ns = new Cn
          , is = new Zt
          , rs = new Zt;
        class as {
            constructor(e) {
                this.camera = e,
                this.intensity = 1,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new St(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Cn,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Jr,
                this._frameExtents = new St(1,1),
                this._viewportCount = 1,
                this._viewports = [new Qt(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = this.matrix;
                is.setFromMatrixPosition(e.matrixWorld),
                t.position.copy(is),
                rs.setFromMatrixPosition(e.target.matrixWorld),
                t.lookAt(rs),
                t.updateMatrixWorld(),
                ns.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(ns),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(ns)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(),
                this.intensity = e.intensity,
                this.bias = e.bias,
                this.radius = e.radius,
                this.mapSize.copy(e.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 1 !== this.intensity && (e.intensity = this.intensity),
                0 !== this.bias && (e.bias = this.bias),
                0 !== this.normalBias && (e.normalBias = this.normalBias),
                1 !== this.radius && (e.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                e.camera = this.camera.toJSON(!1).object,
                delete e.camera.matrix,
                e
            }
        }
        class ss extends as {
            constructor() {
                super(new cr(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = 2 * gt * e.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
                t.aspect = i,
                t.far = r,
                t.updateProjectionMatrix()),
                super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e),
                this.focus = e.focus,
                this
            }
        }
        class os extends es {
            constructor(e, t, n=0, i=Math.PI / 3, r=0, a=2) {
                super(e, t),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(ti.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new ti,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = a,
                this.map = null,
                this.shadow = new ss
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.angle = e.angle,
                this.penumbra = e.penumbra,
                this.decay = e.decay,
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        const ls = new Cn
          , cs = new Zt
          , hs = new Zt;
        class ds extends as {
            constructor() {
                super(new cr(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new St(4,2),
                this._viewportCount = 6,
                this._viewports = [new Qt(2,1,1,1), new Qt(0,1,1,1), new Qt(3,1,1,1), new Qt(1,1,1,1), new Qt(3,0,1,1), new Qt(1,0,1,1)],
                this._cubeDirections = [new Zt(1,0,0), new Zt(-1,0,0), new Zt(0,0,1), new Zt(0,0,-1), new Zt(0,1,0), new Zt(0,-1,0)],
                this._cubeUps = [new Zt(0,1,0), new Zt(0,1,0), new Zt(0,1,0), new Zt(0,1,0), new Zt(0,0,1), new Zt(0,0,-1)]
            }
            updateMatrices(e, t=0) {
                const n = this.camera
                  , i = this.matrix
                  , r = e.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                cs.setFromMatrixPosition(e.matrixWorld),
                n.position.copy(cs),
                hs.copy(n.position),
                hs.add(this._cubeDirections[t]),
                n.up.copy(this._cubeUps[t]),
                n.lookAt(hs),
                n.updateMatrixWorld(),
                i.makeTranslation(-cs.x, -cs.y, -cs.z),
                ls.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(ls)
            }
        }
        class us extends es {
            constructor(e, t, n=0, i=2) {
                super(e, t),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new ds
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.decay = e.decay,
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class fs extends ar {
            constructor(e=-1, t=1, n=1, i=-1, r=.1, a=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = e,
                this.right = t,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = a,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.left = e.left,
                this.right = e.right,
                this.top = e.top,
                this.bottom = e.bottom,
                this.near = e.near,
                this.far = e.far,
                this.zoom = e.zoom,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this
            }
            setViewOffset(e, t, n, i, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom)
                  , t = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - e
                  , a = n + e
                  , s = i + t
                  , o = i - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += e * this.view.offsetX,
                    a = r + e * this.view.width,
                    s -= t * this.view.offsetY,
                    o = s - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom,
                t.object.left = this.left,
                t.object.right = this.right,
                t.object.top = this.top,
                t.object.bottom = this.bottom,
                t.object.near = this.near,
                t.object.far = this.far,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t
            }
        }
        class ps extends as {
            constructor() {
                super(new fs(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class ms extends es {
            constructor(e, t) {
                super(e, t),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(ti.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new ti,
                this.shadow = new ps
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e),
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class gs {
            static decodeText(e) {
                if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
                "undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++)
                    t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class As extends qa {
            constructor(e) {
                super(e),
                this.isImageBitmapLoader = !0,
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e,
                this
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , a = Qa.get(e);
                if (void 0 !== a)
                    return r.manager.itemStart(e),
                    a.then ? void a.then((n => {
                        t && t(n),
                        r.manager.itemEnd(e)
                    }
                    )).catch((e => {
                        i && i(e)
                    }
                    )) : (setTimeout((function() {
                        t && t(a),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    a);
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                s.headers = this.requestHeader;
                const o = fetch(e, s).then((function(e) {
                    return e.blob()
                }
                )).then((function(e) {
                    return createImageBitmap(e, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    return Qa.add(e, n),
                    t && t(n),
                    r.manager.itemEnd(e),
                    n
                }
                )).catch((function(t) {
                    i && i(t),
                    Qa.remove(e),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                ));
                Qa.add(e, o),
                r.manager.itemStart(e)
            }
        }
        class _s extends cr {
            constructor(e=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = e,
                this.index = 0
            }
        }
        const vs = "\\[\\]\\.:\\/"
          , ws = new RegExp("[" + vs + "]","g")
          , ys = "[^" + vs + "]"
          , xs = "[^" + vs.replace("\\.", "") + "]"
          , bs = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", ys) + /(WCOD+)?/.source.replace("WCOD", xs) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ys) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ys) + "$")
          , Ss = ["material", "materials", "bones", "map"];
        class Es {
            constructor(e, t, n) {
                this.path = t,
                this.parsedPath = n || Es.parseTrackName(t),
                this.node = Es.findNode(e, this.parsedPath.nodeName),
                this.rootNode = e,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new Es.Composite(e,t,n) : new Es(e,t,n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(ws, "")
            }
            static parseTrackName(e) {
                const t = bs.exec(e);
                if (null === t)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const e = n.nodeName.substring(i + 1);
                    -1 !== Ss.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                    return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n)
                        return n
                }
                if (e.children) {
                    const n = function(e) {
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            if (r.name === t || r.uuid === t)
                                return r;
                            const a = n(r.children);
                            if (a)
                                return a
                        }
                        return null
                    }
                      , i = n(e.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(),
                this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(),
                this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath
                  , n = t.objectName
                  , i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = Es.findNode(this.rootNode, t.nodeName),
                this.node = e),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !e)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === i) {
                                i = t;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        e = e.material.map;
                        break;
                    default:
                        if (void 0 === e[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === e[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[i]
                    }
                }
                const a = e[i];
                if (void 0 === a) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                }
                let s = this.Versioning.None;
                this.targetObject = e,
                !0 === e.isMaterial ? s = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!e.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = a,
                    this.propertyIndex = r
                } else
                    void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = a) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        Es.Composite = class {
            constructor(e, t, n) {
                const i = n || Es.parseTrackName(t);
                this._targetGroup = e,
                this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].unbind()
            }
        }
        ,
        Es.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Es.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        Es.prototype.GetterByBindingType = [Es.prototype._getValue_direct, Es.prototype._getValue_array, Es.prototype._getValue_arrayElement, Es.prototype._getValue_toArray],
        Es.prototype.SetterByBindingTypeAndVersioning = [[Es.prototype._setValue_direct, Es.prototype._setValue_direct_setNeedsUpdate, Es.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Es.prototype._setValue_array, Es.prototype._setValue_array_setNeedsUpdate, Es.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Es.prototype._setValue_arrayElement, Es.prototype._setValue_arrayElement_setNeedsUpdate, Es.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Es.prototype._setValue_fromArray, Es.prototype._setValue_fromArray_setNeedsUpdate, Es.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        new Float32Array(1);
        function Ms(e, t, n, i) {
            const r = function(e) {
                switch (e) {
                case X:
                case j:
                    return {
                        byteLength: 1,
                        components: 1
                    };
                case Y:
                case q:
                case $:
                    return {
                        byteLength: 2,
                        components: 1
                    };
                case ee:
                case te:
                    return {
                        byteLength: 2,
                        components: 4
                    };
                case Z:
                case K:
                case J:
                    return {
                        byteLength: 4,
                        components: 1
                    };
                case ie:
                    return {
                        byteLength: 4,
                        components: 3
                    }
                }
                throw new Error(`Unknown texture type ${e}.`)
            }(i);
            switch (n) {
            case 1021:
            case 1024:
                return e * t;
            case 1025:
                return e * t * 2;
            case oe:
            case le:
                return e * t / r.components * r.byteLength;
            case 1030:
            case ce:
                return e * t * 2 / r.components * r.byteLength;
            case 1022:
                return e * t * 3 / r.components * r.byteLength;
            case re:
            case he:
                return e * t * 4 / r.components * r.byteLength;
            case de:
            case ue:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case fe:
            case pe:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case ge:
            case _e:
                return Math.max(e, 16) * Math.max(t, 8) / 4;
            case me:
            case Ae:
                return Math.max(e, 8) * Math.max(t, 8) / 2;
            case ve:
            case we:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case ye:
            case xe:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case be:
                return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
            case Se:
                return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
            case Ee:
                return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
            case Me:
                return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
            case Te:
                return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
            case Ce:
                return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
            case Ie:
                return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
            case Re:
                return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
            case Pe:
                return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
            case Be:
                return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
            case De:
                return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
            case Le:
                return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
            case Ue:
                return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
            case Ne:
            case ke:
            case Fe:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
            case 36283:
            case Oe:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
            case ze:
            case He:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
            }
            throw new Error(`Unable to determine texture byte length for ${n} format.`)
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: e
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = e);
        const Ts = {
            c: null,
            u: [new Zt, new Zt, new Zt],
            e: []
        }
          , Cs = {
            c: null,
            u: [new Zt, new Zt, new Zt],
            e: []
        }
          , Is = [[], [], []]
          , Rs = [[], [], []]
          , Ps = []
          , Bs = new Zt
          , Ds = new Zt
          , Ls = new Zt
          , Us = new Zt
          , Ns = new Zt
          , ks = new Zt
          , Fs = new Et
          , Os = new en
          , zs = new Cn
          , Hs = new Cn
          , Ws = new Tn;
        class Vs {
            constructor(e=new Zt, t=new Zt, n=new Et) {
                this.center = e,
                this.halfSize = t,
                this.rotation = n
            }
            set(e, t, n) {
                return this.center = e,
                this.halfSize = t,
                this.rotation = n,
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.halfSize.copy(e.halfSize),
                this.rotation.copy(e.rotation),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            getSize(e) {
                return e.copy(this.halfSize).multiplyScalar(2)
            }
            clampPoint(e, t) {
                const n = this.halfSize;
                Us.subVectors(e, this.center),
                this.rotation.extractBasis(Bs, Ds, Ls),
                t.copy(this.center);
                const i = bt.clamp(Us.dot(Bs), -n.x, n.x);
                t.add(Bs.multiplyScalar(i));
                const r = bt.clamp(Us.dot(Ds), -n.y, n.y);
                t.add(Ds.multiplyScalar(r));
                const a = bt.clamp(Us.dot(Ls), -n.z, n.z);
                return t.add(Ls.multiplyScalar(a)),
                t
            }
            containsPoint(e) {
                return Us.subVectors(e, this.center),
                this.rotation.extractBasis(Bs, Ds, Ls),
                Math.abs(Us.dot(Bs)) <= this.halfSize.x && Math.abs(Us.dot(Ds)) <= this.halfSize.y && Math.abs(Us.dot(Ls)) <= this.halfSize.z
            }
            intersectsBox3(e) {
                return this.intersectsOBB(Gs.fromBox3(e))
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, ks),
                ks.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsOBB(e, t=Number.EPSILON) {
                Ts.c = this.center,
                Ts.e[0] = this.halfSize.x,
                Ts.e[1] = this.halfSize.y,
                Ts.e[2] = this.halfSize.z,
                this.rotation.extractBasis(Ts.u[0], Ts.u[1], Ts.u[2]),
                Cs.c = e.center,
                Cs.e[0] = e.halfSize.x,
                Cs.e[1] = e.halfSize.y,
                Cs.e[2] = e.halfSize.z,
                e.rotation.extractBasis(Cs.u[0], Cs.u[1], Cs.u[2]);
                for (let e = 0; e < 3; e++)
                    for (let t = 0; t < 3; t++)
                        Is[e][t] = Ts.u[e].dot(Cs.u[t]);
                Us.subVectors(Cs.c, Ts.c),
                Ps[0] = Us.dot(Ts.u[0]),
                Ps[1] = Us.dot(Ts.u[1]),
                Ps[2] = Us.dot(Ts.u[2]);
                for (let e = 0; e < 3; e++)
                    for (let n = 0; n < 3; n++)
                        Rs[e][n] = Math.abs(Is[e][n]) + t;
                let n, i;
                for (let e = 0; e < 3; e++)
                    if (n = Ts.e[e],
                    i = Cs.e[0] * Rs[e][0] + Cs.e[1] * Rs[e][1] + Cs.e[2] * Rs[e][2],
                    Math.abs(Ps[e]) > n + i)
                        return !1;
                for (let e = 0; e < 3; e++)
                    if (n = Ts.e[0] * Rs[0][e] + Ts.e[1] * Rs[1][e] + Ts.e[2] * Rs[2][e],
                    i = Cs.e[e],
                    Math.abs(Ps[0] * Is[0][e] + Ps[1] * Is[1][e] + Ps[2] * Is[2][e]) > n + i)
                        return !1;
                return n = Ts.e[1] * Rs[2][0] + Ts.e[2] * Rs[1][0],
                i = Cs.e[1] * Rs[0][2] + Cs.e[2] * Rs[0][1],
                !(Math.abs(Ps[2] * Is[1][0] - Ps[1] * Is[2][0]) > n + i) && (n = Ts.e[1] * Rs[2][1] + Ts.e[2] * Rs[1][1],
                i = Cs.e[0] * Rs[0][2] + Cs.e[2] * Rs[0][0],
                !(Math.abs(Ps[2] * Is[1][1] - Ps[1] * Is[2][1]) > n + i) && (n = Ts.e[1] * Rs[2][2] + Ts.e[2] * Rs[1][2],
                i = Cs.e[0] * Rs[0][1] + Cs.e[1] * Rs[0][0],
                !(Math.abs(Ps[2] * Is[1][2] - Ps[1] * Is[2][2]) > n + i) && (n = Ts.e[0] * Rs[2][0] + Ts.e[2] * Rs[0][0],
                i = Cs.e[1] * Rs[1][2] + Cs.e[2] * Rs[1][1],
                !(Math.abs(Ps[0] * Is[2][0] - Ps[2] * Is[0][0]) > n + i) && (n = Ts.e[0] * Rs[2][1] + Ts.e[2] * Rs[0][1],
                i = Cs.e[0] * Rs[1][2] + Cs.e[2] * Rs[1][0],
                !(Math.abs(Ps[0] * Is[2][1] - Ps[2] * Is[0][1]) > n + i) && (n = Ts.e[0] * Rs[2][2] + Ts.e[2] * Rs[0][2],
                i = Cs.e[0] * Rs[1][1] + Cs.e[1] * Rs[1][0],
                !(Math.abs(Ps[0] * Is[2][2] - Ps[2] * Is[0][2]) > n + i) && (n = Ts.e[0] * Rs[1][0] + Ts.e[1] * Rs[0][0],
                i = Cs.e[1] * Rs[2][2] + Cs.e[2] * Rs[2][1],
                !(Math.abs(Ps[1] * Is[0][0] - Ps[0] * Is[1][0]) > n + i) && (n = Ts.e[0] * Rs[1][1] + Ts.e[1] * Rs[0][1],
                i = Cs.e[0] * Rs[2][2] + Cs.e[2] * Rs[2][0],
                !(Math.abs(Ps[1] * Is[0][1] - Ps[0] * Is[1][1]) > n + i) && (n = Ts.e[0] * Rs[1][2] + Ts.e[1] * Rs[0][2],
                i = Cs.e[0] * Rs[2][1] + Cs.e[1] * Rs[2][0],
                !(Math.abs(Ps[1] * Is[0][2] - Ps[0] * Is[1][2]) > n + i)))))))))
            }
            intersectsPlane(e) {
                this.rotation.extractBasis(Bs, Ds, Ls);
                const t = this.halfSize.x * Math.abs(e.normal.dot(Bs)) + this.halfSize.y * Math.abs(e.normal.dot(Ds)) + this.halfSize.z * Math.abs(e.normal.dot(Ls))
                  , n = e.normal.dot(this.center) - e.constant;
                return Math.abs(n) <= t
            }
            intersectRay(e, t) {
                return this.getSize(Ns),
                Os.setFromCenterAndSize(Us.set(0, 0, 0), Ns),
                zs.setFromMatrix3(this.rotation),
                zs.setPosition(this.center),
                Hs.copy(zs).invert(),
                Ws.copy(e).applyMatrix4(Hs),
                Ws.intersectBox(Os, t) ? t.applyMatrix4(zs) : null
            }
            intersectsRay(e) {
                return null !== this.intersectRay(e, Us)
            }
            fromBox3(e) {
                return e.getCenter(this.center),
                e.getSize(this.halfSize).multiplyScalar(.5),
                this.rotation.identity(),
                this
            }
            equals(e) {
                return e.center.equals(this.center) && e.halfSize.equals(this.halfSize) && e.rotation.equals(this.rotation)
            }
            applyMatrix4(e) {
                const t = e.elements;
                let n = Us.set(t[0], t[1], t[2]).length();
                const i = Us.set(t[4], t[5], t[6]).length()
                  , r = Us.set(t[8], t[9], t[10]).length();
                e.determinant() < 0 && (n = -n),
                Fs.setFromMatrix4(e);
                const a = 1 / n
                  , s = 1 / i
                  , o = 1 / r;
                return Fs.elements[0] *= a,
                Fs.elements[1] *= a,
                Fs.elements[2] *= a,
                Fs.elements[3] *= s,
                Fs.elements[4] *= s,
                Fs.elements[5] *= s,
                Fs.elements[6] *= o,
                Fs.elements[7] *= o,
                Fs.elements[8] *= o,
                this.rotation.multiply(Fs),
                this.halfSize.x *= n,
                this.halfSize.y *= i,
                this.halfSize.z *= r,
                Us.setFromMatrixPosition(e),
                this.center.add(Us),
                this
            }
        }
        const Gs = new Vs;
        function Qs(e) {
            let t = e.length;
            for (; --t >= 0; )
                e[t] = 0
        }
        const Xs = 256
          , js = 286
          , qs = 30
          , Ys = 15
          , Ks = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
          , Zs = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
          , Js = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
          , $s = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , eo = new Array(576);
        Qs(eo);
        const to = new Array(60);
        Qs(to);
        const no = new Array(512);
        Qs(no);
        const io = new Array(256);
        Qs(io);
        const ro = new Array(29);
        Qs(ro);
        const ao = new Array(qs);
        function so(e, t, n, i, r) {
            this.static_tree = e,
            this.extra_bits = t,
            this.extra_base = n,
            this.elems = i,
            this.max_length = r,
            this.has_stree = e && e.length
        }
        let oo, lo, co;
        function ho(e, t) {
            this.dyn_tree = e,
            this.max_code = 0,
            this.stat_desc = t
        }
        Qs(ao);
        const uo = e => e < 256 ? no[e] : no[256 + (e >>> 7)]
          , fo = (e, t) => {
            e.pending_buf[e.pending++] = 255 & t,
            e.pending_buf[e.pending++] = t >>> 8 & 255
        }
          , po = (e, t, n) => {
            e.bi_valid > 16 - n ? (e.bi_buf |= t << e.bi_valid & 65535,
            fo(e, e.bi_buf),
            e.bi_buf = t >> 16 - e.bi_valid,
            e.bi_valid += n - 16) : (e.bi_buf |= t << e.bi_valid & 65535,
            e.bi_valid += n)
        }
          , mo = (e, t, n) => {
            po(e, n[2 * t], n[2 * t + 1])
        }
          , go = (e, t) => {
            let n = 0;
            do {
                n |= 1 & e,
                e >>>= 1,
                n <<= 1
            } while (--t > 0);
            return n >>> 1
        }
          , Ao = (e, t, n) => {
            const i = new Array(16);
            let r, a, s = 0;
            for (r = 1; r <= Ys; r++)
                s = s + n[r - 1] << 1,
                i[r] = s;
            for (a = 0; a <= t; a++) {
                let t = e[2 * a + 1];
                0 !== t && (e[2 * a] = go(i[t]++, t))
            }
        }
          , _o = e => {
            let t;
            for (t = 0; t < js; t++)
                e.dyn_ltree[2 * t] = 0;
            for (t = 0; t < qs; t++)
                e.dyn_dtree[2 * t] = 0;
            for (t = 0; t < 19; t++)
                e.bl_tree[2 * t] = 0;
            e.dyn_ltree[512] = 1,
            e.opt_len = e.static_len = 0,
            e.sym_next = e.matches = 0
        }
          , vo = e => {
            e.bi_valid > 8 ? fo(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
            e.bi_buf = 0,
            e.bi_valid = 0
        }
          , wo = (e, t, n, i) => {
            const r = 2 * t
              , a = 2 * n;
            return e[r] < e[a] || e[r] === e[a] && i[t] <= i[n]
        }
          , yo = (e, t, n) => {
            const i = e.heap[n];
            let r = n << 1;
            for (; r <= e.heap_len && (r < e.heap_len && wo(t, e.heap[r + 1], e.heap[r], e.depth) && r++,
            !wo(t, i, e.heap[r], e.depth)); )
                e.heap[n] = e.heap[r],
                n = r,
                r <<= 1;
            e.heap[n] = i
        }
          , xo = (e, t, n) => {
            let i, r, a, s, o = 0;
            if (0 !== e.sym_next)
                do {
                    i = 255 & e.pending_buf[e.sym_buf + o++],
                    i += (255 & e.pending_buf[e.sym_buf + o++]) << 8,
                    r = e.pending_buf[e.sym_buf + o++],
                    0 === i ? mo(e, r, t) : (a = io[r],
                    mo(e, a + Xs + 1, t),
                    s = Ks[a],
                    0 !== s && (r -= ro[a],
                    po(e, r, s)),
                    i--,
                    a = uo(i),
                    mo(e, a, n),
                    s = Zs[a],
                    0 !== s && (i -= ao[a],
                    po(e, i, s)))
                } while (o < e.sym_next);
            mo(e, 256, t)
        }
          , bo = (e, t) => {
            const n = t.dyn_tree
              , i = t.stat_desc.static_tree
              , r = t.stat_desc.has_stree
              , a = t.stat_desc.elems;
            let s, o, l, c = -1;
            for (e.heap_len = 0,
            e.heap_max = 573,
            s = 0; s < a; s++)
                0 !== n[2 * s] ? (e.heap[++e.heap_len] = c = s,
                e.depth[s] = 0) : n[2 * s + 1] = 0;
            for (; e.heap_len < 2; )
                l = e.heap[++e.heap_len] = c < 2 ? ++c : 0,
                n[2 * l] = 1,
                e.depth[l] = 0,
                e.opt_len--,
                r && (e.static_len -= i[2 * l + 1]);
            for (t.max_code = c,
            s = e.heap_len >> 1; s >= 1; s--)
                yo(e, n, s);
            l = a;
            do {
                s = e.heap[1],
                e.heap[1] = e.heap[e.heap_len--],
                yo(e, n, 1),
                o = e.heap[1],
                e.heap[--e.heap_max] = s,
                e.heap[--e.heap_max] = o,
                n[2 * l] = n[2 * s] + n[2 * o],
                e.depth[l] = (e.depth[s] >= e.depth[o] ? e.depth[s] : e.depth[o]) + 1,
                n[2 * s + 1] = n[2 * o + 1] = l,
                e.heap[1] = l++,
                yo(e, n, 1)
            } while (e.heap_len >= 2);
            e.heap[--e.heap_max] = e.heap[1],
            ( (e, t) => {
                const n = t.dyn_tree
                  , i = t.max_code
                  , r = t.stat_desc.static_tree
                  , a = t.stat_desc.has_stree
                  , s = t.stat_desc.extra_bits
                  , o = t.stat_desc.extra_base
                  , l = t.stat_desc.max_length;
                let c, h, d, u, f, p, m = 0;
                for (u = 0; u <= Ys; u++)
                    e.bl_count[u] = 0;
                for (n[2 * e.heap[e.heap_max] + 1] = 0,
                c = e.heap_max + 1; c < 573; c++)
                    h = e.heap[c],
                    u = n[2 * n[2 * h + 1] + 1] + 1,
                    u > l && (u = l,
                    m++),
                    n[2 * h + 1] = u,
                    h > i || (e.bl_count[u]++,
                    f = 0,
                    h >= o && (f = s[h - o]),
                    p = n[2 * h],
                    e.opt_len += p * (u + f),
                    a && (e.static_len += p * (r[2 * h + 1] + f)));
                if (0 !== m) {
                    do {
                        for (u = l - 1; 0 === e.bl_count[u]; )
                            u--;
                        e.bl_count[u]--,
                        e.bl_count[u + 1] += 2,
                        e.bl_count[l]--,
                        m -= 2
                    } while (m > 0);
                    for (u = l; 0 !== u; u--)
                        for (h = e.bl_count[u]; 0 !== h; )
                            d = e.heap[--c],
                            d > i || (n[2 * d + 1] !== u && (e.opt_len += (u - n[2 * d + 1]) * n[2 * d],
                            n[2 * d + 1] = u),
                            h--)
                }
            }
            )(e, t),
            Ao(n, c, e.bl_count)
        }
          , So = (e, t, n) => {
            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
            for (0 === s && (l = 138,
            c = 3),
            t[2 * (n + 1) + 1] = 65535,
            i = 0; i <= n; i++)
                r = s,
                s = t[2 * (i + 1) + 1],
                ++o < l && r === s || (o < c ? e.bl_tree[2 * r] += o : 0 !== r ? (r !== a && e.bl_tree[2 * r]++,
                e.bl_tree[32]++) : o <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++,
                o = 0,
                a = r,
                0 === s ? (l = 138,
                c = 3) : r === s ? (l = 6,
                c = 3) : (l = 7,
                c = 4))
        }
          , Eo = (e, t, n) => {
            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
            for (0 === s && (l = 138,
            c = 3),
            i = 0; i <= n; i++)
                if (r = s,
                s = t[2 * (i + 1) + 1],
                !(++o < l && r === s)) {
                    if (o < c)
                        do {
                            mo(e, r, e.bl_tree)
                        } while (0 != --o);
                    else
                        0 !== r ? (r !== a && (mo(e, r, e.bl_tree),
                        o--),
                        mo(e, 16, e.bl_tree),
                        po(e, o - 3, 2)) : o <= 10 ? (mo(e, 17, e.bl_tree),
                        po(e, o - 3, 3)) : (mo(e, 18, e.bl_tree),
                        po(e, o - 11, 7));
                    o = 0,
                    a = r,
                    0 === s ? (l = 138,
                    c = 3) : r === s ? (l = 6,
                    c = 3) : (l = 7,
                    c = 4)
                }
        }
        ;
        let Mo = !1;
        const To = (e, t, n, i) => {
            po(e, 0 + (i ? 1 : 0), 3),
            vo(e),
            fo(e, n),
            fo(e, ~n),
            n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending),
            e.pending += n
        }
        ;
        var Co = (e, t, n, i) => {
            let r, a, s = 0;
            e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {
                let t, n = 4093624447;
                for (t = 0; t <= 31; t++,
                n >>>= 1)
                    if (1 & n && 0 !== e.dyn_ltree[2 * t])
                        return 0;
                if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26])
                    return 1;
                for (t = 32; t < Xs; t++)
                    if (0 !== e.dyn_ltree[2 * t])
                        return 1;
                return 0
            }
            )(e)),
            bo(e, e.l_desc),
            bo(e, e.d_desc),
            s = (e => {
                let t;
                for (So(e, e.dyn_ltree, e.l_desc.max_code),
                So(e, e.dyn_dtree, e.d_desc.max_code),
                bo(e, e.bl_desc),
                t = 18; t >= 3 && 0 === e.bl_tree[2 * $s[t] + 1]; t--)
                    ;
                return e.opt_len += 3 * (t + 1) + 5 + 5 + 4,
                t
            }
            )(e),
            r = e.opt_len + 3 + 7 >>> 3,
            a = e.static_len + 3 + 7 >>> 3,
            a <= r && (r = a)) : r = a = n + 5,
            n + 4 <= r && -1 !== t ? To(e, t, n, i) : 4 === e.strategy || a === r ? (po(e, 2 + (i ? 1 : 0), 3),
            xo(e, eo, to)) : (po(e, 4 + (i ? 1 : 0), 3),
            ( (e, t, n, i) => {
                let r;
                for (po(e, t - 257, 5),
                po(e, n - 1, 5),
                po(e, i - 4, 4),
                r = 0; r < i; r++)
                    po(e, e.bl_tree[2 * $s[r] + 1], 3);
                Eo(e, e.dyn_ltree, t - 1),
                Eo(e, e.dyn_dtree, n - 1)
            }
            )(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1),
            xo(e, e.dyn_ltree, e.dyn_dtree)),
            _o(e),
            i && vo(e)
        }
          , Io = {
            _tr_init: e => {
                Mo || (( () => {
                    let e, t, n, i, r;
                    const a = new Array(16);
                    for (n = 0,
                    i = 0; i < 28; i++)
                        for (ro[i] = n,
                        e = 0; e < 1 << Ks[i]; e++)
                            io[n++] = i;
                    for (io[n - 1] = i,
                    r = 0,
                    i = 0; i < 16; i++)
                        for (ao[i] = r,
                        e = 0; e < 1 << Zs[i]; e++)
                            no[r++] = i;
                    for (r >>= 7; i < qs; i++)
                        for (ao[i] = r << 7,
                        e = 0; e < 1 << Zs[i] - 7; e++)
                            no[256 + r++] = i;
                    for (t = 0; t <= Ys; t++)
                        a[t] = 0;
                    for (e = 0; e <= 143; )
                        eo[2 * e + 1] = 8,
                        e++,
                        a[8]++;
                    for (; e <= 255; )
                        eo[2 * e + 1] = 9,
                        e++,
                        a[9]++;
                    for (; e <= 279; )
                        eo[2 * e + 1] = 7,
                        e++,
                        a[7]++;
                    for (; e <= 287; )
                        eo[2 * e + 1] = 8,
                        e++,
                        a[8]++;
                    for (Ao(eo, 287, a),
                    e = 0; e < qs; e++)
                        to[2 * e + 1] = 5,
                        to[2 * e] = go(e, 5);
                    oo = new so(eo,Ks,257,js,Ys),
                    lo = new so(to,Zs,0,qs,Ys),
                    co = new so(new Array(0),Js,0,19,7)
                }
                )(),
                Mo = !0),
                e.l_desc = new ho(e.dyn_ltree,oo),
                e.d_desc = new ho(e.dyn_dtree,lo),
                e.bl_desc = new ho(e.bl_tree,co),
                e.bi_buf = 0,
                e.bi_valid = 0,
                _o(e)
            }
            ,
            _tr_stored_block: To,
            _tr_flush_block: Co,
            _tr_tally: (e, t, n) => (e.pending_buf[e.sym_buf + e.sym_next++] = t,
            e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8,
            e.pending_buf[e.sym_buf + e.sym_next++] = n,
            0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++,
            t--,
            e.dyn_ltree[2 * (io[n] + Xs + 1)]++,
            e.dyn_dtree[2 * uo(t)]++),
            e.sym_next === e.sym_end),
            _tr_align: e => {
                po(e, 2, 3),
                mo(e, 256, eo),
                (e => {
                    16 === e.bi_valid ? (fo(e, e.bi_buf),
                    e.bi_buf = 0,
                    e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf,
                    e.bi_buf >>= 8,
                    e.bi_valid -= 8)
                }
                )(e)
            }
        };
        var Ro = (e, t, n, i) => {
            let r = 65535 & e
              , a = e >>> 16 & 65535
              , s = 0;
            for (; 0 !== n; ) {
                s = n > 2e3 ? 2e3 : n,
                n -= s;
                do {
                    r = r + t[i++] | 0,
                    a = a + r | 0
                } while (--s);
                r %= 65521,
                a %= 65521
            }
            return r | a << 16
        }
        ;
        const Po = new Uint32Array(( () => {
            let e, t = [];
            for (var n = 0; n < 256; n++) {
                e = n;
                for (var i = 0; i < 8; i++)
                    e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                t[n] = e
            }
            return t
        }
        )());
        var Bo = (e, t, n, i) => {
            const r = Po
              , a = i + n;
            e ^= -1;
            for (let n = i; n < a; n++)
                e = e >>> 8 ^ r[255 & (e ^ t[n])];
            return ~e
        }
          , Do = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        }
          , Lo = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
        const {_tr_init: Uo, _tr_stored_block: No, _tr_flush_block: ko, _tr_tally: Fo, _tr_align: Oo} = Io
          , {Z_NO_FLUSH: zo, Z_PARTIAL_FLUSH: Ho, Z_FULL_FLUSH: Wo, Z_FINISH: Vo, Z_BLOCK: Go, Z_OK: Qo, Z_STREAM_END: Xo, Z_STREAM_ERROR: jo, Z_DATA_ERROR: qo, Z_BUF_ERROR: Yo, Z_DEFAULT_COMPRESSION: Ko, Z_FILTERED: Zo, Z_HUFFMAN_ONLY: Jo, Z_RLE: $o, Z_FIXED: el, Z_DEFAULT_STRATEGY: tl, Z_UNKNOWN: nl, Z_DEFLATED: il} = Lo
          , rl = 258
          , al = 262
          , sl = 42
          , ol = 113
          , ll = 666
          , cl = (e, t) => (e.msg = Do[t],
        t)
          , hl = e => 2 * e - (e > 4 ? 9 : 0)
          , dl = e => {
            let t = e.length;
            for (; --t >= 0; )
                e[t] = 0
        }
          , ul = e => {
            let t, n, i, r = e.w_size;
            t = e.hash_size,
            i = t;
            do {
                n = e.head[--i],
                e.head[i] = n >= r ? n - r : 0
            } while (--t);
            t = r,
            i = t;
            do {
                n = e.prev[--i],
                e.prev[i] = n >= r ? n - r : 0
            } while (--t)
        }
        ;
        let fl = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask;
        const pl = e => {
            const t = e.state;
            let n = t.pending;
            n > e.avail_out && (n = e.avail_out),
            0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out),
            e.next_out += n,
            t.pending_out += n,
            e.total_out += n,
            e.avail_out -= n,
            t.pending -= n,
            0 === t.pending && (t.pending_out = 0))
        }
          , ml = (e, t) => {
            ko(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t),
            e.block_start = e.strstart,
            pl(e.strm)
        }
          , gl = (e, t) => {
            e.pending_buf[e.pending++] = t
        }
          , Al = (e, t) => {
            e.pending_buf[e.pending++] = t >>> 8 & 255,
            e.pending_buf[e.pending++] = 255 & t
        }
          , _l = (e, t, n, i) => {
            let r = e.avail_in;
            return r > i && (r = i),
            0 === r ? 0 : (e.avail_in -= r,
            t.set(e.input.subarray(e.next_in, e.next_in + r), n),
            1 === e.state.wrap ? e.adler = Ro(e.adler, t, r, n) : 2 === e.state.wrap && (e.adler = Bo(e.adler, t, r, n)),
            e.next_in += r,
            e.total_in += r,
            r)
        }
          , vl = (e, t) => {
            let n, i, r = e.max_chain_length, a = e.strstart, s = e.prev_length, o = e.nice_match;
            const l = e.strstart > e.w_size - al ? e.strstart - (e.w_size - al) : 0
              , c = e.window
              , h = e.w_mask
              , d = e.prev
              , u = e.strstart + rl;
            let f = c[a + s - 1]
              , p = c[a + s];
            e.prev_length >= e.good_match && (r >>= 2),
            o > e.lookahead && (o = e.lookahead);
            do {
                if (n = t,
                c[n + s] === p && c[n + s - 1] === f && c[n] === c[a] && c[++n] === c[a + 1]) {
                    a += 2,
                    n++;
                    do {} while (c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && a < u);
                    if (i = rl - (u - a),
                    a = u - rl,
                    i > s) {
                        if (e.match_start = t,
                        s = i,
                        i >= o)
                            break;
                        f = c[a + s - 1],
                        p = c[a + s]
                    }
                }
            } while ((t = d[t & h]) > l && 0 != --r);
            return s <= e.lookahead ? s : e.lookahead
        }
          , wl = e => {
            const t = e.w_size;
            let n, i, r;
            do {
                if (i = e.window_size - e.lookahead - e.strstart,
                e.strstart >= t + (t - al) && (e.window.set(e.window.subarray(t, t + t - i), 0),
                e.match_start -= t,
                e.strstart -= t,
                e.block_start -= t,
                e.insert > e.strstart && (e.insert = e.strstart),
                ul(e),
                i += t),
                0 === e.strm.avail_in)
                    break;
                if (n = _l(e.strm, e.window, e.strstart + e.lookahead, i),
                e.lookahead += n,
                e.lookahead + e.insert >= 3)
                    for (r = e.strstart - e.insert,
                    e.ins_h = e.window[r],
                    e.ins_h = fl(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = fl(e, e.ins_h, e.window[r + 3 - 1]),
                    e.prev[r & e.w_mask] = e.head[e.ins_h],
                    e.head[e.ins_h] = r,
                    r++,
                    e.insert--,
                    !(e.lookahead + e.insert < 3)); )
                        ;
            } while (e.lookahead < al && 0 !== e.strm.avail_in)
        }
          , yl = (e, t) => {
            let n, i, r, a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, s = 0, o = e.strm.avail_in;
            do {
                if (n = 65535,
                r = e.bi_valid + 42 >> 3,
                e.strm.avail_out < r)
                    break;
                if (r = e.strm.avail_out - r,
                i = e.strstart - e.block_start,
                n > i + e.strm.avail_in && (n = i + e.strm.avail_in),
                n > r && (n = r),
                n < a && (0 === n && t !== Vo || t === zo || n !== i + e.strm.avail_in))
                    break;
                s = t === Vo && n === i + e.strm.avail_in ? 1 : 0,
                No(e, 0, 0, s),
                e.pending_buf[e.pending - 4] = n,
                e.pending_buf[e.pending - 3] = n >> 8,
                e.pending_buf[e.pending - 2] = ~n,
                e.pending_buf[e.pending - 1] = ~n >> 8,
                pl(e.strm),
                i && (i > n && (i = n),
                e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out),
                e.strm.next_out += i,
                e.strm.avail_out -= i,
                e.strm.total_out += i,
                e.block_start += i,
                n -= i),
                n && (_l(e.strm, e.strm.output, e.strm.next_out, n),
                e.strm.next_out += n,
                e.strm.avail_out -= n,
                e.strm.total_out += n)
            } while (0 === s);
            return o -= e.strm.avail_in,
            o && (o >= e.w_size ? (e.matches = 2,
            e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0),
            e.strstart = e.w_size,
            e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size,
            e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
            e.matches < 2 && e.matches++,
            e.insert > e.strstart && (e.insert = e.strstart)),
            e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart),
            e.strstart += o,
            e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o),
            e.block_start = e.strstart),
            e.high_water < e.strstart && (e.high_water = e.strstart),
            s ? 4 : t !== zo && t !== Vo && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart,
            e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size,
            e.strstart -= e.w_size,
            e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
            e.matches < 2 && e.matches++,
            r += e.w_size,
            e.insert > e.strstart && (e.insert = e.strstart)),
            r > e.strm.avail_in && (r = e.strm.avail_in),
            r && (_l(e.strm, e.window, e.strstart, r),
            e.strstart += r,
            e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r),
            e.high_water < e.strstart && (e.high_water = e.strstart),
            r = e.bi_valid + 42 >> 3,
            r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r,
            a = r > e.w_size ? e.w_size : r,
            i = e.strstart - e.block_start,
            (i >= a || (i || t === Vo) && t !== zo && 0 === e.strm.avail_in && i <= r) && (n = i > r ? r : i,
            s = t === Vo && 0 === e.strm.avail_in && n === i ? 1 : 0,
            No(e, e.block_start, n, s),
            e.block_start += n,
            pl(e.strm)),
            s ? 3 : 1)
        }
          , xl = (e, t) => {
            let n, i;
            for (; ; ) {
                if (e.lookahead < al) {
                    if (wl(e),
                    e.lookahead < al && t === zo)
                        return 1;
                    if (0 === e.lookahead)
                        break
                }
                if (n = 0,
                e.lookahead >= 3 && (e.ins_h = fl(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                e.head[e.ins_h] = e.strstart),
                0 !== n && e.strstart - n <= e.w_size - al && (e.match_length = vl(e, n)),
                e.match_length >= 3)
                    if (i = Fo(e, e.strstart - e.match_start, e.match_length - 3),
                    e.lookahead -= e.match_length,
                    e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                        e.match_length--;
                        do {
                            e.strstart++,
                            e.ins_h = fl(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                            n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                            e.head[e.ins_h] = e.strstart
                        } while (0 != --e.match_length);
                        e.strstart++
                    } else
                        e.strstart += e.match_length,
                        e.match_length = 0,
                        e.ins_h = e.window[e.strstart],
                        e.ins_h = fl(e, e.ins_h, e.window[e.strstart + 1]);
                else
                    i = Fo(e, 0, e.window[e.strstart]),
                    e.lookahead--,
                    e.strstart++;
                if (i && (ml(e, !1),
                0 === e.strm.avail_out))
                    return 1
            }
            return e.insert = e.strstart < 2 ? e.strstart : 2,
            t === Vo ? (ml(e, !0),
            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ml(e, !1),
            0 === e.strm.avail_out) ? 1 : 2
        }
          , bl = (e, t) => {
            let n, i, r;
            for (; ; ) {
                if (e.lookahead < al) {
                    if (wl(e),
                    e.lookahead < al && t === zo)
                        return 1;
                    if (0 === e.lookahead)
                        break
                }
                if (n = 0,
                e.lookahead >= 3 && (e.ins_h = fl(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                e.head[e.ins_h] = e.strstart),
                e.prev_length = e.match_length,
                e.prev_match = e.match_start,
                e.match_length = 2,
                0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - al && (e.match_length = vl(e, n),
                e.match_length <= 5 && (e.strategy === Zo || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)),
                e.prev_length >= 3 && e.match_length <= e.prev_length) {
                    r = e.strstart + e.lookahead - 3,
                    i = Fo(e, e.strstart - 1 - e.prev_match, e.prev_length - 3),
                    e.lookahead -= e.prev_length - 1,
                    e.prev_length -= 2;
                    do {
                        ++e.strstart <= r && (e.ins_h = fl(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                        n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                        e.head[e.ins_h] = e.strstart)
                    } while (0 != --e.prev_length);
                    if (e.match_available = 0,
                    e.match_length = 2,
                    e.strstart++,
                    i && (ml(e, !1),
                    0 === e.strm.avail_out))
                        return 1
                } else if (e.match_available) {
                    if (i = Fo(e, 0, e.window[e.strstart - 1]),
                    i && ml(e, !1),
                    e.strstart++,
                    e.lookahead--,
                    0 === e.strm.avail_out)
                        return 1
                } else
                    e.match_available = 1,
                    e.strstart++,
                    e.lookahead--
            }
            return e.match_available && (i = Fo(e, 0, e.window[e.strstart - 1]),
            e.match_available = 0),
            e.insert = e.strstart < 2 ? e.strstart : 2,
            t === Vo ? (ml(e, !0),
            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ml(e, !1),
            0 === e.strm.avail_out) ? 1 : 2
        }
        ;
        function Sl(e, t, n, i, r) {
            this.good_length = e,
            this.max_lazy = t,
            this.nice_length = n,
            this.max_chain = i,
            this.func = r
        }
        const El = [new Sl(0,0,0,0,yl), new Sl(4,4,8,4,xl), new Sl(4,5,16,8,xl), new Sl(4,6,32,32,xl), new Sl(4,4,16,16,bl), new Sl(8,16,32,32,bl), new Sl(8,16,128,128,bl), new Sl(8,32,128,256,bl), new Sl(32,128,258,1024,bl), new Sl(32,258,258,4096,bl)];
        function Ml() {
            this.strm = null,
            this.status = 0,
            this.pending_buf = null,
            this.pending_buf_size = 0,
            this.pending_out = 0,
            this.pending = 0,
            this.wrap = 0,
            this.gzhead = null,
            this.gzindex = 0,
            this.method = il,
            this.last_flush = -1,
            this.w_size = 0,
            this.w_bits = 0,
            this.w_mask = 0,
            this.window = null,
            this.window_size = 0,
            this.prev = null,
            this.head = null,
            this.ins_h = 0,
            this.hash_size = 0,
            this.hash_bits = 0,
            this.hash_mask = 0,
            this.hash_shift = 0,
            this.block_start = 0,
            this.match_length = 0,
            this.prev_match = 0,
            this.match_available = 0,
            this.strstart = 0,
            this.match_start = 0,
            this.lookahead = 0,
            this.prev_length = 0,
            this.max_chain_length = 0,
            this.max_lazy_match = 0,
            this.level = 0,
            this.strategy = 0,
            this.good_match = 0,
            this.nice_match = 0,
            this.dyn_ltree = new Uint16Array(1146),
            this.dyn_dtree = new Uint16Array(122),
            this.bl_tree = new Uint16Array(78),
            dl(this.dyn_ltree),
            dl(this.dyn_dtree),
            dl(this.bl_tree),
            this.l_desc = null,
            this.d_desc = null,
            this.bl_desc = null,
            this.bl_count = new Uint16Array(16),
            this.heap = new Uint16Array(573),
            dl(this.heap),
            this.heap_len = 0,
            this.heap_max = 0,
            this.depth = new Uint16Array(573),
            dl(this.depth),
            this.sym_buf = 0,
            this.lit_bufsize = 0,
            this.sym_next = 0,
            this.sym_end = 0,
            this.opt_len = 0,
            this.static_len = 0,
            this.matches = 0,
            this.insert = 0,
            this.bi_buf = 0,
            this.bi_valid = 0
        }
        const Tl = e => {
            if (!e)
                return 1;
            const t = e.state;
            return !t || t.strm !== e || t.status !== sl && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== ol && t.status !== ll ? 1 : 0
        }
          , Cl = e => {
            if (Tl(e))
                return cl(e, jo);
            e.total_in = e.total_out = 0,
            e.data_type = nl;
            const t = e.state;
            return t.pending = 0,
            t.pending_out = 0,
            t.wrap < 0 && (t.wrap = -t.wrap),
            t.status = 2 === t.wrap ? 57 : t.wrap ? sl : ol,
            e.adler = 2 === t.wrap ? 0 : 1,
            t.last_flush = -2,
            Uo(t),
            Qo
        }
          , Il = e => {
            const t = Cl(e);
            var n;
            return t === Qo && ((n = e.state).window_size = 2 * n.w_size,
            dl(n.head),
            n.max_lazy_match = El[n.level].max_lazy,
            n.good_match = El[n.level].good_length,
            n.nice_match = El[n.level].nice_length,
            n.max_chain_length = El[n.level].max_chain,
            n.strstart = 0,
            n.block_start = 0,
            n.lookahead = 0,
            n.insert = 0,
            n.match_length = n.prev_length = 2,
            n.match_available = 0,
            n.ins_h = 0),
            t
        }
          , Rl = (e, t, n, i, r, a) => {
            if (!e)
                return jo;
            let s = 1;
            if (t === Ko && (t = 6),
            i < 0 ? (s = 0,
            i = -i) : i > 15 && (s = 2,
            i -= 16),
            r < 1 || r > 9 || n !== il || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > el || 8 === i && 1 !== s)
                return cl(e, jo);
            8 === i && (i = 9);
            const o = new Ml;
            return e.state = o,
            o.strm = e,
            o.status = sl,
            o.wrap = s,
            o.gzhead = null,
            o.w_bits = i,
            o.w_size = 1 << o.w_bits,
            o.w_mask = o.w_size - 1,
            o.hash_bits = r + 7,
            o.hash_size = 1 << o.hash_bits,
            o.hash_mask = o.hash_size - 1,
            o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3),
            o.window = new Uint8Array(2 * o.w_size),
            o.head = new Uint16Array(o.hash_size),
            o.prev = new Uint16Array(o.w_size),
            o.lit_bufsize = 1 << r + 6,
            o.pending_buf_size = 4 * o.lit_bufsize,
            o.pending_buf = new Uint8Array(o.pending_buf_size),
            o.sym_buf = o.lit_bufsize,
            o.sym_end = 3 * (o.lit_bufsize - 1),
            o.level = t,
            o.strategy = a,
            o.method = n,
            Il(e)
        }
        ;
        var Pl = {
            deflateInit: (e, t) => Rl(e, t, il, 15, 8, tl),
            deflateInit2: Rl,
            deflateReset: Il,
            deflateResetKeep: Cl,
            deflateSetHeader: (e, t) => Tl(e) || 2 !== e.state.wrap ? jo : (e.state.gzhead = t,
            Qo),
            deflate: (e, t) => {
                if (Tl(e) || t > Go || t < 0)
                    return e ? cl(e, jo) : jo;
                const n = e.state;
                if (!e.output || 0 !== e.avail_in && !e.input || n.status === ll && t !== Vo)
                    return cl(e, 0 === e.avail_out ? Yo : jo);
                const i = n.last_flush;
                if (n.last_flush = t,
                0 !== n.pending) {
                    if (pl(e),
                    0 === e.avail_out)
                        return n.last_flush = -1,
                        Qo
                } else if (0 === e.avail_in && hl(t) <= hl(i) && t !== Vo)
                    return cl(e, Yo);
                if (n.status === ll && 0 !== e.avail_in)
                    return cl(e, Yo);
                if (n.status === sl && 0 === n.wrap && (n.status = ol),
                n.status === sl) {
                    let t = il + (n.w_bits - 8 << 4) << 8
                      , i = -1;
                    if (i = n.strategy >= Jo || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3,
                    t |= i << 6,
                    0 !== n.strstart && (t |= 32),
                    t += 31 - t % 31,
                    Al(n, t),
                    0 !== n.strstart && (Al(n, e.adler >>> 16),
                    Al(n, 65535 & e.adler)),
                    e.adler = 1,
                    n.status = ol,
                    pl(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        Qo
                }
                if (57 === n.status)
                    if (e.adler = 0,
                    gl(n, 31),
                    gl(n, 139),
                    gl(n, 8),
                    n.gzhead)
                        gl(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)),
                        gl(n, 255 & n.gzhead.time),
                        gl(n, n.gzhead.time >> 8 & 255),
                        gl(n, n.gzhead.time >> 16 & 255),
                        gl(n, n.gzhead.time >> 24 & 255),
                        gl(n, 9 === n.level ? 2 : n.strategy >= Jo || n.level < 2 ? 4 : 0),
                        gl(n, 255 & n.gzhead.os),
                        n.gzhead.extra && n.gzhead.extra.length && (gl(n, 255 & n.gzhead.extra.length),
                        gl(n, n.gzhead.extra.length >> 8 & 255)),
                        n.gzhead.hcrc && (e.adler = Bo(e.adler, n.pending_buf, n.pending, 0)),
                        n.gzindex = 0,
                        n.status = 69;
                    else if (gl(n, 0),
                    gl(n, 0),
                    gl(n, 0),
                    gl(n, 0),
                    gl(n, 0),
                    gl(n, 9 === n.level ? 2 : n.strategy >= Jo || n.level < 2 ? 4 : 0),
                    gl(n, 3),
                    n.status = ol,
                    pl(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        Qo;
                if (69 === n.status) {
                    if (n.gzhead.extra) {
                        let t = n.pending
                          , i = (65535 & n.gzhead.extra.length) - n.gzindex;
                        for (; n.pending + i > n.pending_buf_size; ) {
                            let r = n.pending_buf_size - n.pending;
                            if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + r), n.pending),
                            n.pending = n.pending_buf_size,
                            n.gzhead.hcrc && n.pending > t && (e.adler = Bo(e.adler, n.pending_buf, n.pending - t, t)),
                            n.gzindex += r,
                            pl(e),
                            0 !== n.pending)
                                return n.last_flush = -1,
                                Qo;
                            t = 0,
                            i -= r
                        }
                        let r = new Uint8Array(n.gzhead.extra);
                        n.pending_buf.set(r.subarray(n.gzindex, n.gzindex + i), n.pending),
                        n.pending += i,
                        n.gzhead.hcrc && n.pending > t && (e.adler = Bo(e.adler, n.pending_buf, n.pending - t, t)),
                        n.gzindex = 0
                    }
                    n.status = 73
                }
                if (73 === n.status) {
                    if (n.gzhead.name) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (e.adler = Bo(e.adler, n.pending_buf, n.pending - i, i)),
                                pl(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                    Qo;
                                i = 0
                            }
                            t = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0,
                            gl(n, t)
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (e.adler = Bo(e.adler, n.pending_buf, n.pending - i, i)),
                        n.gzindex = 0
                    }
                    n.status = 91
                }
                if (91 === n.status) {
                    if (n.gzhead.comment) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (e.adler = Bo(e.adler, n.pending_buf, n.pending - i, i)),
                                pl(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                    Qo;
                                i = 0
                            }
                            t = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0,
                            gl(n, t)
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (e.adler = Bo(e.adler, n.pending_buf, n.pending - i, i))
                    }
                    n.status = 103
                }
                if (103 === n.status) {
                    if (n.gzhead.hcrc) {
                        if (n.pending + 2 > n.pending_buf_size && (pl(e),
                        0 !== n.pending))
                            return n.last_flush = -1,
                            Qo;
                        gl(n, 255 & e.adler),
                        gl(n, e.adler >> 8 & 255),
                        e.adler = 0
                    }
                    if (n.status = ol,
                    pl(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        Qo
                }
                if (0 !== e.avail_in || 0 !== n.lookahead || t !== zo && n.status !== ll) {
                    let i = 0 === n.level ? yl(n, t) : n.strategy === Jo ? ( (e, t) => {
                        let n;
                        for (; ; ) {
                            if (0 === e.lookahead && (wl(e),
                            0 === e.lookahead)) {
                                if (t === zo)
                                    return 1;
                                break
                            }
                            if (e.match_length = 0,
                            n = Fo(e, 0, e.window[e.strstart]),
                            e.lookahead--,
                            e.strstart++,
                            n && (ml(e, !1),
                            0 === e.strm.avail_out))
                                return 1
                        }
                        return e.insert = 0,
                        t === Vo ? (ml(e, !0),
                        0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ml(e, !1),
                        0 === e.strm.avail_out) ? 1 : 2
                    }
                    )(n, t) : n.strategy === $o ? ( (e, t) => {
                        let n, i, r, a;
                        const s = e.window;
                        for (; ; ) {
                            if (e.lookahead <= rl) {
                                if (wl(e),
                                e.lookahead <= rl && t === zo)
                                    return 1;
                                if (0 === e.lookahead)
                                    break
                            }
                            if (e.match_length = 0,
                            e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1,
                            i = s[r],
                            i === s[++r] && i === s[++r] && i === s[++r])) {
                                a = e.strstart + rl;
                                do {} while (i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && r < a);
                                e.match_length = rl - (a - r),
                                e.match_length > e.lookahead && (e.match_length = e.lookahead)
                            }
                            if (e.match_length >= 3 ? (n = Fo(e, 1, e.match_length - 3),
                            e.lookahead -= e.match_length,
                            e.strstart += e.match_length,
                            e.match_length = 0) : (n = Fo(e, 0, e.window[e.strstart]),
                            e.lookahead--,
                            e.strstart++),
                            n && (ml(e, !1),
                            0 === e.strm.avail_out))
                                return 1
                        }
                        return e.insert = 0,
                        t === Vo ? (ml(e, !0),
                        0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ml(e, !1),
                        0 === e.strm.avail_out) ? 1 : 2
                    }
                    )(n, t) : El[n.level].func(n, t);
                    if (3 !== i && 4 !== i || (n.status = ll),
                    1 === i || 3 === i)
                        return 0 === e.avail_out && (n.last_flush = -1),
                        Qo;
                    if (2 === i && (t === Ho ? Oo(n) : t !== Go && (No(n, 0, 0, !1),
                    t === Wo && (dl(n.head),
                    0 === n.lookahead && (n.strstart = 0,
                    n.block_start = 0,
                    n.insert = 0))),
                    pl(e),
                    0 === e.avail_out))
                        return n.last_flush = -1,
                        Qo
                }
                return t !== Vo ? Qo : n.wrap <= 0 ? Xo : (2 === n.wrap ? (gl(n, 255 & e.adler),
                gl(n, e.adler >> 8 & 255),
                gl(n, e.adler >> 16 & 255),
                gl(n, e.adler >> 24 & 255),
                gl(n, 255 & e.total_in),
                gl(n, e.total_in >> 8 & 255),
                gl(n, e.total_in >> 16 & 255),
                gl(n, e.total_in >> 24 & 255)) : (Al(n, e.adler >>> 16),
                Al(n, 65535 & e.adler)),
                pl(e),
                n.wrap > 0 && (n.wrap = -n.wrap),
                0 !== n.pending ? Qo : Xo)
            }
            ,
            deflateEnd: e => {
                if (Tl(e))
                    return jo;
                const t = e.state.status;
                return e.state = null,
                t === ol ? cl(e, qo) : Qo
            }
            ,
            deflateSetDictionary: (e, t) => {
                let n = t.length;
                if (Tl(e))
                    return jo;
                const i = e.state
                  , r = i.wrap;
                if (2 === r || 1 === r && i.status !== sl || i.lookahead)
                    return jo;
                if (1 === r && (e.adler = Ro(e.adler, t, n, 0)),
                i.wrap = 0,
                n >= i.w_size) {
                    0 === r && (dl(i.head),
                    i.strstart = 0,
                    i.block_start = 0,
                    i.insert = 0);
                    let e = new Uint8Array(i.w_size);
                    e.set(t.subarray(n - i.w_size, n), 0),
                    t = e,
                    n = i.w_size
                }
                const a = e.avail_in
                  , s = e.next_in
                  , o = e.input;
                for (e.avail_in = n,
                e.next_in = 0,
                e.input = t,
                wl(i); i.lookahead >= 3; ) {
                    let e = i.strstart
                      , t = i.lookahead - 2;
                    do {
                        i.ins_h = fl(i, i.ins_h, i.window[e + 3 - 1]),
                        i.prev[e & i.w_mask] = i.head[i.ins_h],
                        i.head[i.ins_h] = e,
                        e++
                    } while (--t);
                    i.strstart = e,
                    i.lookahead = 2,
                    wl(i)
                }
                return i.strstart += i.lookahead,
                i.block_start = i.strstart,
                i.insert = i.lookahead,
                i.lookahead = 0,
                i.match_length = i.prev_length = 2,
                i.match_available = 0,
                e.next_in = s,
                e.input = o,
                e.avail_in = a,
                i.wrap = r,
                Qo
            }
            ,
            deflateInfo: "pako deflate (from Nodeca project)"
        };
        const Bl = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
        var Dl = function(e) {
            const t = Array.prototype.slice.call(arguments, 1);
            for (; t.length; ) {
                const n = t.shift();
                if (n) {
                    if ("object" != typeof n)
                        throw new TypeError(n + "must be non-object");
                    for (const t in n)
                        Bl(n, t) && (e[t] = n[t])
                }
            }
            return e
        }
          , Ll = e => {
            let t = 0;
            for (let n = 0, i = e.length; n < i; n++)
                t += e[n].length;
            const n = new Uint8Array(t);
            for (let t = 0, i = 0, r = e.length; t < r; t++) {
                let r = e[t];
                n.set(r, i),
                i += r.length
            }
            return n
        }
        ;
        let Ul = !0;
        try {
            String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (e) {
            Ul = !1
        }
        const Nl = new Uint8Array(256);
        for (let e = 0; e < 256; e++)
            Nl[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
        Nl[254] = Nl[254] = 1;
        var kl = e => {
            if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                return (new TextEncoder).encode(e);
            let t, n, i, r, a, s = e.length, o = 0;
            for (r = 0; r < s; r++)
                n = e.charCodeAt(r),
                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                r++)),
                o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
            for (t = new Uint8Array(o),
            a = 0,
            r = 0; a < o; r++)
                n = e.charCodeAt(r),
                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                r++)),
                n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6,
                t[a++] = 128 | 63 & n) : n < 65536 ? (t[a++] = 224 | n >>> 12,
                t[a++] = 128 | n >>> 6 & 63,
                t[a++] = 128 | 63 & n) : (t[a++] = 240 | n >>> 18,
                t[a++] = 128 | n >>> 12 & 63,
                t[a++] = 128 | n >>> 6 & 63,
                t[a++] = 128 | 63 & n);
            return t
        }
          , Fl = (e, t) => {
            const n = t || e.length;
            if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                return (new TextDecoder).decode(e.subarray(0, t));
            let i, r;
            const a = new Array(2 * n);
            for (r = 0,
            i = 0; i < n; ) {
                let t = e[i++];
                if (t < 128) {
                    a[r++] = t;
                    continue
                }
                let s = Nl[t];
                if (s > 4)
                    a[r++] = 65533,
                    i += s - 1;
                else {
                    for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < n; )
                        t = t << 6 | 63 & e[i++],
                        s--;
                    s > 1 ? a[r++] = 65533 : t < 65536 ? a[r++] = t : (t -= 65536,
                    a[r++] = 55296 | t >> 10 & 1023,
                    a[r++] = 56320 | 1023 & t)
                }
            }
            return ( (e, t) => {
                if (t < 65534 && e.subarray && Ul)
                    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                let n = "";
                for (let i = 0; i < t; i++)
                    n += String.fromCharCode(e[i]);
                return n
            }
            )(a, r)
        }
          , Ol = (e, t) => {
            (t = t || e.length) > e.length && (t = e.length);
            let n = t - 1;
            for (; n >= 0 && 128 == (192 & e[n]); )
                n--;
            return n < 0 || 0 === n ? t : n + Nl[e[n]] > t ? n : t
        }
        ;
        var zl = function() {
            this.input = null,
            this.next_in = 0,
            this.avail_in = 0,
            this.total_in = 0,
            this.output = null,
            this.next_out = 0,
            this.avail_out = 0,
            this.total_out = 0,
            this.msg = "",
            this.state = null,
            this.data_type = 2,
            this.adler = 0
        };
        const Hl = Object.prototype.toString
          , {Z_NO_FLUSH: Wl, Z_SYNC_FLUSH: Vl, Z_FULL_FLUSH: Gl, Z_FINISH: Ql, Z_OK: Xl, Z_STREAM_END: jl, Z_DEFAULT_COMPRESSION: ql, Z_DEFAULT_STRATEGY: Yl, Z_DEFLATED: Kl} = Lo;
        function Zl(e) {
            this.options = Dl({
                level: ql,
                method: Kl,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Yl
            }, e || {});
            let t = this.options;
            t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new zl,
            this.strm.avail_out = 0;
            let n = Pl.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
            if (n !== Xl)
                throw new Error(Do[n]);
            if (t.header && Pl.deflateSetHeader(this.strm, t.header),
            t.dictionary) {
                let e;
                if (e = "string" == typeof t.dictionary ? kl(t.dictionary) : "[object ArrayBuffer]" === Hl.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary,
                n = Pl.deflateSetDictionary(this.strm, e),
                n !== Xl)
                    throw new Error(Do[n]);
                this._dict_set = !0
            }
        }
        function Jl(e, t) {
            const n = new Zl(t);
            if (n.push(e, !0),
            n.err)
                throw n.msg || Do[n.err];
            return n.result
        }
        Zl.prototype.push = function(e, t) {
            const n = this.strm
              , i = this.options.chunkSize;
            let r, a;
            if (this.ended)
                return !1;
            for (a = t === ~~t ? t : !0 === t ? Ql : Wl,
            "string" == typeof e ? n.input = kl(e) : "[object ArrayBuffer]" === Hl.call(e) ? n.input = new Uint8Array(e) : n.input = e,
            n.next_in = 0,
            n.avail_in = n.input.length; ; )
                if (0 === n.avail_out && (n.output = new Uint8Array(i),
                n.next_out = 0,
                n.avail_out = i),
                (a === Vl || a === Gl) && n.avail_out <= 6)
                    this.onData(n.output.subarray(0, n.next_out)),
                    n.avail_out = 0;
                else {
                    if (r = Pl.deflate(n, a),
                    r === jl)
                        return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)),
                        r = Pl.deflateEnd(this.strm),
                        this.onEnd(r),
                        this.ended = !0,
                        r === Xl;
                    if (0 !== n.avail_out) {
                        if (a > 0 && n.next_out > 0)
                            this.onData(n.output.subarray(0, n.next_out)),
                            n.avail_out = 0;
                        else if (0 === n.avail_in)
                            break
                    } else
                        this.onData(n.output)
                }
            return !0
        }
        ,
        Zl.prototype.onData = function(e) {
            this.chunks.push(e)
        }
        ,
        Zl.prototype.onEnd = function(e) {
            e === Xl && (this.result = Ll(this.chunks)),
            this.chunks = [],
            this.err = e,
            this.msg = this.strm.msg
        }
        ;
        var $l = {
            Deflate: Zl,
            deflate: Jl,
            deflateRaw: function(e, t) {
                return (t = t || {}).raw = !0,
                Jl(e, t)
            },
            gzip: function(e, t) {
                return (t = t || {}).gzip = !0,
                Jl(e, t)
            },
            constants: Lo
        };
        const ec = 16209;
        var tc = function(e, t) {
            let n, i, r, a, s, o, l, c, h, d, u, f, p, m, g, A, _, v, w, y, x, b, S, E;
            const M = e.state;
            n = e.next_in,
            S = e.input,
            i = n + (e.avail_in - 5),
            r = e.next_out,
            E = e.output,
            a = r - (t - e.avail_out),
            s = r + (e.avail_out - 257),
            o = M.dmax,
            l = M.wsize,
            c = M.whave,
            h = M.wnext,
            d = M.window,
            u = M.hold,
            f = M.bits,
            p = M.lencode,
            m = M.distcode,
            g = (1 << M.lenbits) - 1,
            A = (1 << M.distbits) - 1;
            e: do {
                f < 15 && (u += S[n++] << f,
                f += 8,
                u += S[n++] << f,
                f += 8),
                _ = p[u & g];
                t: for (; ; ) {
                    if (v = _ >>> 24,
                    u >>>= v,
                    f -= v,
                    v = _ >>> 16 & 255,
                    0 === v)
                        E[r++] = 65535 & _;
                    else {
                        if (!(16 & v)) {
                            if (64 & v) {
                                if (32 & v) {
                                    M.mode = 16191;
                                    break e
                                }
                                e.msg = "invalid literal/length code",
                                M.mode = ec;
                                break e
                            }
                            _ = p[(65535 & _) + (u & (1 << v) - 1)];
                            continue t
                        }
                        for (w = 65535 & _,
                        v &= 15,
                        v && (f < v && (u += S[n++] << f,
                        f += 8),
                        w += u & (1 << v) - 1,
                        u >>>= v,
                        f -= v),
                        f < 15 && (u += S[n++] << f,
                        f += 8,
                        u += S[n++] << f,
                        f += 8),
                        _ = m[u & A]; ; ) {
                            if (v = _ >>> 24,
                            u >>>= v,
                            f -= v,
                            v = _ >>> 16 & 255,
                            16 & v) {
                                if (y = 65535 & _,
                                v &= 15,
                                f < v && (u += S[n++] << f,
                                f += 8,
                                f < v && (u += S[n++] << f,
                                f += 8)),
                                y += u & (1 << v) - 1,
                                y > o) {
                                    e.msg = "invalid distance too far back",
                                    M.mode = ec;
                                    break e
                                }
                                if (u >>>= v,
                                f -= v,
                                v = r - a,
                                y > v) {
                                    if (v = y - v,
                                    v > c && M.sane) {
                                        e.msg = "invalid distance too far back",
                                        M.mode = ec;
                                        break e
                                    }
                                    if (x = 0,
                                    b = d,
                                    0 === h) {
                                        if (x += l - v,
                                        v < w) {
                                            w -= v;
                                            do {
                                                E[r++] = d[x++]
                                            } while (--v);
                                            x = r - y,
                                            b = E
                                        }
                                    } else if (h < v) {
                                        if (x += l + h - v,
                                        v -= h,
                                        v < w) {
                                            w -= v;
                                            do {
                                                E[r++] = d[x++]
                                            } while (--v);
                                            if (x = 0,
                                            h < w) {
                                                v = h,
                                                w -= v;
                                                do {
                                                    E[r++] = d[x++]
                                                } while (--v);
                                                x = r - y,
                                                b = E
                                            }
                                        }
                                    } else if (x += h - v,
                                    v < w) {
                                        w -= v;
                                        do {
                                            E[r++] = d[x++]
                                        } while (--v);
                                        x = r - y,
                                        b = E
                                    }
                                    for (; w > 2; )
                                        E[r++] = b[x++],
                                        E[r++] = b[x++],
                                        E[r++] = b[x++],
                                        w -= 3;
                                    w && (E[r++] = b[x++],
                                    w > 1 && (E[r++] = b[x++]))
                                } else {
                                    x = r - y;
                                    do {
                                        E[r++] = E[x++],
                                        E[r++] = E[x++],
                                        E[r++] = E[x++],
                                        w -= 3
                                    } while (w > 2);
                                    w && (E[r++] = E[x++],
                                    w > 1 && (E[r++] = E[x++]))
                                }
                                break
                            }
                            if (64 & v) {
                                e.msg = "invalid distance code",
                                M.mode = ec;
                                break e
                            }
                            _ = m[(65535 & _) + (u & (1 << v) - 1)]
                        }
                    }
                    break
                }
            } while (n < i && r < s);
            w = f >> 3,
            n -= w,
            f -= w << 3,
            u &= (1 << f) - 1,
            e.next_in = n,
            e.next_out = r,
            e.avail_in = n < i ? i - n + 5 : 5 - (n - i),
            e.avail_out = r < s ? s - r + 257 : 257 - (r - s),
            M.hold = u,
            M.bits = f
        };
        const nc = 15
          , ic = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
          , rc = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
          , ac = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
          , sc = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
        var oc = (e, t, n, i, r, a, s, o) => {
            const l = o.bits;
            let c, h, d, u, f, p, m = 0, g = 0, A = 0, _ = 0, v = 0, w = 0, y = 0, x = 0, b = 0, S = 0, E = null;
            const M = new Uint16Array(16)
              , T = new Uint16Array(16);
            let C, I, R, P = null;
            for (m = 0; m <= nc; m++)
                M[m] = 0;
            for (g = 0; g < i; g++)
                M[t[n + g]]++;
            for (v = l,
            _ = nc; _ >= 1 && 0 === M[_]; _--)
                ;
            if (v > _ && (v = _),
            0 === _)
                return r[a++] = 20971520,
                r[a++] = 20971520,
                o.bits = 1,
                0;
            for (A = 1; A < _ && 0 === M[A]; A++)
                ;
            for (v < A && (v = A),
            x = 1,
            m = 1; m <= nc; m++)
                if (x <<= 1,
                x -= M[m],
                x < 0)
                    return -1;
            if (x > 0 && (0 === e || 1 !== _))
                return -1;
            for (T[1] = 0,
            m = 1; m < nc; m++)
                T[m + 1] = T[m] + M[m];
            for (g = 0; g < i; g++)
                0 !== t[n + g] && (s[T[t[n + g]]++] = g);
            if (0 === e ? (E = P = s,
            p = 20) : 1 === e ? (E = ic,
            P = rc,
            p = 257) : (E = ac,
            P = sc,
            p = 0),
            S = 0,
            g = 0,
            m = A,
            f = a,
            w = v,
            y = 0,
            d = -1,
            b = 1 << v,
            u = b - 1,
            1 === e && b > 852 || 2 === e && b > 592)
                return 1;
            for (; ; ) {
                C = m - y,
                s[g] + 1 < p ? (I = 0,
                R = s[g]) : s[g] >= p ? (I = P[s[g] - p],
                R = E[s[g] - p]) : (I = 96,
                R = 0),
                c = 1 << m - y,
                h = 1 << w,
                A = h;
                do {
                    h -= c,
                    r[f + (S >> y) + h] = C << 24 | I << 16 | R
                } while (0 !== h);
                for (c = 1 << m - 1; S & c; )
                    c >>= 1;
                if (0 !== c ? (S &= c - 1,
                S += c) : S = 0,
                g++,
                0 == --M[m]) {
                    if (m === _)
                        break;
                    m = t[n + s[g]]
                }
                if (m > v && (S & u) !== d) {
                    for (0 === y && (y = v),
                    f += A,
                    w = m - y,
                    x = 1 << w; w + y < _ && (x -= M[w + y],
                    !(x <= 0)); )
                        w++,
                        x <<= 1;
                    if (b += 1 << w,
                    1 === e && b > 852 || 2 === e && b > 592)
                        return 1;
                    d = S & u,
                    r[d] = v << 24 | w << 16 | f - a
                }
            }
            return 0 !== S && (r[f + S] = m - y << 24 | 64 << 16),
            o.bits = v,
            0
        }
        ;
        const {Z_FINISH: lc, Z_BLOCK: cc, Z_TREES: hc, Z_OK: dc, Z_STREAM_END: uc, Z_NEED_DICT: fc, Z_STREAM_ERROR: pc, Z_DATA_ERROR: mc, Z_MEM_ERROR: gc, Z_BUF_ERROR: Ac, Z_DEFLATED: _c} = Lo
          , vc = 16180
          , wc = 16190
          , yc = 16191
          , xc = 16192
          , bc = 16194
          , Sc = 16199
          , Ec = 16200
          , Mc = 16206
          , Tc = 16209
          , Cc = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
        function Ic() {
            this.strm = null,
            this.mode = 0,
            this.last = !1,
            this.wrap = 0,
            this.havedict = !1,
            this.flags = 0,
            this.dmax = 0,
            this.check = 0,
            this.total = 0,
            this.head = null,
            this.wbits = 0,
            this.wsize = 0,
            this.whave = 0,
            this.wnext = 0,
            this.window = null,
            this.hold = 0,
            this.bits = 0,
            this.length = 0,
            this.offset = 0,
            this.extra = 0,
            this.lencode = null,
            this.distcode = null,
            this.lenbits = 0,
            this.distbits = 0,
            this.ncode = 0,
            this.nlen = 0,
            this.ndist = 0,
            this.have = 0,
            this.next = null,
            this.lens = new Uint16Array(320),
            this.work = new Uint16Array(288),
            this.lendyn = null,
            this.distdyn = null,
            this.sane = 0,
            this.back = 0,
            this.was = 0
        }
        const Rc = e => {
            if (!e)
                return 1;
            const t = e.state;
            return !t || t.strm !== e || t.mode < vc || t.mode > 16211 ? 1 : 0
        }
          , Pc = e => {
            if (Rc(e))
                return pc;
            const t = e.state;
            return e.total_in = e.total_out = t.total = 0,
            e.msg = "",
            t.wrap && (e.adler = 1 & t.wrap),
            t.mode = vc,
            t.last = 0,
            t.havedict = 0,
            t.flags = -1,
            t.dmax = 32768,
            t.head = null,
            t.hold = 0,
            t.bits = 0,
            t.lencode = t.lendyn = new Int32Array(852),
            t.distcode = t.distdyn = new Int32Array(592),
            t.sane = 1,
            t.back = -1,
            dc
        }
          , Bc = e => {
            if (Rc(e))
                return pc;
            const t = e.state;
            return t.wsize = 0,
            t.whave = 0,
            t.wnext = 0,
            Pc(e)
        }
          , Dc = (e, t) => {
            let n;
            if (Rc(e))
                return pc;
            const i = e.state;
            return t < 0 ? (n = 0,
            t = -t) : (n = 5 + (t >> 4),
            t < 48 && (t &= 15)),
            t && (t < 8 || t > 15) ? pc : (null !== i.window && i.wbits !== t && (i.window = null),
            i.wrap = n,
            i.wbits = t,
            Bc(e))
        }
          , Lc = (e, t) => {
            if (!e)
                return pc;
            const n = new Ic;
            e.state = n,
            n.strm = e,
            n.window = null,
            n.mode = vc;
            const i = Dc(e, t);
            return i !== dc && (e.state = null),
            i
        }
        ;
        let Uc, Nc, kc = !0;
        const Fc = e => {
            if (kc) {
                Uc = new Int32Array(512),
                Nc = new Int32Array(32);
                let t = 0;
                for (; t < 144; )
                    e.lens[t++] = 8;
                for (; t < 256; )
                    e.lens[t++] = 9;
                for (; t < 280; )
                    e.lens[t++] = 7;
                for (; t < 288; )
                    e.lens[t++] = 8;
                for (oc(1, e.lens, 0, 288, Uc, 0, e.work, {
                    bits: 9
                }),
                t = 0; t < 32; )
                    e.lens[t++] = 5;
                oc(2, e.lens, 0, 32, Nc, 0, e.work, {
                    bits: 5
                }),
                kc = !1
            }
            e.lencode = Uc,
            e.lenbits = 9,
            e.distcode = Nc,
            e.distbits = 5
        }
          , Oc = (e, t, n, i) => {
            let r;
            const a = e.state;
            return null === a.window && (a.wsize = 1 << a.wbits,
            a.wnext = 0,
            a.whave = 0,
            a.window = new Uint8Array(a.wsize)),
            i >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0),
            a.wnext = 0,
            a.whave = a.wsize) : (r = a.wsize - a.wnext,
            r > i && (r = i),
            a.window.set(t.subarray(n - i, n - i + r), a.wnext),
            (i -= r) ? (a.window.set(t.subarray(n - i, n), 0),
            a.wnext = i,
            a.whave = a.wsize) : (a.wnext += r,
            a.wnext === a.wsize && (a.wnext = 0),
            a.whave < a.wsize && (a.whave += r))),
            0
        }
        ;
        var zc = {
            inflateReset: Bc,
            inflateReset2: Dc,
            inflateResetKeep: Pc,
            inflateInit: e => Lc(e, 15),
            inflateInit2: Lc,
            inflate: (e, t) => {
                let n, i, r, a, s, o, l, c, h, d, u, f, p, m, g, A, _, v, w, y, x, b, S = 0;
                const E = new Uint8Array(4);
                let M, T;
                const C = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                if (Rc(e) || !e.output || !e.input && 0 !== e.avail_in)
                    return pc;
                n = e.state,
                n.mode === yc && (n.mode = xc),
                s = e.next_out,
                r = e.output,
                l = e.avail_out,
                a = e.next_in,
                i = e.input,
                o = e.avail_in,
                c = n.hold,
                h = n.bits,
                d = o,
                u = l,
                b = dc;
                e: for (; ; )
                    switch (n.mode) {
                    case vc:
                        if (0 === n.wrap) {
                            n.mode = xc;
                            break
                        }
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (2 & n.wrap && 35615 === c) {
                            0 === n.wbits && (n.wbits = 15),
                            n.check = 0,
                            E[0] = 255 & c,
                            E[1] = c >>> 8 & 255,
                            n.check = Bo(n.check, E, 2, 0),
                            c = 0,
                            h = 0,
                            n.mode = 16181;
                            break
                        }
                        if (n.head && (n.head.done = !1),
                        !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                            e.msg = "incorrect header check",
                            n.mode = Tc;
                            break
                        }
                        if ((15 & c) !== _c) {
                            e.msg = "unknown compression method",
                            n.mode = Tc;
                            break
                        }
                        if (c >>>= 4,
                        h -= 4,
                        x = 8 + (15 & c),
                        0 === n.wbits && (n.wbits = x),
                        x > 15 || x > n.wbits) {
                            e.msg = "invalid window size",
                            n.mode = Tc;
                            break
                        }
                        n.dmax = 1 << n.wbits,
                        n.flags = 0,
                        e.adler = n.check = 1,
                        n.mode = 512 & c ? 16189 : yc,
                        c = 0,
                        h = 0;
                        break;
                    case 16181:
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (n.flags = c,
                        (255 & n.flags) !== _c) {
                            e.msg = "unknown compression method",
                            n.mode = Tc;
                            break
                        }
                        if (57344 & n.flags) {
                            e.msg = "unknown header flags set",
                            n.mode = Tc;
                            break
                        }
                        n.head && (n.head.text = c >> 8 & 1),
                        512 & n.flags && 4 & n.wrap && (E[0] = 255 & c,
                        E[1] = c >>> 8 & 255,
                        n.check = Bo(n.check, E, 2, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16182;
                    case 16182:
                        for (; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        n.head && (n.head.time = c),
                        512 & n.flags && 4 & n.wrap && (E[0] = 255 & c,
                        E[1] = c >>> 8 & 255,
                        E[2] = c >>> 16 & 255,
                        E[3] = c >>> 24 & 255,
                        n.check = Bo(n.check, E, 4, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16183;
                    case 16183:
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        n.head && (n.head.xflags = 255 & c,
                        n.head.os = c >> 8),
                        512 & n.flags && 4 & n.wrap && (E[0] = 255 & c,
                        E[1] = c >>> 8 & 255,
                        n.check = Bo(n.check, E, 2, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16184;
                    case 16184:
                        if (1024 & n.flags) {
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.length = c,
                            n.head && (n.head.extra_len = c),
                            512 & n.flags && 4 & n.wrap && (E[0] = 255 & c,
                            E[1] = c >>> 8 & 255,
                            n.check = Bo(n.check, E, 2, 0)),
                            c = 0,
                            h = 0
                        } else
                            n.head && (n.head.extra = null);
                        n.mode = 16185;
                    case 16185:
                        if (1024 & n.flags && (f = n.length,
                        f > o && (f = o),
                        f && (n.head && (x = n.head.extra_len - n.length,
                        n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)),
                        n.head.extra.set(i.subarray(a, a + f), x)),
                        512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, f, a)),
                        o -= f,
                        a += f,
                        n.length -= f),
                        n.length))
                            break e;
                        n.length = 0,
                        n.mode = 16186;
                    case 16186:
                        if (2048 & n.flags) {
                            if (0 === o)
                                break e;
                            f = 0;
                            do {
                                x = i[a + f++],
                                n.head && x && n.length < 65536 && (n.head.name += String.fromCharCode(x))
                            } while (x && f < o);
                            if (512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, f, a)),
                            o -= f,
                            a += f,
                            x)
                                break e
                        } else
                            n.head && (n.head.name = null);
                        n.length = 0,
                        n.mode = 16187;
                    case 16187:
                        if (4096 & n.flags) {
                            if (0 === o)
                                break e;
                            f = 0;
                            do {
                                x = i[a + f++],
                                n.head && x && n.length < 65536 && (n.head.comment += String.fromCharCode(x))
                            } while (x && f < o);
                            if (512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, f, a)),
                            o -= f,
                            a += f,
                            x)
                                break e
                        } else
                            n.head && (n.head.comment = null);
                        n.mode = 16188;
                    case 16188:
                        if (512 & n.flags) {
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (4 & n.wrap && c !== (65535 & n.check)) {
                                e.msg = "header crc mismatch",
                                n.mode = Tc;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.head && (n.head.hcrc = n.flags >> 9 & 1,
                        n.head.done = !0),
                        e.adler = n.check = 0,
                        n.mode = yc;
                        break;
                    case 16189:
                        for (; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        e.adler = n.check = Cc(c),
                        c = 0,
                        h = 0,
                        n.mode = wc;
                    case wc:
                        if (0 === n.havedict)
                            return e.next_out = s,
                            e.avail_out = l,
                            e.next_in = a,
                            e.avail_in = o,
                            n.hold = c,
                            n.bits = h,
                            fc;
                        e.adler = n.check = 1,
                        n.mode = yc;
                    case yc:
                        if (t === cc || t === hc)
                            break e;
                    case xc:
                        if (n.last) {
                            c >>>= 7 & h,
                            h -= 7 & h,
                            n.mode = Mc;
                            break
                        }
                        for (; h < 3; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        switch (n.last = 1 & c,
                        c >>>= 1,
                        h -= 1,
                        3 & c) {
                        case 0:
                            n.mode = 16193;
                            break;
                        case 1:
                            if (Fc(n),
                            n.mode = Sc,
                            t === hc) {
                                c >>>= 2,
                                h -= 2;
                                break e
                            }
                            break;
                        case 2:
                            n.mode = 16196;
                            break;
                        case 3:
                            e.msg = "invalid block type",
                            n.mode = Tc
                        }
                        c >>>= 2,
                        h -= 2;
                        break;
                    case 16193:
                        for (c >>>= 7 & h,
                        h -= 7 & h; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if ((65535 & c) != (c >>> 16 ^ 65535)) {
                            e.msg = "invalid stored block lengths",
                            n.mode = Tc;
                            break
                        }
                        if (n.length = 65535 & c,
                        c = 0,
                        h = 0,
                        n.mode = bc,
                        t === hc)
                            break e;
                    case bc:
                        n.mode = 16195;
                    case 16195:
                        if (f = n.length,
                        f) {
                            if (f > o && (f = o),
                            f > l && (f = l),
                            0 === f)
                                break e;
                            r.set(i.subarray(a, a + f), s),
                            o -= f,
                            a += f,
                            l -= f,
                            s += f,
                            n.length -= f;
                            break
                        }
                        n.mode = yc;
                        break;
                    case 16196:
                        for (; h < 14; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (n.nlen = 257 + (31 & c),
                        c >>>= 5,
                        h -= 5,
                        n.ndist = 1 + (31 & c),
                        c >>>= 5,
                        h -= 5,
                        n.ncode = 4 + (15 & c),
                        c >>>= 4,
                        h -= 4,
                        n.nlen > 286 || n.ndist > 30) {
                            e.msg = "too many length or distance symbols",
                            n.mode = Tc;
                            break
                        }
                        n.have = 0,
                        n.mode = 16197;
                    case 16197:
                        for (; n.have < n.ncode; ) {
                            for (; h < 3; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.lens[C[n.have++]] = 7 & c,
                            c >>>= 3,
                            h -= 3
                        }
                        for (; n.have < 19; )
                            n.lens[C[n.have++]] = 0;
                        if (n.lencode = n.lendyn,
                        n.lenbits = 7,
                        M = {
                            bits: n.lenbits
                        },
                        b = oc(0, n.lens, 0, 19, n.lencode, 0, n.work, M),
                        n.lenbits = M.bits,
                        b) {
                            e.msg = "invalid code lengths set",
                            n.mode = Tc;
                            break
                        }
                        n.have = 0,
                        n.mode = 16198;
                    case 16198:
                        for (; n.have < n.nlen + n.ndist; ) {
                            for (; S = n.lencode[c & (1 << n.lenbits) - 1],
                            g = S >>> 24,
                            A = S >>> 16 & 255,
                            _ = 65535 & S,
                            !(g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (_ < 16)
                                c >>>= g,
                                h -= g,
                                n.lens[n.have++] = _;
                            else {
                                if (16 === _) {
                                    for (T = g + 2; h < T; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    if (c >>>= g,
                                    h -= g,
                                    0 === n.have) {
                                        e.msg = "invalid bit length repeat",
                                        n.mode = Tc;
                                        break
                                    }
                                    x = n.lens[n.have - 1],
                                    f = 3 + (3 & c),
                                    c >>>= 2,
                                    h -= 2
                                } else if (17 === _) {
                                    for (T = g + 3; h < T; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    c >>>= g,
                                    h -= g,
                                    x = 0,
                                    f = 3 + (7 & c),
                                    c >>>= 3,
                                    h -= 3
                                } else {
                                    for (T = g + 7; h < T; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    c >>>= g,
                                    h -= g,
                                    x = 0,
                                    f = 11 + (127 & c),
                                    c >>>= 7,
                                    h -= 7
                                }
                                if (n.have + f > n.nlen + n.ndist) {
                                    e.msg = "invalid bit length repeat",
                                    n.mode = Tc;
                                    break
                                }
                                for (; f--; )
                                    n.lens[n.have++] = x
                            }
                        }
                        if (n.mode === Tc)
                            break;
                        if (0 === n.lens[256]) {
                            e.msg = "invalid code -- missing end-of-block",
                            n.mode = Tc;
                            break
                        }
                        if (n.lenbits = 9,
                        M = {
                            bits: n.lenbits
                        },
                        b = oc(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, M),
                        n.lenbits = M.bits,
                        b) {
                            e.msg = "invalid literal/lengths set",
                            n.mode = Tc;
                            break
                        }
                        if (n.distbits = 6,
                        n.distcode = n.distdyn,
                        M = {
                            bits: n.distbits
                        },
                        b = oc(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, M),
                        n.distbits = M.bits,
                        b) {
                            e.msg = "invalid distances set",
                            n.mode = Tc;
                            break
                        }
                        if (n.mode = Sc,
                        t === hc)
                            break e;
                    case Sc:
                        n.mode = Ec;
                    case Ec:
                        if (o >= 6 && l >= 258) {
                            e.next_out = s,
                            e.avail_out = l,
                            e.next_in = a,
                            e.avail_in = o,
                            n.hold = c,
                            n.bits = h,
                            tc(e, u),
                            s = e.next_out,
                            r = e.output,
                            l = e.avail_out,
                            a = e.next_in,
                            i = e.input,
                            o = e.avail_in,
                            c = n.hold,
                            h = n.bits,
                            n.mode === yc && (n.back = -1);
                            break
                        }
                        for (n.back = 0; S = n.lencode[c & (1 << n.lenbits) - 1],
                        g = S >>> 24,
                        A = S >>> 16 & 255,
                        _ = 65535 & S,
                        !(g <= h); ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (A && !(240 & A)) {
                            for (v = g,
                            w = A,
                            y = _; S = n.lencode[y + ((c & (1 << v + w) - 1) >> v)],
                            g = S >>> 24,
                            A = S >>> 16 & 255,
                            _ = 65535 & S,
                            !(v + g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            c >>>= v,
                            h -= v,
                            n.back += v
                        }
                        if (c >>>= g,
                        h -= g,
                        n.back += g,
                        n.length = _,
                        0 === A) {
                            n.mode = 16205;
                            break
                        }
                        if (32 & A) {
                            n.back = -1,
                            n.mode = yc;
                            break
                        }
                        if (64 & A) {
                            e.msg = "invalid literal/length code",
                            n.mode = Tc;
                            break
                        }
                        n.extra = 15 & A,
                        n.mode = 16201;
                    case 16201:
                        if (n.extra) {
                            for (T = n.extra; h < T; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.length += c & (1 << n.extra) - 1,
                            c >>>= n.extra,
                            h -= n.extra,
                            n.back += n.extra
                        }
                        n.was = n.length,
                        n.mode = 16202;
                    case 16202:
                        for (; S = n.distcode[c & (1 << n.distbits) - 1],
                        g = S >>> 24,
                        A = S >>> 16 & 255,
                        _ = 65535 & S,
                        !(g <= h); ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (!(240 & A)) {
                            for (v = g,
                            w = A,
                            y = _; S = n.distcode[y + ((c & (1 << v + w) - 1) >> v)],
                            g = S >>> 24,
                            A = S >>> 16 & 255,
                            _ = 65535 & S,
                            !(v + g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            c >>>= v,
                            h -= v,
                            n.back += v
                        }
                        if (c >>>= g,
                        h -= g,
                        n.back += g,
                        64 & A) {
                            e.msg = "invalid distance code",
                            n.mode = Tc;
                            break
                        }
                        n.offset = _,
                        n.extra = 15 & A,
                        n.mode = 16203;
                    case 16203:
                        if (n.extra) {
                            for (T = n.extra; h < T; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.offset += c & (1 << n.extra) - 1,
                            c >>>= n.extra,
                            h -= n.extra,
                            n.back += n.extra
                        }
                        if (n.offset > n.dmax) {
                            e.msg = "invalid distance too far back",
                            n.mode = Tc;
                            break
                        }
                        n.mode = 16204;
                    case 16204:
                        if (0 === l)
                            break e;
                        if (f = u - l,
                        n.offset > f) {
                            if (f = n.offset - f,
                            f > n.whave && n.sane) {
                                e.msg = "invalid distance too far back",
                                n.mode = Tc;
                                break
                            }
                            f > n.wnext ? (f -= n.wnext,
                            p = n.wsize - f) : p = n.wnext - f,
                            f > n.length && (f = n.length),
                            m = n.window
                        } else
                            m = r,
                            p = s - n.offset,
                            f = n.length;
                        f > l && (f = l),
                        l -= f,
                        n.length -= f;
                        do {
                            r[s++] = m[p++]
                        } while (--f);
                        0 === n.length && (n.mode = Ec);
                        break;
                    case 16205:
                        if (0 === l)
                            break e;
                        r[s++] = n.length,
                        l--,
                        n.mode = Ec;
                        break;
                    case Mc:
                        if (n.wrap) {
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c |= i[a++] << h,
                                h += 8
                            }
                            if (u -= l,
                            e.total_out += u,
                            n.total += u,
                            4 & n.wrap && u && (e.adler = n.check = n.flags ? Bo(n.check, r, u, s - u) : Ro(n.check, r, u, s - u)),
                            u = l,
                            4 & n.wrap && (n.flags ? c : Cc(c)) !== n.check) {
                                e.msg = "incorrect data check",
                                n.mode = Tc;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.mode = 16207;
                    case 16207:
                        if (n.wrap && n.flags) {
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (4 & n.wrap && c !== (4294967295 & n.total)) {
                                e.msg = "incorrect length check",
                                n.mode = Tc;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.mode = 16208;
                    case 16208:
                        b = uc;
                        break e;
                    case Tc:
                        b = mc;
                        break e;
                    case 16210:
                        return gc;
                    default:
                        return pc
                    }
                return e.next_out = s,
                e.avail_out = l,
                e.next_in = a,
                e.avail_in = o,
                n.hold = c,
                n.bits = h,
                (n.wsize || u !== e.avail_out && n.mode < Tc && (n.mode < Mc || t !== lc)) && Oc(e, e.output, e.next_out, u - e.avail_out),
                d -= e.avail_in,
                u -= e.avail_out,
                e.total_in += d,
                e.total_out += u,
                n.total += u,
                4 & n.wrap && u && (e.adler = n.check = n.flags ? Bo(n.check, r, u, e.next_out - u) : Ro(n.check, r, u, e.next_out - u)),
                e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === yc ? 128 : 0) + (n.mode === Sc || n.mode === bc ? 256 : 0),
                (0 === d && 0 === u || t === lc) && b === dc && (b = Ac),
                b
            }
            ,
            inflateEnd: e => {
                if (Rc(e))
                    return pc;
                let t = e.state;
                return t.window && (t.window = null),
                e.state = null,
                dc
            }
            ,
            inflateGetHeader: (e, t) => {
                if (Rc(e))
                    return pc;
                const n = e.state;
                return 2 & n.wrap ? (n.head = t,
                t.done = !1,
                dc) : pc
            }
            ,
            inflateSetDictionary: (e, t) => {
                const n = t.length;
                let i, r, a;
                return Rc(e) ? pc : (i = e.state,
                0 !== i.wrap && i.mode !== wc ? pc : i.mode === wc && (r = 1,
                r = Ro(r, t, n, 0),
                r !== i.check) ? mc : (a = Oc(e, t, n, n),
                a ? (i.mode = 16210,
                gc) : (i.havedict = 1,
                dc)))
            }
            ,
            inflateInfo: "pako inflate (from Nodeca project)"
        };
        var Hc = function() {
            this.text = 0,
            this.time = 0,
            this.xflags = 0,
            this.os = 0,
            this.extra = null,
            this.extra_len = 0,
            this.name = "",
            this.comment = "",
            this.hcrc = 0,
            this.done = !1
        };
        const Wc = Object.prototype.toString
          , {Z_NO_FLUSH: Vc, Z_FINISH: Gc, Z_OK: Qc, Z_STREAM_END: Xc, Z_NEED_DICT: jc, Z_STREAM_ERROR: qc, Z_DATA_ERROR: Yc, Z_MEM_ERROR: Kc} = Lo;
        function Zc(e) {
            this.options = Dl({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
            }, e || {});
            const t = this.options;
            t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits,
            0 === t.windowBits && (t.windowBits = -15)),
            !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32),
            t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits || (t.windowBits |= 15)),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new zl,
            this.strm.avail_out = 0;
            let n = zc.inflateInit2(this.strm, t.windowBits);
            if (n !== Qc)
                throw new Error(Do[n]);
            if (this.header = new Hc,
            zc.inflateGetHeader(this.strm, this.header),
            t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = kl(t.dictionary) : "[object ArrayBuffer]" === Wc.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)),
            t.raw && (n = zc.inflateSetDictionary(this.strm, t.dictionary),
            n !== Qc)))
                throw new Error(Do[n])
        }
        function Jc(e, t) {
            const n = new Zc(t);
            if (n.push(e),
            n.err)
                throw n.msg || Do[n.err];
            return n.result
        }
        Zc.prototype.push = function(e, t) {
            const n = this.strm
              , i = this.options.chunkSize
              , r = this.options.dictionary;
            let a, s, o;
            if (this.ended)
                return !1;
            for (s = t === ~~t ? t : !0 === t ? Gc : Vc,
            "[object ArrayBuffer]" === Wc.call(e) ? n.input = new Uint8Array(e) : n.input = e,
            n.next_in = 0,
            n.avail_in = n.input.length; ; ) {
                for (0 === n.avail_out && (n.output = new Uint8Array(i),
                n.next_out = 0,
                n.avail_out = i),
                a = zc.inflate(n, s),
                a === jc && r && (a = zc.inflateSetDictionary(n, r),
                a === Qc ? a = zc.inflate(n, s) : a === Yc && (a = jc)); n.avail_in > 0 && a === Xc && n.state.wrap > 0 && 0 !== e[n.next_in]; )
                    zc.inflateReset(n),
                    a = zc.inflate(n, s);
                switch (a) {
                case qc:
                case Yc:
                case jc:
                case Kc:
                    return this.onEnd(a),
                    this.ended = !0,
                    !1
                }
                if (o = n.avail_out,
                n.next_out && (0 === n.avail_out || a === Xc))
                    if ("string" === this.options.to) {
                        let e = Ol(n.output, n.next_out)
                          , t = n.next_out - e
                          , r = Fl(n.output, e);
                        n.next_out = t,
                        n.avail_out = i - t,
                        t && n.output.set(n.output.subarray(e, e + t), 0),
                        this.onData(r)
                    } else
                        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                if (a !== Qc || 0 !== o) {
                    if (a === Xc)
                        return a = zc.inflateEnd(this.strm),
                        this.onEnd(a),
                        this.ended = !0,
                        !0;
                    if (0 === n.avail_in)
                        break
                }
            }
            return !0
        }
        ,
        Zc.prototype.onData = function(e) {
            this.chunks.push(e)
        }
        ,
        Zc.prototype.onEnd = function(e) {
            e === Qc && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Ll(this.chunks)),
            this.chunks = [],
            this.err = e,
            this.msg = this.strm.msg
        }
        ;
        var $c = {
            Inflate: Zc,
            inflate: Jc,
            inflateRaw: function(e, t) {
                return (t = t || {}).raw = !0,
                Jc(e, t)
            },
            ungzip: Jc,
            constants: Lo
        };
        const {Deflate: eh, deflate: th, deflateRaw: nh, gzip: ih} = $l
          , {Inflate: rh, inflate: ah, inflateRaw: sh, ungzip: oh} = $c;
        var lh = {
            Deflate: eh,
            deflate: th,
            deflateRaw: nh,
            gzip: ih,
            Inflate: rh,
            inflate: ah,
            inflateRaw: sh,
            ungzip: oh,
            constants: Lo
        };
        function ch(e) {
            let t;
            e = (e = e.replace(/-/g, "+")).replace(/_/g, "/");
            try {
                t = atob(e)
            } catch (e) {
                return null
            }
            const n = new Uint8Array(t.length);
            for (let e = 0; e < t.length; ++e) {
                const i = t.charCodeAt(e);
                if (i > 255)
                    return null;
                n[e] = i
            }
            return n
        }
        var hh, dh, uh, fh, ph, mh, gh, Ah, _h, vh, wh, yh = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, xh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class bh {
            constructor(e) {
                hh.add(this),
                uh.set(this, []),
                fh.set(this, []),
                ph.set(this, []),
                mh.set(this, []),
                gh.set(this, []),
                Ah.set(this, null),
                null != e && (yh(this, uh, e.up, "f"),
                yh(this, fh, e.right, "f"),
                yh(this, ph, e.down, "f"),
                yh(this, mh, e.left, "f"),
                yh(this, gh, e.reset, "f"))
            }
            recordFrame(e, t) {
                if (e > dh.maxFrames)
                    throw new Error("Frame number exceeds maximum frame count.");
                if (null != xh(this, Ah, "f") && e <= xh(this, Ah, "f"))
                    throw new Error("Frame number must be greater than the previous recorded frame.");
                yh(this, Ah, e, "f");
                const n = xh(this, uh, "f").length % 2 != 0
                  , i = xh(this, fh, "f").length % 2 != 0
                  , r = xh(this, ph, "f").length % 2 != 0
                  , a = xh(this, mh, "f").length % 2 != 0
                  , s = xh(this, gh, "f").length % 2 != 0;
                t.up != n && xh(this, uh, "f").push(e),
                t.right != i && xh(this, fh, "f").push(e),
                t.down != r && xh(this, ph, "f").push(e),
                t.left != a && xh(this, mh, "f").push(e),
                t.reset != s && xh(this, gh, "f").push(e)
            }
            getFrame(e) {
                return {
                    up: (xh(this, hh, "m", _h).call(this, e, xh(this, uh, "f")) + 1) % 2 != 0,
                    right: (xh(this, hh, "m", _h).call(this, e, xh(this, fh, "f")) + 1) % 2 != 0,
                    down: (xh(this, hh, "m", _h).call(this, e, xh(this, ph, "f")) + 1) % 2 != 0,
                    left: (xh(this, hh, "m", _h).call(this, e, xh(this, mh, "f")) + 1) % 2 != 0,
                    reset: (xh(this, hh, "m", _h).call(this, e, xh(this, gh, "f")) + 1) % 2 != 0
                }
            }
            serialize() {
                const e = new Uint8Array(3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length + 3 + 3 * xh(this, mh, "f").length + 3 + 3 * xh(this, gh, "f").length);
                xh(this, hh, "m", vh).call(this, xh(this, uh, "f"), e.subarray(0, 3 + 3 * xh(this, uh, "f").length)),
                xh(this, hh, "m", vh).call(this, xh(this, fh, "f"), e.subarray(3 + 3 * xh(this, uh, "f").length, 3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length)),
                xh(this, hh, "m", vh).call(this, xh(this, ph, "f"), e.subarray(3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length, 3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length)),
                xh(this, hh, "m", vh).call(this, xh(this, mh, "f"), e.subarray(3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length, 3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length + 3 + 3 * xh(this, mh, "f").length)),
                xh(this, hh, "m", vh).call(this, xh(this, gh, "f"), e.subarray(3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length + 3 + 3 * xh(this, mh, "f").length, 3 + 3 * xh(this, uh, "f").length + 3 + 3 * xh(this, fh, "f").length + 3 + 3 * xh(this, ph, "f").length + 3 + 3 * xh(this, mh, "f").length + 3 + 3 * xh(this, gh, "f").length));
                const t = new lh.Deflate({
                    level: 9
                });
                return t.push(new Uint8Array(e), !0),
                function(e) {
                    let t = "";
                    for (const n of e)
                        t += String.fromCharCode(n);
                    let n = btoa(t);
                    return n = n.replace(/\+/g, "-"),
                    n = n.replace(/\//g, "_"),
                    n = n.replace(/=/g, ""),
                    n
                }(t.result)
            }
            static deserialize(e) {
                const t = ch(e);
                if (null == t)
                    return null;
                const n = new lh.Inflate;
                if (n.push(t, !0),
                n.err)
                    return null;
                const i = n.result;
                if (!(i instanceof Uint8Array))
                    return null;
                const r = xh(dh, dh, "m", wh).call(dh, i);
                if (null == r)
                    return null;
                const a = xh(dh, dh, "m", wh).call(dh, i.subarray(3 + 3 * r.length));
                if (null == a)
                    return null;
                const s = xh(dh, dh, "m", wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * a.length));
                if (null == s)
                    return null;
                const o = xh(dh, dh, "m", wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * a.length + 3 + 3 * s.length));
                if (null == o)
                    return null;
                const l = xh(dh, dh, "m", wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * a.length + 3 + 3 * s.length + 3 + 3 * o.length));
                return null == l ? null : new dh({
                    up: r,
                    right: a,
                    down: s,
                    left: o,
                    reset: l
                })
            }
        }
        dh = bh,
        uh = new WeakMap,
        fh = new WeakMap,
        ph = new WeakMap,
        mh = new WeakMap,
        gh = new WeakMap,
        Ah = new WeakMap,
        hh = new WeakSet,
        _h = function(e, t) {
            let n = -1;
            for (let i = 0; i < t.length; ++i) {
                const r = t[i];
                if (r == e) {
                    n = i;
                    break
                }
                if (r > e)
                    break;
                n = i
            }
            return n
        }
        ,
        vh = function(e, t) {
            t[0] = 255 & e.length,
            t[1] = e.length >>> 8 & 255,
            t[2] = e.length >>> 16 & 255;
            for (let n = 0; n < e.length; ++n) {
                let i;
                i = 0 == n ? e[n] : e[n] - e[n - 1],
                t[3 + 3 * n] = 255 & i,
                t[3 + 3 * n + 1] = i >>> 8 & 255,
                t[3 + 3 * n + 2] = i >>> 16 & 255
            }
        }
        ,
        wh = function(e) {
            if (e.length < 3)
                return null;
            const t = e[0] | e[1] << 8 | e[2] << 16;
            if (e.length < 3 + 3 * t)
                return null;
            const n = [];
            for (let i = 0; i < t; ++i) {
                const t = e[3 + 3 * i] | e[3 + 3 * i + 1] << 8 | e[3 + 3 * i + 2] << 16;
                0 == i ? n.push(t) : n.push(n[i - 1] + t)
            }
            return n
        }
        ,
        bh.maxFrames = 5999999;
        const Sh = bh;
        var Eh, Mh, Th, Ch, Ih, Rh, Ph, Bh, Dh, Lh, Uh, Nh, kh, Fh = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Oh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class zh {
            constructor() {
                Mh.set(this, void 0),
                Th.set(this, void 0),
                Ch.set(this, void 0),
                Ih.set(this, void 0),
                Rh.set(this, void 0),
                Ph.set(this, []),
                Bh.set(this, new Map),
                Lh.set(this, []),
                Uh.set(this, new Map),
                Nh.set(this, null),
                kh.set(this, null),
                Fh(this, Mh, new Ammo.btDefaultCollisionConfiguration, "f"),
                Fh(this, Th, new Ammo.btCollisionDispatcher(Oh(this, Mh, "f")), "f"),
                Fh(this, Ch, new Ammo.btDbvtBroadphase, "f"),
                Fh(this, Ih, new Ammo.btSequentialImpulseConstraintSolver, "f"),
                Fh(this, Rh, new Ammo.btDiscreteDynamicsWorld(Oh(this, Th, "f"),Oh(this, Ch, "f"),Oh(this, Ih, "f"),Oh(this, Mh, "f")), "f");
                const e = new Ammo.btVector3(0,-9.82,0);
                Oh(this, Rh, "f").setGravity(e),
                Ammo.destroy(e)
            }
            dispose() {
                for (const {body: e} of Oh(this, Lh, "f"))
                    null != e && Oh(this, Rh, "f").removeRigidBody(e);
                Oh(this, Lh, "f").length = 0;
                for (const {body: e} of Oh(this, Ph, "f"))
                    null != e && (Ammo.destroy(e.getMotionState()),
                    Ammo.destroy(e));
                Oh(this, Ph, "f").length = 0,
                Oh(this, Bh, "f").clear();
                for (const e of Oh(this, Uh, "f").values())
                    for (const t of e)
                        Ammo.destroy(t.getMotionState()),
                        Ammo.destroy(t);
                Oh(this, Uh, "f").clear(),
                null != Oh(this, Nh, "f") && (Oh(this, Nh, "f").isActive && Oh(this, Rh, "f").removeRigidBody(Oh(this, Nh, "f").body),
                Ammo.destroy(Oh(this, Nh, "f").body.getMotionState()),
                Ammo.destroy(Oh(this, Nh, "f").body),
                Ammo.destroy(Oh(this, Nh, "f").shape)),
                null != Oh(this, kh, "f") && (Oh(this, kh, "f").isActive && Oh(this, Rh, "f").removeRigidBody(Oh(this, kh, "f").body),
                Ammo.destroy(Oh(this, kh, "f").body.getMotionState()),
                Ammo.destroy(Oh(this, kh, "f").body),
                Ammo.destroy(Oh(this, kh, "f").shape),
                Ammo.destroy(Oh(this, kh, "f").triangleMesh)),
                Ammo.destroy(Oh(this, Rh, "f")),
                Ammo.destroy(Oh(this, Ih, "f")),
                Ammo.destroy(Oh(this, Ch, "f")),
                Ammo.destroy(Oh(this, Th, "f")),
                Ammo.destroy(Oh(this, Mh, "f"))
            }
            createGroundPlane() {
                if (null != Oh(this, Nh, "f"))
                    throw new Error("Ground is already initialized");
                const e = new Ammo.btVector3(0,1,0)
                  , t = new Ammo.btStaticPlaneShape(e,0);
                t.setMargin(.01),
                Ammo.destroy(e);
                const n = new Ammo.btTransform;
                n.setIdentity();
                const i = new Ammo.btDefaultMotionState(n);
                Ammo.destroy(n);
                const r = new Ammo.btVector3;
                t.calculateLocalInertia(0, r);
                const a = new Ammo.btRigidBodyConstructionInfo(0,i,t,r)
                  , s = new Ammo.btRigidBody(a);
                s.setFriction(1),
                Ammo.destroy(r),
                Ammo.destroy(a),
                Fh(this, Nh, {
                    body: s,
                    shape: t,
                    isActive: !1
                }, "f")
            }
            createMountains(e, t) {
                if (e.length % 9 != 0)
                    throw new Error("Number of mountain vertices is not dividable by 9");
                if (e.length > 0) {
                    if (null != Oh(this, kh, "f"))
                        throw new Error("Mountains are already initialized");
                    let n = 1 / 0;
                    const i = new Ammo.btTriangleMesh;
                    for (let t = 0; t < e.length; t += 9) {
                        const r = e[t + 0]
                          , a = e[t + 1]
                          , s = e[t + 2]
                          , o = e[t + 3]
                          , l = e[t + 4]
                          , c = e[t + 5]
                          , h = e[t + 6]
                          , d = e[t + 7]
                          , u = e[t + 8]
                          , f = new Ammo.btVector3(r,a,s)
                          , p = new Ammo.btVector3(o,l,c)
                          , m = new Ammo.btVector3(h,d,u);
                        i.addTriangle(f, p, m),
                        Ammo.destroy(f),
                        Ammo.destroy(p),
                        Ammo.destroy(m),
                        n = Math.min(n, new Zt(r,a,s).lengthSq(), new Zt(o,l,c).lengthSq(), new Zt(h,d,u).lengthSq())
                    }
                    const r = new Ammo.btBvhTriangleMeshShape(i);
                    r.setMargin(.02);
                    const a = new Ammo.btVector3(t.x,t.y,t.z)
                      , s = new Ammo.btTransform;
                    s.setIdentity(),
                    s.setOrigin(a),
                    Ammo.destroy(a);
                    const o = new Ammo.btVector3;
                    r.calculateLocalInertia(0, o);
                    const l = new Ammo.btDefaultMotionState(s);
                    Ammo.destroy(s);
                    const c = new Ammo.btRigidBodyConstructionInfo(0,l,r,o)
                      , h = new Ammo.btRigidBody(c);
                    h.setFriction(1),
                    Ammo.destroy(o),
                    Ammo.destroy(c);
                    const d = Math.sqrt(n);
                    Fh(this, kh, {
                        body: h,
                        shape: r,
                        triangleMesh: i,
                        offset: t,
                        minimumRadius: d,
                        isActive: !1
                    }, "f")
                }
            }
            addStaticBody(e, t, n) {
                const i = Oh(Eh, Eh, "f", Dh);
                (t = t.clone()).applyMatrix4(e);
                const r = {
                    active: !1,
                    matrix: e,
                    shape: n,
                    body: null,
                    min: t.min.clone(),
                    max: t.max.clone()
                };
                Oh(this, Ph, "f").push(r);
                for (let e = Math.floor((t.min.x - 3) / i); e <= Math.ceil((t.max.x + 3) / i); ++e)
                    for (let n = Math.floor((t.min.y - 3) / i); n <= Math.ceil((t.max.y + 3) / i); ++n)
                        for (let a = Math.floor((t.min.z - 3) / i); a <= Math.ceil((t.max.z + 3) / i); ++a) {
                            const t = Oh(this, Bh, "f").get(e);
                            if (null == t)
                                Oh(this, Bh, "f").set(e, new Map([[n, new Map([[a, [r]]])]]));
                            else {
                                const e = t.get(n);
                                if (null == e)
                                    t.set(n, new Map([[a, [r]]]));
                                else {
                                    const t = e.get(a);
                                    null == t ? e.set(a, [r]) : t.push(r)
                                }
                            }
                        }
            }
            activePhysicsAt(e) {
                if (null != Oh(this, Nh, "f") && (e.y < 4 ? Oh(this, Nh, "f").isActive || (Oh(this, Rh, "f").addRigidBody(Oh(this, Nh, "f").body),
                Oh(this, Nh, "f").isActive = !0) : e.y > 5 && Oh(this, Nh, "f").isActive && (Oh(this, Rh, "f").removeRigidBody(Oh(this, Nh, "f").body),
                Oh(this, Nh, "f").isActive = !1)),
                null != Oh(this, kh, "f")) {
                    const t = e.distanceTo(Oh(this, kh, "f").offset);
                    t > Oh(this, kh, "f").minimumRadius - 10 ? Oh(this, kh, "f").isActive || (Oh(this, Rh, "f").addRigidBody(Oh(this, kh, "f").body),
                    Oh(this, kh, "f").isActive = !0) : t < Oh(this, kh, "f").minimumRadius - 20 && Oh(this, kh, "f").isActive && (Oh(this, Rh, "f").removeRigidBody(Oh(this, kh, "f").body),
                    Oh(this, kh, "f").isActive = !1)
                }
                const t = new Ammo.btVector3
                  , n = new Ammo.btVector3;
                Fh(this, Lh, Oh(this, Lh, "f").filter((t => {
                    if (t.active && (e.x < t.min.x - 3 || e.x > t.max.x + 3 || e.y < t.min.y - 3 || e.y > t.max.y + 3 || e.z < t.min.z - 3 || e.z > t.max.z + 3)) {
                        const e = Oh(this, Uh, "f").get(t.shape);
                        return null == e ? Oh(this, Uh, "f").set(t.shape, [t.body]) : e.push(t.body),
                        Oh(this, Rh, "f").removeRigidBody(t.body),
                        t.body = null,
                        t.active = !1,
                        !1
                    }
                    return !0
                }
                )), "f");
                const i = e.clone().divideScalar(Oh(Eh, Eh, "f", Dh)).floor()
                  , r = Oh(this, Bh, "f").get(i.x);
                if (null != r) {
                    const t = r.get(i.y);
                    if (null != t) {
                        const n = t.get(i.z);
                        if (null != n)
                            for (const t of n)
                                if (!t.active && e.x >= t.min.x - 3 && e.x <= t.max.x + 3 && e.y >= t.min.y - 3 && e.y <= t.max.y + 3 && e.z >= t.min.z - 3 && e.z <= t.max.z + 3) {
                                    let e = Oh(this, Uh, "f").get(t.shape);
                                    null == e && (e = [],
                                    Oh(this, Uh, "f").set(t.shape, e));
                                    const n = new Ammo.btTransform;
                                    let i;
                                    if (n.setFromOpenGLMatrix(t.matrix.elements),
                                    e.length > 0)
                                        i = e.pop(),
                                        i.setWorldTransform(n),
                                        Ammo.destroy(n),
                                        Oh(this, Rh, "f").addRigidBody(i);
                                    else {
                                        const e = new Ammo.btDefaultMotionState(n);
                                        Ammo.destroy(n);
                                        const r = new Ammo.btVector3;
                                        t.shape.calculateLocalInertia(0, r);
                                        const a = new Ammo.btRigidBodyConstructionInfo(0,e,t.shape,r);
                                        i = new Ammo.btRigidBody(a),
                                        i.setFriction(1),
                                        Ammo.destroy(r),
                                        Ammo.destroy(a),
                                        Oh(this, Rh, "f").addRigidBody(i)
                                    }
                                    if (null != t.body)
                                        throw new Error("Activating already active rigid body");
                                    t.body = i,
                                    t.active = !0,
                                    Oh(this, Lh, "f").push(t)
                                }
                    }
                }
                Ammo.destroy(t),
                Ammo.destroy(n)
            }
            step() {
                Oh(this, Rh, "f").stepSimulation(1 / Eh.stepsPerSecond, 0, 1 / Eh.stepsPerSecond)
            }
            get world() {
                return Oh(this, Rh, "f")
            }
            get dispatcher() {
                return Oh(this, Th, "f")
            }
        }
        Eh = zh,
        Mh = new WeakMap,
        Th = new WeakMap,
        Ch = new WeakMap,
        Ih = new WeakMap,
        Rh = new WeakMap,
        Ph = new WeakMap,
        Bh = new WeakMap,
        Lh = new WeakMap,
        Uh = new WeakMap,
        Nh = new WeakMap,
        kh = new WeakMap,
        Dh = {
            value: 20
        },
        zh.stepsPerSecond = 1e3;
        const Hh = zh;
        var Wh, Vh = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Gh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Qh {
            constructor(e) {
                if (Wh.set(this, 0),
                null != e) {
                    if (!Number.isSafeInteger(e))
                        throw new Error("Frames is not a safe integer");
                    Vh(this, Wh, e, "f")
                }
            }
            get numberOfFrames() {
                return Gh(this, Wh, "f")
            }
            get time() {
                return Gh(this, Wh, "f") / 1e3
            }
            increment() {
                var e;
                Vh(this, Wh, (e = Gh(this, Wh, "f"),
                ++e), "f")
            }
            difference(e) {
                return new Qh(Gh(this, Wh, "f") - Gh(e, Wh, "f"))
            }
            lessThan(e) {
                return Gh(this, Wh, "f") < Gh(e, Wh, "f")
            }
            greaterThan(e) {
                return Gh(this, Wh, "f") > Gh(e, Wh, "f")
            }
            lessOrEqual(e) {
                return Gh(this, Wh, "f") <= Gh(e, Wh, "f")
            }
            greaterOrEqual(e) {
                return Gh(this, Wh, "f") >= Gh(e, Wh, "f")
            }
            equals(e) {
                return Gh(this, Wh, "f") == Gh(e, Wh, "f")
            }
            isNegative() {
                return Gh(this, Wh, "f") < 0
            }
            clone() {
                const e = new Qh;
                return Vh(e, Wh, Gh(this, Wh, "f"), "f"),
                e
            }
        }
        Wh = new WeakMap;
        const Xh = Qh;
        var jh;
        !function(e) {
            e[e.Checkpoint = 0] = "Checkpoint",
            e[e.Finish = 1] = "Finish"
        }(jh || (jh = {}));
        const qh = jh
          , Yh = [[new Kt(0,0,0,1), new Kt(0,.7071067811865475,0,.7071067811865476), new Kt(0,1,0,0), new Kt(0,.7071067811865476,0,-.7071067811865475)], [new Kt(0,0,1,0), new Kt(.7071067811865475,0,.7071067811865476,0), new Kt(1,0,0,0), new Kt(.7071067811865476,0,-.7071067811865475,0)], [new Kt(0,0,-.7071067811865477,.7071067811865475), new Kt(.5,.5,-.5,.5), new Kt(.7071067811865475,.7071067811865477,0,0), new Kt(.5,.5,.5,-.5)], [new Kt(0,0,.7071067811865475,.7071067811865476), new Kt(.5,-.5,.5,.5), new Kt(.7071067811865476,-.7071067811865475,0,0), new Kt(.5,-.5,-.5,-.5)], [new Kt(.7071067811865475,0,0,.7071067811865476), new Kt(.5,.5,.5,.5), new Kt(0,.7071067811865476,.7071067811865475,0), new Kt(-.5,.5,.5,-.5)], [new Kt(-.7071067811865477,0,0,.7071067811865475), new Kt(-.5,-.5,.5,.5), new Kt(0,-.7071067811865475,.7071067811865477,0), new Kt(.5,-.5,.5,-.5)]];
        function Kh(e, t) {
            return Yh[t][e].clone()
        }
        var Zh, Jh, $h, ed, td, nd, id, rd, ad, sd = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, od = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class ld {
            constructor(e, t, n) {
                Zh.add(this),
                $h.set(this, void 0),
                ed.set(this, new Map),
                td.set(this, []),
                nd.set(this, []),
                id.set(this, []),
                sd(this, $h, t, "f"),
                n.forEachPart(( (n, i, r, a, s, o, l, c) => {
                    od(this, Zh, "m", rd).call(this, n, i, r, s, o, a, e, t);
                    const h = od(this, ed, "f").get(a);
                    null == h ? od(this, ed, "f").set(a, [{
                        x: n,
                        y: i,
                        z: r,
                        rotation: s,
                        rotationAxis: o,
                        type: a,
                        checkpointOrder: c
                    }]) : h.push({
                        x: n,
                        y: i,
                        z: r,
                        rotation: s,
                        rotationAxis: o,
                        type: a,
                        checkpointOrder: c
                    })
                }
                ));
                const i = od(this, $h, "f").getPartTypesWithDetector(qh.Finish);
                for (const e of i) {
                    const t = od(this, $h, "f").getDetector(e);
                    if (null == t)
                        throw new Error("Part detector is missing");
                    const n = od(this, ed, "f").get(e);
                    null != n && sd(this, td, od(this, td, "f").concat(n.map(( ({x: e, y: n, z: i, rotation: r, rotationAxis: a, type: s, checkpointOrder: o}) => ({
                        x: e,
                        y: n,
                        z: i,
                        rotation: r,
                        rotationAxis: a,
                        type: s,
                        checkpointOrder: o,
                        detector: t
                    })))), "f")
                }
                const r = od(this, $h, "f").getPartTypesWithDetector(qh.Checkpoint);
                for (const e of r) {
                    const t = od(this, $h, "f").getDetector(e);
                    if (null == t)
                        throw new Error("Part detector is missing");
                    const n = od(this, ed, "f").get(e);
                    null != n && sd(this, nd, od(this, nd, "f").concat(n.map(( ({x: e, y: n, z: i, rotation: r, rotationAxis: a, type: s, checkpointOrder: o}) => {
                        if (null == o)
                            throw new Error("Checkpoint has no checkpoint order");
                        return {
                            x: e,
                            y: n,
                            z: i,
                            rotation: r,
                            rotationAxis: a,
                            type: s,
                            checkpointOrder: o,
                            detector: t
                        }
                    }
                    ))), "f")
                }
                sd(this, id, od(this, nd, "f").map((e => e.checkpointOrder)).filter(( (e, t, n) => n.indexOf(e) == t)).sort(( (e, t) => e - t)), "f")
            }
            checkCheckpoint(e, t) {
                return od(this, Zh, "m", ad).call(this, e, t)
            }
            checkFinish(e) {
                return od(this, Zh, "m", ad).call(this, e)
            }
            getTotalNumberOfCheckpointIndices() {
                return od(this, id, "f").length
            }
        }
        Jh = ld,
        $h = new WeakMap,
        ed = new WeakMap,
        td = new WeakMap,
        nd = new WeakMap,
        id = new WeakMap,
        Zh = new WeakSet,
        rd = function(e, t, n, i, r, a, s, o) {
            const l = Kh(i, r)
              , c = new Zt(e * Jh.partSize,t * Jh.partSize,n * Jh.partSize)
              , h = (new Cn).compose(c, l, new Zt(1,1,1))
              , {boundingBox: d, shape: u} = o.getPhysicsShape(a);
            s.addStaticBody(h, d, u)
        }
        ,
        ad = function(e, t) {
            let n = []
              , i = null;
            null == t ? n = od(this, td, "f") : (n = od(this, nd, "f"),
            t < od(this, id, "f").length && (i = od(this, id, "f")[t]));
            for (const {x: t, y: r, z: a, rotation: s, rotationAxis: o, type: l, checkpointOrder: c, detector: h} of n)
                if (c == i) {
                    const n = Kh(s, o)
                      , i = h.center.clone().applyQuaternion(n).add(new Zt(t * Jh.partSize,r * Jh.partSize,a * Jh.partSize))
                      , c = h.size.clone().applyQuaternion(n);
                    c.x = Math.abs(c.x),
                    c.y = Math.abs(c.y),
                    c.z = Math.abs(c.z);
                    const d = (new en).setFromCenterAndSize(i, c);
                    if (e.intersectsBox3(d))
                        return {
                            x: t,
                            y: r,
                            z: a,
                            rotation: s,
                            rotationAxis: o,
                            type: l
                        }
                }
            return null
        }
        ,
        ld.partSize = 5;
        const cd = ld;
        var hd;
        !function(e) {
            e[e.Straight = 0] = "Straight",
            e[e.TurnSharp = 1] = "TurnSharp",
            e[e.SlopeUp = 2] = "SlopeUp",
            e[e.SlopeDown = 3] = "SlopeDown",
            e[e.Slope = 4] = "Slope",
            e[e.Start = 5] = "Start",
            e[e.Finish = 6] = "Finish",
            e[e.ToWideMiddle = 7] = "ToWideMiddle",
            e[e.ToWideLeft = 8] = "ToWideLeft",
            e[e.ToWideRight = 9] = "ToWideRight",
            e[e.StraightWide = 10] = "StraightWide",
            e[e.InnerCornerWide = 11] = "InnerCornerWide",
            e[e.OuterCornerWide = 12] = "OuterCornerWide",
            e[e.SlopeUpLeftWide = 13] = "SlopeUpLeftWide",
            e[e.SlopeUpRightWide = 14] = "SlopeUpRightWide",
            e[e.SlopeDownLeftWide = 15] = "SlopeDownLeftWide",
            e[e.SlopeDownRightWide = 16] = "SlopeDownRightWide",
            e[e.SlopeLeftWide = 17] = "SlopeLeftWide",
            e[e.SlopeRightWide = 18] = "SlopeRightWide",
            e[e.PillarTop = 19] = "PillarTop",
            e[e.PillarMiddle = 20] = "PillarMiddle",
            e[e.PillarBottom = 21] = "PillarBottom",
            e[e.PillarShort = 22] = "PillarShort",
            e[e.PlanePillarBottom = 23] = "PlanePillarBottom",
            e[e.PlanePillarShort = 24] = "PlanePillarShort",
            e[e.Plane = 25] = "Plane",
            e[e.PlaneWall = 26] = "PlaneWall",
            e[e.PlaneWallCorner = 27] = "PlaneWallCorner",
            e[e.PlaneWallInnerCorner = 28] = "PlaneWallInnerCorner",
            e[e.Block = 29] = "Block",
            e[e.WallTrackTop = 30] = "WallTrackTop",
            e[e.WallTrackMiddle = 31] = "WallTrackMiddle",
            e[e.WallTrackBottom = 32] = "WallTrackBottom",
            e[e.PlaneSlopeUp = 33] = "PlaneSlopeUp",
            e[e.PlaneSlopeDown = 34] = "PlaneSlopeDown",
            e[e.PlaneSlope = 35] = "PlaneSlope",
            e[e.TurnShort = 36] = "TurnShort",
            e[e.TurnLong = 37] = "TurnLong",
            e[e.SlopeUpLong = 38] = "SlopeUpLong",
            e[e.SlopeDownLong = 39] = "SlopeDownLong",
            e[e.SlopePillar = 40] = "SlopePillar",
            e[e.TurnSLeft = 41] = "TurnSLeft",
            e[e.TurnSRight = 42] = "TurnSRight",
            e[e.IntersectionT = 43] = "IntersectionT",
            e[e.IntersectionCross = 44] = "IntersectionCross",
            e[e.PillarBranch1 = 45] = "PillarBranch1",
            e[e.PillarBranch2 = 46] = "PillarBranch2",
            e[e.PillarBranch3 = 47] = "PillarBranch3",
            e[e.PillarBranch4 = 48] = "PillarBranch4",
            e[e.WallTrackBottomCorner = 49] = "WallTrackBottomCorner",
            e[e.WallTrackMiddleCorner = 50] = "WallTrackMiddleCorner",
            e[e.WallTrackTopCorner = 51] = "WallTrackTopCorner",
            e[e.Checkpoint = 52] = "Checkpoint",
            e[e.HalfBlock = 53] = "HalfBlock",
            e[e.QuarterBlock = 54] = "QuarterBlock",
            e[e.HalfPlane = 55] = "HalfPlane",
            e[e.QuarterPlane = 56] = "QuarterPlane",
            e[e.PlaneBridge = 57] = "PlaneBridge",
            e[e.SignArrowLeft = 58] = "SignArrowLeft",
            e[e.SignArrowRight = 59] = "SignArrowRight",
            e[e.SignArrowUp = 61] = "SignArrowUp",
            e[e.SignArrowDown = 62] = "SignArrowDown",
            e[e.SignWarning = 63] = "SignWarning",
            e[e.SignWrongWay = 64] = "SignWrongWay",
            e[e.CheckpointWide = 65] = "CheckpointWide",
            e[e.WallTrackCeiling = 66] = "WallTrackCeiling",
            e[e.WallTrackFloor = 67] = "WallTrackFloor",
            e[e.BlockSlopedDown = 68] = "BlockSlopedDown",
            e[e.BlockSlopedDownInnerCorner = 69] = "BlockSlopedDownInnerCorner",
            e[e.BlockSlopedDownOuterCorner = 70] = "BlockSlopedDownOuterCorner",
            e[e.BlockSlopedUp = 71] = "BlockSlopedUp",
            e[e.BlockSlopedUpInnerCorner = 72] = "BlockSlopedUpInnerCorner",
            e[e.BlockSlopedUpOuterCorner = 73] = "BlockSlopedUpOuterCorner",
            e[e.FinishWide = 74] = "FinishWide",
            e[e.PlaneCheckpoint = 75] = "PlaneCheckpoint",
            e[e.PlaneFinish = 76] = "PlaneFinish",
            e[e.PlaneCheckpointWide = 77] = "PlaneCheckpointWide",
            e[e.PlaneFinishWide = 78] = "PlaneFinishWide",
            e[e.WallTrackBottomInnerCorner = 79] = "WallTrackBottomInnerCorner",
            e[e.WallTrackInnerCorner = 80] = "WallTrackInnerCorner",
            e[e.WallTrackTopInnerCorner = 81] = "WallTrackTopInnerCorner",
            e[e.TurnLong2 = 82] = "TurnLong2",
            e[e.TurnLong3 = 83] = "TurnLong3",
            e[e.SlopePillarShort = 84] = "SlopePillarShort",
            e[e.BlockSlopeUp = 85] = "BlockSlopeUp",
            e[e.BlockSlopeDown = 86] = "BlockSlopeDown",
            e[e.BlockSlopeVerticalTop = 87] = "BlockSlopeVerticalTop",
            e[e.BlockSlopeVerticalBottom = 88] = "BlockSlopeVerticalBottom",
            e[e.PlaneSlopeVerticalBottom = 90] = "PlaneSlopeVerticalBottom",
            e[e.StartWide = 91] = "StartWide",
            e[e.PlaneStart = 92] = "PlaneStart",
            e[e.PlaneStartWide = 93] = "PlaneStartWide",
            e[e.TurnShortLeftWide = 94] = "TurnShortLeftWide",
            e[e.TurnShortRightWide = 95] = "TurnShortRightWide",
            e[e.TurnLongLeftWide = 96] = "TurnLongLeftWide",
            e[e.TurnLongRightWide = 97] = "TurnLongRightWide",
            e[e.SlopeUpVertical = 98] = "SlopeUpVertical",
            e[e.PlaneSlopePillar = 99] = "PlaneSlopePillar",
            e[e.PlaneSlopePillarShort = 100] = "PlaneSlopePillarShort",
            e[e.PillarBranch1Top = 101] = "PillarBranch1Top",
            e[e.PillarBranch1Bottom = 102] = "PillarBranch1Bottom",
            e[e.PillarBranch1Middle = 103] = "PillarBranch1Middle",
            e[e.PillarBranch2Top = 104] = "PillarBranch2Top",
            e[e.PillarBranch2Middle = 105] = "PillarBranch2Middle",
            e[e.PillarBranch2Bottom = 106] = "PillarBranch2Bottom",
            e[e.PillarBranch3Top = 107] = "PillarBranch3Top",
            e[e.PillarBranch3Middle = 108] = "PillarBranch3Middle",
            e[e.PillarBranch3Bottom = 109] = "PillarBranch3Bottom",
            e[e.PillarBranch4Top = 110] = "PillarBranch4Top",
            e[e.PillarBranch4Middle = 111] = "PillarBranch4Middle",
            e[e.PillarBranch4Bottom = 112] = "PillarBranch4Bottom",
            e[e.PillarBranch5 = 113] = "PillarBranch5",
            e[e.PillarBranch5Top = 114] = "PillarBranch5Top",
            e[e.PillarBranch5Middle = 115] = "PillarBranch5Middle",
            e[e.PillarBranch5Bottom = 116] = "PillarBranch5Bottom",
            e[e.ToWideDouble = 117] = "ToWideDouble",
            e[e.ToWideDiagonal = 118] = "ToWideDiagonal",
            e[e.StraightPillarBottom = 119] = "StraightPillarBottom",
            e[e.StraightPillarShort = 120] = "StraightPillarShort",
            e[e.TurnSharpPillarBottom = 121] = "TurnSharpPillarBottom",
            e[e.TurnSharpPillarShort = 122] = "TurnSharpPillarShort",
            e[e.IntersectionTPillarBottom = 123] = "IntersectionTPillarBottom",
            e[e.IntersectionTPillarShort = 124] = "IntersectionTPillarShort",
            e[e.IntersectionCrossPillarBottom = 125] = "IntersectionCrossPillarBottom",
            e[e.IntersectionCrossPillarShort = 126] = "IntersectionCrossPillarShort",
            e[e.PlaneBridgeCorner = 127] = "PlaneBridgeCorner",
            e[e.PlaneBridgeIntersectionT = 128] = "PlaneBridgeIntersectionT",
            e[e.PlaneBridgeIntersectionCross = 129] = "PlaneBridgeIntersectionCross",
            e[e.BlockBridge = 130] = "BlockBridge",
            e[e.BlockBridgeCorner = 131] = "BlockBridgeCorner",
            e[e.BlockBridgeIntersectionT = 132] = "BlockBridgeIntersectionT",
            e[e.BlockBridgeIntersectionCross = 133] = "BlockBridgeIntersectionCross",
            e[e.WallTrackCeilingCorner = 134] = "WallTrackCeilingCorner",
            e[e.WallTrackCeilingPlaneCorner = 135] = "WallTrackCeilingPlaneCorner",
            e[e.WallTrackFloorCorner = 136] = "WallTrackFloorCorner",
            e[e.WallTrackFloorPlaneCorner = 137] = "WallTrackFloorPlaneCorner",
            e[e.SlopeUpVerticalLeftWide = 138] = "SlopeUpVerticalLeftWide",
            e[e.SlopeUpVerticalRightWide = 139] = "SlopeUpVerticalRightWide",
            e[e.BlockSlopeVerticalCornerTop = 140] = "BlockSlopeVerticalCornerTop",
            e[e.BlockSlopeVerticalCornerBottom = 141] = "BlockSlopeVerticalCornerBottom",
            e[e.WallTrackSlopeToVertical = 142] = "WallTrackSlopeToVertical",
            e[e.PlaneSlopeToVertical = 143] = "PlaneSlopeToVertical",
            e[e.BlockSlopeToVertical = 144] = "BlockSlopeToVertical",
            e[e.PlaneSlopeUpLong = 145] = "PlaneSlopeUpLong",
            e[e.PlaneSlopeDownLong = 146] = "PlaneSlopeDownLong",
            e[e.SlopeUpLongLeftWide = 147] = "SlopeUpLongLeftWide",
            e[e.SlopeUpLongRightWide = 148] = "SlopeUpLongRightWide",
            e[e.SlopeDownLongLeftWide = 149] = "SlopeDownLongLeftWide",
            e[e.SlopeDownLongRightWide = 150] = "SlopeDownLongRightWide",
            e[e.BlockSlopeUpLong = 151] = "BlockSlopeUpLong",
            e[e.BlockSlopeDownLong = 152] = "BlockSlopeDownLong",
            e[e.BlockSlopeVerticalInnerCornerBottom = 153] = "BlockSlopeVerticalInnerCornerBottom",
            e[e.BlockSlopeVerticalInnerCornerTop = 154] = "BlockSlopeVerticalInnerCornerTop",
            e[e.BlockInnerCorner = 155] = "BlockInnerCorner"
        }(hd || (hd = {}));
        const dd = hd;
        var ud;
        !function(e) {
            e[e.YPositive = 0] = "YPositive",
            e[e.YNegative = 1] = "YNegative",
            e[e.XPositive = 2] = "XPositive",
            e[e.XNegative = 3] = "XNegative",
            e[e.ZPositive = 4] = "ZPositive",
            e[e.ZNegative = 5] = "ZNegative"
        }(ud || (ud = {}));
        const fd = ud;
        function pd(e) {
            let t, n, i, r = -1, a = 0;
            for (let s = 0; s < e.length; ++s) {
                const o = e[s];
                if (void 0 === t && (t = o.array.constructor),
                t !== o.array.constructor)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
                    null;
                if (void 0 === n && (n = o.itemSize),
                n !== o.itemSize)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
                    null;
                if (void 0 === i && (i = o.normalized),
                i !== o.normalized)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
                    null;
                if (-1 === r && (r = o.gpuType),
                r !== o.gpuType)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
                    null;
                a += o.count * n
            }
            const s = new t(a)
              , o = new Ci(s,n,i);
            let l = 0;
            for (let t = 0; t < e.length; ++t) {
                const i = e[t];
                if (i.isInterleavedBufferAttribute) {
                    const e = l / n;
                    for (let t = 0, r = i.count; t < r; t++)
                        for (let r = 0; r < n; r++) {
                            const n = i.getComponent(t, r);
                            o.setComponent(t + e, r, n)
                        }
                } else
                    s.set(i.array, l);
                l += i.count * n
            }
            return void 0 !== r && (o.gpuType = r),
            o
        }
        function md(e, t) {
            if (0 === t)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                e;
            if (2 === t || 1 === t) {
                let n = e.getIndex();
                if (null === n) {
                    const t = []
                      , i = e.getAttribute("position");
                    if (void 0 === i)
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        e;
                    for (let e = 0; e < i.count; e++)
                        t.push(e);
                    e.setIndex(t),
                    n = e.getIndex()
                }
                const i = n.count - 2
                  , r = [];
                if (2 === t)
                    for (let e = 1; e <= i; e++)
                        r.push(n.getX(0)),
                        r.push(n.getX(e)),
                        r.push(n.getX(e + 1));
                else
                    for (let e = 0; e < i; e++)
                        e % 2 == 0 ? (r.push(n.getX(e)),
                        r.push(n.getX(e + 1)),
                        r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)),
                        r.push(n.getX(e + 1)),
                        r.push(n.getX(e)));
                r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const a = e.clone();
                return a.setIndex(r),
                a.clearGroups(),
                a
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
            e
        }
        class gd extends qa {
            constructor(e) {
                super(e),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(e) {
                    return new xd(e)
                }
                )),
                this.register((function(e) {
                    return new bd(e)
                }
                )),
                this.register((function(e) {
                    return new Bd(e)
                }
                )),
                this.register((function(e) {
                    return new Dd(e)
                }
                )),
                this.register((function(e) {
                    return new Ld(e)
                }
                )),
                this.register((function(e) {
                    return new Ed(e)
                }
                )),
                this.register((function(e) {
                    return new Md(e)
                }
                )),
                this.register((function(e) {
                    return new Td(e)
                }
                )),
                this.register((function(e) {
                    return new Cd(e)
                }
                )),
                this.register((function(e) {
                    return new yd(e)
                }
                )),
                this.register((function(e) {
                    return new Id(e)
                }
                )),
                this.register((function(e) {
                    return new Sd(e)
                }
                )),
                this.register((function(e) {
                    return new Pd(e)
                }
                )),
                this.register((function(e) {
                    return new Rd(e)
                }
                )),
                this.register((function(e) {
                    return new vd(e)
                }
                )),
                this.register((function(e) {
                    return new Ud(e)
                }
                )),
                this.register((function(e) {
                    return new Nd(e)
                }
                ))
            }
            load(e, t, n, i) {
                const r = this;
                let a;
                if ("" !== this.resourcePath)
                    a = this.resourcePath;
                else if ("" !== this.path) {
                    const t = gs.extractUrlBase(e);
                    a = gs.resolveURL(t, this.path)
                } else
                    a = gs.extractUrlBase(e);
                this.manager.itemStart(e);
                const s = function(t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                  , o = new Za(this.manager);
                o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(e, (function(n) {
                    try {
                        r.parse(n, a, (function(n) {
                            t(n),
                            r.manager.itemEnd(e)
                        }
                        ), s)
                    } catch (e) {
                        s(e)
                    }
                }
                ), n, s)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e,
                this
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e,
                this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e,
                this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                this
            }
            parse(e, t, n, i) {
                let r;
                const a = {}
                  , s = {}
                  , o = new TextDecoder;
                if ("string" == typeof e)
                    r = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (o.decode(new Uint8Array(e,0,4)) === kd) {
                        try {
                            a[_d.KHR_BINARY_GLTF] = new zd(e)
                        } catch (e) {
                            return void (i && i(e))
                        }
                        r = JSON.parse(a[_d.KHR_BINARY_GLTF].content)
                    } else
                        r = JSON.parse(o.decode(e))
                } else
                    r = e;
                if (void 0 === r.asset || r.asset.version[0] < 2)
                    return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new du(r,{
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let e = 0; e < this.pluginCallbacks.length; e++) {
                    const t = this.pluginCallbacks[e](l);
                    t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                    s[t.name] = t,
                    a[t.name] = !0
                }
                if (r.extensionsUsed)
                    for (let e = 0; e < r.extensionsUsed.length; ++e) {
                        const t = r.extensionsUsed[e]
                          , n = r.extensionsRequired || [];
                        switch (t) {
                        case _d.KHR_MATERIALS_UNLIT:
                            a[t] = new wd;
                            break;
                        case _d.KHR_DRACO_MESH_COMPRESSION:
                            a[t] = new Hd(r,this.dracoLoader);
                            break;
                        case _d.KHR_TEXTURE_TRANSFORM:
                            a[t] = new Wd;
                            break;
                        case _d.KHR_MESH_QUANTIZATION:
                            a[t] = new Vd;
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                        }
                    }
                l.setExtensions(a),
                l.setPlugins(s),
                l.parse(n, i)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(e, t, i, r)
                }
                ))
            }
        }
        function Ad() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const _d = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class vd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser
                  , t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser
                  , n = "light:" + e;
                let i = t.cache.get(n);
                if (i)
                    return i;
                const r = t.json
                  , a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                let s;
                const o = new wi(16777215);
                void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], Ke);
                const l = void 0 !== a.range ? a.range : 0;
                switch (a.type) {
                case "directional":
                    s = new ms(o),
                    s.target.position.set(0, 0, -1),
                    s.add(s.target);
                    break;
                case "point":
                    s = new us(o),
                    s.distance = l;
                    break;
                case "spot":
                    s = new os(o),
                    s.distance = l,
                    a.spot = a.spot || {},
                    a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0,
                    a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4,
                    s.angle = a.spot.outerConeAngle,
                    s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle,
                    s.target.position.set(0, 0, -1),
                    s.add(s.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                }
                return s.position.set(0, 0, 0),
                au(s, a),
                void 0 !== a.intensity && (s.intensity = a.intensity),
                s.name = t.createUniqueName(a.name || "light_" + e),
                i = Promise.resolve(s),
                t.cache.add(n, i),
                i
            }
            getDependency(e, t) {
                if ("light" === e)
                    return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this
                  , n = this.parser
                  , i = n.json.nodes[e]
                  , r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(e) {
                    return n._getNodeRef(t.cache, r, e)
                }
                ))
            }
        }
        class wd {
            constructor() {
                this.name = _d.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Si
            }
            extendParams(e, t, n) {
                const i = [];
                e.color = new wi(1,1,1),
                e.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const t = r.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], Ke),
                        e.opacity = t[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, Ye))
                }
                return Promise.all(i)
            }
        }
        class yd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i),
                Promise.resolve()
            }
        }
        class xd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
                void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
                void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
                void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)),
                void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)),
                void 0 !== a.clearcoatNormalTexture.scale)) {
                    const e = a.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new St(e,e)
                }
                return Promise.all(r)
            }
        }
        class bd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_DISPERSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0,
                Promise.resolve()
            }
        }
        class Sd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor),
                void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
                void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor),
                void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
                void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
                void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)),
                Promise.all(r)
            }
        }
        class Ed {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [];
                t.sheenColor = new wi(0,0,0),
                t.sheenRoughness = 0,
                t.sheen = 1;
                const a = i.extensions[this.name];
                if (void 0 !== a.sheenColorFactor) {
                    const e = a.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], Ke)
                }
                return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor),
                void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ye)),
                void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)),
                Promise.all(r)
            }
        }
        class Md {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor),
                void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
                Promise.all(r)
            }
        }
        class Td {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0,
                void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
                t.attenuationDistance = a.attenuationDistance || 1 / 0;
                const s = a.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new wi).setRGB(s[0], s[1], s[2], Ke),
                Promise.all(r)
            }
        }
        class Cd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5,
                Promise.resolve()
            }
        }
        class Id {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1,
                void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                const s = a.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new wi).setRGB(s[0], s[1], s[2], Ke),
                void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Ye)),
                Promise.all(r)
            }
        }
        class Rd {
            constructor(e) {
                this.parser = e,
                this.name = _d.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1,
                void 0 !== a.bumpTexture && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)),
                Promise.all(r)
            }
        }
        class Pd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ba : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength),
                void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation),
                void 0 !== a.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
                Promise.all(r)
            }
        }
        class Bd {
            constructor(e) {
                this.parser = e,
                this.name = _d.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser
                  , n = t.json
                  , i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name]
                  , a = t.options.ktx2Loader;
                if (!a) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, r.source, a)
            }
        }
        class Dd {
            constructor(e) {
                this.parser = e,
                this.name = _d.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const a = r.extensions[t]
                  , s = i.images[a.source];
                let o = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, a.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Ld {
            constructor(e) {
                this.parser = e,
                this.name = _d.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const a = r.extensions[t]
                  , s = i.images[a.source];
                let o = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, a.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Ud {
            constructor(e) {
                this.name = _d.EXT_MESHOPT_COMPRESSION,
                this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json
                  , n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name]
                      , i = this.parser.getDependency("buffer", e.buffer)
                      , r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function(t) {
                        const n = e.byteOffset || 0
                          , i = e.byteLength || 0
                          , a = e.count
                          , s = e.byteStride
                          , o = new Uint8Array(t,n,i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        }
                        )) : r.ready.then((function() {
                            const t = new ArrayBuffer(a * s);
                            return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter),
                            t
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class Nd {
            constructor(e) {
                this.name = _d.EXT_MESH_GPU_INSTANCING,
                this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json
                  , n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const i = t.meshes[n.mesh];
                for (const e of i.primitives)
                    if (e.mode !== jd.TRIANGLES && e.mode !== jd.TRIANGLE_STRIP && e.mode !== jd.TRIANGLE_FAN && void 0 !== e.mode)
                        return null;
                const r = n.extensions[this.name].attributes
                  , a = []
                  , s = {};
                for (const e in r)
                    a.push(this.parser.getDependency("accessor", r[e]).then((t => (s[e] = t,
                    s[e]))));
                return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
                Promise.all(a).then((e => {
                    const t = e.pop()
                      , n = t.isGroup ? t.children : [t]
                      , i = e[0].count
                      , r = [];
                    for (const e of n) {
                        const t = new Cn
                          , n = new Zt
                          , a = new Kt
                          , o = new Zt(1,1,1)
                          , l = new Qr(e.geometry,e.material,i);
                        for (let e = 0; e < i; e++)
                            s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e),
                            s.ROTATION && a.fromBufferAttribute(s.ROTATION, e),
                            s.SCALE && o.fromBufferAttribute(s.SCALE, e),
                            l.setMatrixAt(e, t.compose(n, a, o));
                        for (const t in s)
                            if ("_COLOR_0" === t) {
                                const e = s[t];
                                l.instanceColor = new kr(e.array,e.itemSize,e.normalized)
                            } else
                                "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                        ti.prototype.copy.call(l, e),
                        this.parser.assignFinalMaterial(l),
                        r.push(l)
                    }
                    return t.isGroup ? (t.clear(),
                    t.add(...r),
                    t) : r[0]
                }
                )))
            }
        }
        const kd = "glTF"
          , Fd = 1313821514
          , Od = 5130562;
        class zd {
            constructor(e) {
                this.name = _d.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const t = new DataView(e,0,12)
                  , n = new TextDecoder;
                if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                },
                this.header.magic !== kd)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12
                  , r = new DataView(e,12);
                let a = 0;
                for (; a < i; ) {
                    const t = r.getUint32(a, !0);
                    a += 4;
                    const i = r.getUint32(a, !0);
                    if (a += 4,
                    i === Fd) {
                        const i = new Uint8Array(e,12 + a,t);
                        this.content = n.decode(i)
                    } else if (i === Od) {
                        const n = 12 + a;
                        this.body = e.slice(n, n + t)
                    }
                    a += t
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Hd {
            constructor(e, t) {
                if (!t)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = _d.KHR_DRACO_MESH_COMPRESSION,
                this.json = e,
                this.dracoLoader = t,
                this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json
                  , i = this.dracoLoader
                  , r = e.extensions[this.name].bufferView
                  , a = e.extensions[this.name].attributes
                  , s = {}
                  , o = {}
                  , l = {};
                for (const e in a) {
                    const t = Jd[e] || e.toLowerCase();
                    s[t] = a[e]
                }
                for (const t in e.attributes) {
                    const i = Jd[t] || t.toLowerCase();
                    if (void 0 !== a[t]) {
                        const r = n.accessors[e.attributes[t]]
                          , a = qd[r.componentType];
                        l[i] = a.name,
                        o[i] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", r).then((function(e) {
                    return new Promise((function(t, n) {
                        i.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t]
                                  , i = o[t];
                                void 0 !== i && (n.normalized = i)
                            }
                            t(e)
                        }
                        ), s, l, Ke, n)
                    }
                    ))
                }
                ))
            }
        }
        class Wd {
            constructor() {
                this.name = _d.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                void 0 !== t.texCoord && (e.channel = t.texCoord),
                void 0 !== t.offset && e.offset.fromArray(t.offset),
                void 0 !== t.rotation && (e.rotation = t.rotation),
                void 0 !== t.scale && e.repeat.fromArray(t.scale),
                e.needsUpdate = !0,
                e) : e
            }
        }
        class Vd {
            constructor() {
                this.name = _d.KHR_MESH_QUANTIZATION
            }
        }
        class Gd extends Pa {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i * 3 + i;
                for (let e = 0; e !== i; e++)
                    t[e] = n[r + e];
                return t
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = 2 * s
                  , l = 3 * s
                  , c = i - t
                  , h = (n - t) / c
                  , d = h * h
                  , u = d * h
                  , f = e * l
                  , p = f - l
                  , m = -2 * u + 3 * d
                  , g = u - d
                  , A = 1 - m
                  , _ = g - d + h;
                for (let e = 0; e !== s; e++) {
                    const t = a[p + e + s]
                      , n = a[p + e + o] * c
                      , i = a[f + e + s]
                      , l = a[f + e] * c;
                    r[e] = A * t + _ * n + m * i + g * l
                }
                return r
            }
        }
        const Qd = new Kt;
        class Xd extends Gd {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return Qd.fromArray(r).normalize().toArray(r),
                r
            }
        }
        const jd = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , qd = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , Yd = {
            9728: z,
            9729: V,
            9984: H,
            9985: G,
            9986: W,
            9987: Q
        }
          , Kd = {
            33071: F,
            33648: O,
            10497: k
        }
          , Zd = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , Jd = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , $d = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , eu = {
            CUBICSPLINE: void 0,
            LINEAR: Ve,
            STEP: We
        }
          , tu = "OPAQUE"
          , nu = "MASK"
          , iu = "BLEND";
        function ru(e, t, n) {
            for (const i in n.extensions)
                void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                t.userData.gltfExtensions[i] = n.extensions[i])
        }
        function au(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function su(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++)
                    e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++)
                        e.morphTargetDictionary[n[t]] = t
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function ou(e) {
            let t;
            const n = e.extensions && e.extensions[_d.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + lu(n.attributes) : e.indices + ":" + lu(e.attributes) + ":" + e.mode,
            void 0 !== e.targets)
                for (let n = 0, i = e.targets.length; n < i; n++)
                    t += ":" + lu(e.targets[n]);
            return t
        }
        function lu(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++)
                t += n[i] + ":" + e[n[i]] + ";";
            return t
        }
        function cu(e) {
            switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const hu = new Cn;
        class du {
            constructor(e={}, t={}) {
                this.json = e,
                this.extensions = {},
                this.plugins = {},
                this.options = t,
                this.cache = new Ad,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let n = !1
                  , i = -1
                  , r = !1
                  , a = -1;
                if ("undefined" != typeof navigator) {
                    const e = navigator.userAgent;
                    n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                    const t = e.match(/Version\/(\d+)/);
                    i = n && t ? parseInt(t[1], 10) : -1,
                    r = e.indexOf("Firefox") > -1,
                    a = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
                }
                "undefined" == typeof createImageBitmap || n && i < 17 || r && a < 98 ? this.textureLoader = new $a(this.options.manager) : this.textureLoader = new As(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new Za(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this
                  , i = this.json
                  , r = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(t) {
                    const a = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return ru(r, a, i),
                    au(a, i),
                    Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(a)
                    }
                    ))).then((function() {
                        for (const e of a.scenes)
                            e.updateMatrixWorld();
                        e(a)
                    }
                    ))
                }
                )).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || []
                  , t = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++)
                        e[i[t]].isBone = !0
                }
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                    void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                    void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1)
                    return n;
                const i = n.clone()
                  , r = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n,i] of e.children.entries())
                        r(i, t.children[n])
                }
                ;
                return r(n, i),
                i.name += "_instance_" + e.uses[t]++,
                i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i)
                        return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne((function(e) {
                            return e.loadNode && e.loadNode(t)
                        }
                        ));
                        break;
                    case "mesh":
                        i = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }
                        ));
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }
                        ));
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }
                        ));
                        break;
                    case "texture":
                        i = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }
                        ));
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }
                        ));
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(e, t)
                        }
                        )),
                        !i)
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this
                      , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(i.map((function(t, i) {
                        return n.getDependency(e, i)
                    }
                    ))),
                    this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e]
                  , n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type)
                    throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e)
                    return Promise.resolve(this.extensions[_d.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(e, r) {
                    n.load(gs.resolveURL(t.uri, i.path), e, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0
                      , i = t.byteOffset || 0;
                    return e.slice(i, i + n)
                }
                ))
            }
            loadAccessor(e) {
                const t = this
                  , n = this.json
                  , i = this.json.accessors[e];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const e = Zd[i.type]
                      , t = qd[i.componentType]
                      , n = !0 === i.normalized
                      , r = new t(i.count * e);
                    return Promise.resolve(new Ci(r,e,n))
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
                void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                Promise.all(r).then((function(e) {
                    const r = e[0]
                      , a = Zd[i.type]
                      , s = qd[i.componentType]
                      , o = s.BYTES_PER_ELEMENT
                      , l = o * a
                      , c = i.byteOffset || 0
                      , h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                      , d = !0 === i.normalized;
                    let u, f;
                    if (h && h !== l) {
                        const e = Math.floor(c / h)
                          , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                        let l = t.cache.get(n);
                        l || (u = new s(r,e * h,i.count * h / o),
                        l = new vr(u,h / o),
                        t.cache.add(n, l)),
                        f = new yr(l,a,c % h / o,d)
                    } else
                        u = null === r ? new s(i.count * a) : new s(r,c,i.count * a),
                        f = new Ci(u,a,d);
                    if (void 0 !== i.sparse) {
                        const t = Zd.SCALAR
                          , n = qd[i.sparse.indices.componentType]
                          , o = i.sparse.indices.byteOffset || 0
                          , l = i.sparse.values.byteOffset || 0
                          , c = new n(e[1],o,i.sparse.count * t)
                          , h = new s(e[2],l,i.sparse.count * a);
                        null !== r && (f = new Ci(f.array.slice(),f.itemSize,f.normalized)),
                        f.normalized = !1;
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            if (f.setX(t, h[e * a]),
                            a >= 2 && f.setY(t, h[e * a + 1]),
                            a >= 3 && f.setZ(t, h[e * a + 2]),
                            a >= 4 && f.setW(t, h[e * a + 3]),
                            a >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                        f.normalized = d
                    }
                    return f
                }
                ))
            }
            loadTexture(e) {
                const t = this.json
                  , n = this.options
                  , i = t.textures[e].source
                  , r = t.images[i];
                let a = this.textureLoader;
                if (r.uri) {
                    const e = n.manager.getHandler(r.uri);
                    null !== e && (a = e)
                }
                return this.loadTextureImage(e, i, a)
            }
            loadTextureImage(e, t, n) {
                const i = this
                  , r = this.json
                  , a = r.textures[e]
                  , s = r.images[t]
                  , o = (s.uri || s.bufferView) + ":" + a.sampler;
                if (this.textureCache[o])
                    return this.textureCache[o];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1,
                    t.name = a.name || s.name || "",
                    "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri);
                    const n = (r.samplers || {})[a.sampler] || {};
                    return t.magFilter = Yd[n.magFilter] || V,
                    t.minFilter = Yd[n.minFilter] || Q,
                    t.wrapS = Kd[n.wrapS] || k,
                    t.wrapT = Kd[n.wrapT] || k,
                    t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== z && t.minFilter !== V,
                    i.associations.set(t, {
                        textures: e
                    }),
                    t
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[o] = l,
                l
            }
            loadImageSource(e, t) {
                const n = this
                  , i = this.json
                  , r = this.options;
                if (void 0 !== this.sourceCache[e])
                    return this.sourceCache[e].then((e => e.clone()));
                const a = i.images[e]
                  , s = self.URL || self.webkitURL;
                let o = a.uri || ""
                  , l = !1;
                if (void 0 !== a.bufferView)
                    o = n.getDependency("bufferView", a.bufferView).then((function(e) {
                        l = !0;
                        const t = new Blob([e],{
                            type: a.mimeType
                        });
                        return o = s.createObjectURL(t),
                        o
                    }
                    ));
                else if (void 0 === a.uri)
                    throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(o).then((function(e) {
                    return new Promise((function(n, i) {
                        let a = n;
                        !0 === t.isImageBitmapLoader && (a = function(e) {
                            const t = new Gt(e);
                            t.needsUpdate = !0,
                            n(t)
                        }
                        ),
                        t.load(gs.resolveURL(e, r.path), a, void 0, i)
                    }
                    ))
                }
                )).then((function(e) {
                    var t;
                    return !0 === l && s.revokeObjectURL(o),
                    au(e, a),
                    e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"),
                    e
                }
                )).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", o),
                    e
                }
                ));
                return this.sourceCache[e] = c,
                c
            }
            assignTexture(e, t, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(a) {
                    if (!a)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord),
                    r.extensions[_d.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[_d.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = r.associations.get(a);
                            a = r.extensions[_d.KHR_TEXTURE_TRANSFORM].extendTexture(a, e),
                            r.associations.set(a, t)
                        }
                    }
                    return void 0 !== i && (a.colorSpace = i),
                    e[t] = a,
                    a
                }
                ))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const i = void 0 === t.attributes.tangent
                  , r = void 0 !== t.attributes.color
                  , a = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new fa,
                    bi.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    t.sizeAttenuation = !1,
                    this.cache.add(e, t)),
                    n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new $r,
                    bi.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    this.cache.add(e, t)),
                    n = t
                }
                if (i || r || a) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    i && (e += "derivative-tangents:"),
                    r && (e += "vertex-colors:"),
                    a && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(),
                    r && (t.vertexColors = !0),
                    a && (t.flatShading = !0),
                    i && (t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                    this.cache.add(e, t),
                    this.associations.set(t, this.associations.get(n))),
                    n = t
                }
                e.material = n
            }
            getMaterialType() {
                return xa
            }
            loadMaterial(e) {
                const t = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.materials[e];
                let a;
                const s = {}
                  , o = [];
                if ((r.extensions || {})[_d.KHR_MATERIALS_UNLIT]) {
                    const e = i[_d.KHR_MATERIALS_UNLIT];
                    a = e.getMaterialType(),
                    o.push(e.extendParams(s, r, t))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (s.color = new wi(1,1,1),
                    s.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        s.color.setRGB(e[0], e[1], e[2], Ke),
                        s.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && o.push(t.assignTexture(s, "map", n.baseColorTexture, Ye)),
                    s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (o.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)),
                    o.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))),
                    a = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    }
                    )),
                    o.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, s)
                    }
                    ))))
                }
                !0 === r.doubleSided && (s.side = 2);
                const l = r.alphaMode || tu;
                if (l === iu ? (s.transparent = !0,
                s.depthWrite = !1) : (s.transparent = !1,
                l === nu && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
                void 0 !== r.normalTexture && a !== Si && (o.push(t.assignTexture(s, "normalMap", r.normalTexture)),
                s.normalScale = new St(1,1),
                void 0 !== r.normalTexture.scale)) {
                    const e = r.normalTexture.scale;
                    s.normalScale.set(e, e)
                }
                if (void 0 !== r.occlusionTexture && a !== Si && (o.push(t.assignTexture(s, "aoMap", r.occlusionTexture)),
                void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)),
                void 0 !== r.emissiveFactor && a !== Si) {
                    const e = r.emissiveFactor;
                    s.emissive = (new wi).setRGB(e[0], e[1], e[2], Ke)
                }
                return void 0 !== r.emissiveTexture && a !== Si && o.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, Ye)),
                Promise.all(o).then((function() {
                    const n = new a(s);
                    return r.name && (n.name = r.name),
                    au(n, r),
                    t.associations.set(n, {
                        materials: e
                    }),
                    r.extensions && ru(i, n, r),
                    n
                }
                ))
            }
            createUniqueName(e) {
                const t = Es.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                t)
            }
            loadGeometries(e) {
                const t = this
                  , n = this.extensions
                  , i = this.primitiveCache;
                function r(e) {
                    return n[_d.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return uu(n, e, t)
                    }
                    ))
                }
                const a = [];
                for (let n = 0, s = e.length; n < s; n++) {
                    const s = e[n]
                      , o = ou(s)
                      , l = i[o];
                    if (l)
                        a.push(l.promise);
                    else {
                        let e;
                        e = s.extensions && s.extensions[_d.KHR_DRACO_MESH_COMPRESSION] ? r(s) : uu(new Oi, s, t),
                        i[o] = {
                            primitive: s,
                            promise: e
                        },
                        a.push(e)
                    }
                }
                return Promise.all(a)
            }
            loadMesh(e) {
                const t = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.meshes[e]
                  , a = r.primitives
                  , s = [];
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new xa({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })),
                    o.DefaultMaterial) : this.getDependency("material", a[e].material);
                    s.push(t)
                }
                var o;
                return s.push(t.loadGeometries(a)),
                Promise.all(s).then((function(n) {
                    const s = n.slice(0, n.length - 1)
                      , o = n[n.length - 1]
                      , l = [];
                    for (let n = 0, c = o.length; n < c; n++) {
                        const c = o[n]
                          , h = a[n];
                        let d;
                        const u = s[n];
                        if (h.mode === jd.TRIANGLES || h.mode === jd.TRIANGLE_STRIP || h.mode === jd.TRIANGLE_FAN || void 0 === h.mode)
                            d = !0 === r.isSkinnedMesh ? new Pr(c,u) : new Zi(c,u),
                            !0 === d.isSkinnedMesh && d.normalizeSkinWeights(),
                            h.mode === jd.TRIANGLE_STRIP ? d.geometry = md(d.geometry, 1) : h.mode === jd.TRIANGLE_FAN && (d.geometry = md(d.geometry, 2));
                        else if (h.mode === jd.LINES)
                            d = new da(c,u);
                        else if (h.mode === jd.LINE_STRIP)
                            d = new oa(c,u);
                        else if (h.mode === jd.LINE_LOOP)
                            d = new ua(c,u);
                        else {
                            if (h.mode !== jd.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                            d = new _a(c,u)
                        }
                        Object.keys(d.geometry.morphAttributes).length > 0 && su(d, r),
                        d.name = t.createUniqueName(r.name || "mesh_" + e),
                        au(d, r),
                        h.extensions && ru(i, d, h),
                        t.assignFinalMaterial(d),
                        l.push(d)
                    }
                    for (let n = 0, i = l.length; n < i; n++)
                        t.associations.set(l[n], {
                            meshes: e,
                            primitives: n
                        });
                    if (1 === l.length)
                        return r.extensions && ru(i, l[0], r),
                        l[0];
                    const c = new pr;
                    r.extensions && ru(i, c, r),
                    t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++)
                        c.add(l[e]);
                    return c
                }
                ))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e]
                  , i = n[n.type];
                if (i)
                    return "perspective" === n.type ? t = new cr(bt.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new fs(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                    n.name && (t.name = this.createUniqueName(n.name)),
                    au(t, n),
                    Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e]
                  , n = [];
                for (let e = 0, i = t.joints.length; e < i; e++)
                    n.push(this._loadNodeShallow(t.joints[e]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                Promise.all(n).then((function(e) {
                    const n = e.pop()
                      , i = e
                      , r = []
                      , a = [];
                    for (let e = 0, s = i.length; e < s; e++) {
                        const s = i[e];
                        if (s) {
                            r.push(s);
                            const t = new Cn;
                            null !== n && t.fromArray(n.array, 16 * e),
                            a.push(t)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    return new Nr(r,a)
                }
                ))
            }
            loadAnimation(e) {
                const t = this.json
                  , n = this
                  , i = t.animations[e]
                  , r = i.name ? i.name : "animation_" + e
                  , a = []
                  , s = []
                  , o = []
                  , l = []
                  , c = [];
                for (let e = 0, t = i.channels.length; e < t; e++) {
                    const t = i.channels[e]
                      , n = i.samplers[t.sampler]
                      , r = t.target
                      , h = r.node
                      , d = void 0 !== i.parameters ? i.parameters[n.input] : n.input
                      , u = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (a.push(this.getDependency("node", h)),
                    s.push(this.getDependency("accessor", d)),
                    o.push(this.getDependency("accessor", u)),
                    l.push(n),
                    c.push(r))
                }
                return Promise.all([Promise.all(a), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function(e) {
                    const t = e[0]
                      , i = e[1]
                      , a = e[2]
                      , s = e[3]
                      , o = e[4]
                      , l = [];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = t[e]
                          , c = i[e]
                          , h = a[e]
                          , d = s[e]
                          , u = o[e];
                        if (void 0 === r)
                            continue;
                        r.updateMatrix && r.updateMatrix();
                        const f = n._createAnimationTracks(r, c, h, d, u);
                        if (f)
                            for (let e = 0; e < f.length; e++)
                                l.push(f[e])
                    }
                    return new Va(r,void 0,l)
                }
                ))
            }
            createNodeMesh(e) {
                const t = this.json
                  , n = this
                  , i = t.nodes[e];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                    return void 0 !== i.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++)
                                e.morphTargetInfluences[t] = i.weights[t]
                    }
                    )),
                    t
                }
                ))
            }
            loadNode(e) {
                const t = this
                  , n = this.json.nodes[e]
                  , i = t._loadNodeShallow(e)
                  , r = []
                  , a = n.children || [];
                for (let e = 0, n = a.length; e < n; e++)
                    r.push(t.getDependency("node", a[e]));
                const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), s]).then((function(e) {
                    const t = e[0]
                      , n = e[1]
                      , i = e[2];
                    null !== i && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(i, hu)
                    }
                    ));
                    for (let e = 0, i = n.length; e < i; e++)
                        t.add(n[e]);
                    return t
                }
                ))
            }
            _loadNodeShallow(e) {
                const t = this.json
                  , n = this.extensions
                  , i = this;
                if (void 0 !== this.nodeCache[e])
                    return this.nodeCache[e];
                const r = t.nodes[e]
                  , a = r.name ? i.createUniqueName(r.name) : ""
                  , s = []
                  , o = i._invokeOne((function(t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }
                ));
                return o && s.push(o),
                void 0 !== r.camera && s.push(i.getDependency("camera", r.camera).then((function(e) {
                    return i._getNodeRef(i.cameraCache, r.camera, e)
                }
                ))),
                i._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                }
                )).forEach((function(e) {
                    s.push(e)
                }
                )),
                this.nodeCache[e] = Promise.all(s).then((function(t) {
                    let s;
                    if (s = !0 === r.isBone ? new Br : t.length > 1 ? new pr : 1 === t.length ? t[0] : new ti,
                    s !== t[0])
                        for (let e = 0, n = t.length; e < n; e++)
                            s.add(t[e]);
                    if (r.name && (s.userData.name = r.name,
                    s.name = a),
                    au(s, r),
                    r.extensions && ru(n, s, r),
                    void 0 !== r.matrix) {
                        const e = new Cn;
                        e.fromArray(r.matrix),
                        s.applyMatrix4(e)
                    } else
                        void 0 !== r.translation && s.position.fromArray(r.translation),
                        void 0 !== r.rotation && s.quaternion.fromArray(r.rotation),
                        void 0 !== r.scale && s.scale.fromArray(r.scale);
                    return i.associations.has(s) || i.associations.set(s, {}),
                    i.associations.get(s).nodes = e,
                    s
                }
                )),
                this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions
                  , n = this.json.scenes[e]
                  , i = this
                  , r = new pr;
                n.name && (r.name = i.createUniqueName(n.name)),
                au(r, n),
                n.extensions && ru(t, r, n);
                const a = n.nodes || []
                  , s = [];
                for (let e = 0, t = a.length; e < t; e++)
                    s.push(i.getDependency("node", a[e]));
                return Promise.all(s).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++)
                        r.add(e[t]);
                    return i.associations = (e => {
                        const t = new Map;
                        for (const [e,n] of i.associations)
                            (e instanceof bi || e instanceof Gt) && t.set(e, n);
                        return e.traverse((e => {
                            const n = i.associations.get(e);
                            null != n && t.set(e, n)
                        }
                        )),
                        t
                    }
                    )(r),
                    r
                }
                ))
            }
            _createAnimationTracks(e, t, n, i, r) {
                const a = []
                  , s = e.name ? e.name : e.uuid
                  , o = [];
                let l;
                switch ($d[r.path] === $d.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid)
                }
                )) : o.push(s),
                $d[r.path]) {
                case $d.weights:
                    l = Fa;
                    break;
                case $d.rotation:
                    l = za;
                    break;
                case $d.position:
                case $d.scale:
                    l = Wa;
                    break;
                default:
                    if (1 === n.itemSize)
                        l = Fa;
                    else
                        l = Wa
                }
                const c = void 0 !== i.interpolation ? eu[i.interpolation] : Ve
                  , h = this._getArrayFromAccessor(n);
                for (let e = 0, n = o.length; e < n; e++) {
                    const n = new l(o[e] + "." + $d[r.path],t.array,h,c);
                    "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n),
                    a.push(n)
                }
                return a
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = cu(t.constructor)
                      , n = new Float32Array(t.length);
                    for (let i = 0, r = t.length; i < r; i++)
                        n[i] = t[i] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new (this instanceof za ? Xd : Gd)(this.times,this.values,this.getValueSize() / 3,e)
                }
                ,
                e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }
        function uu(e, t, n) {
            const i = t.attributes
              , r = [];
            function a(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }
                ))
            }
            for (const t in i) {
                const n = Jd[t] || t.toLowerCase();
                n in e.attributes || r.push(a(i[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const i = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                r.push(i)
            }
            return Ut.workingColorSpace !== Ke && "COLOR_0"in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ut.workingColorSpace}" not supported.`),
            au(e, t),
            function(e, t, n) {
                const i = t.attributes
                  , r = new en;
                if (void 0 === i.POSITION)
                    return;
                {
                    const e = n.json.accessors[i.POSITION]
                      , t = e.min
                      , a = e.max;
                    if (void 0 === t || void 0 === a)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new Zt(t[0],t[1],t[2]), new Zt(a[0],a[1],a[2])),
                    e.normalized) {
                        const t = cu(qd[e.componentType]);
                        r.min.multiplyScalar(t),
                        r.max.multiplyScalar(t)
                    }
                }
                const a = t.targets;
                if (void 0 !== a) {
                    const e = new Zt
                      , t = new Zt;
                    for (let i = 0, r = a.length; i < r; i++) {
                        const r = a[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION]
                              , a = i.min
                              , s = i.max;
                            if (void 0 !== a && void 0 !== s) {
                                if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))),
                                t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))),
                                t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))),
                                i.normalized) {
                                    const e = cu(qd[i.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(e)
                }
                e.boundingBox = r;
                const s = new vn;
                r.getCenter(s.center),
                s.radius = r.min.distanceTo(r.max) / 2,
                e.boundingSphere = s
            }(e, t, n),
            Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let i = !1
                      , r = !1
                      , a = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (a = !0),
                        i && r && a)
                            break
                    }
                    if (!i && !r && !a)
                        return Promise.resolve(e);
                    const s = []
                      , o = []
                      , l = [];
                    for (let c = 0, h = t.length; c < h; c++) {
                        const h = t[c];
                        if (i) {
                            const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                            s.push(t)
                        }
                        if (r) {
                            const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                            o.push(t)
                        }
                        if (a) {
                            const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function(t) {
                        const n = t[0]
                          , s = t[1]
                          , o = t[2];
                        return i && (e.morphAttributes.position = n),
                        r && (e.morphAttributes.normal = s),
                        a && (e.morphAttributes.color = o),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
        /**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
        function fu() {
            let e = null
              , t = !1
              , n = null
              , i = null;
            function r(t, a) {
                n(t, a),
                i = e.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
                    t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(i),
                    t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }
        function pu(e) {
            const t = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data),
                    t.get(e)
                },
                remove: function(n) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    const i = t.get(n);
                    i && (e.deleteBuffer(i.buffer),
                    t.delete(n))
                },
                update: function(n, i) {
                    if (n.isInterleavedBufferAttribute && (n = n.data),
                    n.isGLBufferAttribute) {
                        const e = t.get(n);
                        return void ((!e || e.version < n.version) && t.set(n, {
                            buffer: n.buffer,
                            type: n.type,
                            bytesPerElement: n.elementSize,
                            version: n.version
                        }))
                    }
                    const r = t.get(n);
                    if (void 0 === r)
                        t.set(n, function(t, n) {
                            const i = t.array
                              , r = t.usage
                              , a = i.byteLength
                              , s = e.createBuffer();
                            let o;
                            if (e.bindBuffer(n, s),
                            e.bufferData(n, i, r),
                            t.onUploadCallback(),
                            i instanceof Float32Array)
                                o = e.FLOAT;
                            else if (i instanceof Uint16Array)
                                o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array)
                                o = e.SHORT;
                            else if (i instanceof Uint32Array)
                                o = e.UNSIGNED_INT;
                            else if (i instanceof Int32Array)
                                o = e.INT;
                            else if (i instanceof Int8Array)
                                o = e.BYTE;
                            else if (i instanceof Uint8Array)
                                o = e.UNSIGNED_BYTE;
                            else {
                                if (!(i instanceof Uint8ClampedArray))
                                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                o = e.UNSIGNED_BYTE
                            }
                            return {
                                buffer: s,
                                type: o,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: a
                            }
                        }(n, i));
                    else if (r.version < n.version) {
                        if (r.size !== n.array.byteLength)
                            throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        !function(t, n, i) {
                            const r = n.array
                              , a = n.updateRanges;
                            if (e.bindBuffer(i, t),
                            0 === a.length)
                                e.bufferSubData(i, 0, r);
                            else {
                                a.sort(( (e, t) => e.start - t.start));
                                let t = 0;
                                for (let e = 1; e < a.length; e++) {
                                    const n = a[t]
                                      , i = a[e];
                                    i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t,
                                    a[t] = i)
                                }
                                a.length = t + 1;
                                for (let t = 0, n = a.length; t < n; t++) {
                                    const n = a[t];
                                    e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                }
                                n.clearUpdateRanges()
                            }
                            n.onUploadCallback()
                        }(r.buffer, n, i),
                        r.version = n.version
                    }
                }
            }
        }
        const mu = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }
          , gu = {
            common: {
                diffuse: {
                    value: new wi(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Et
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Et
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new Et
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new Et
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new Et
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new Et
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new Et
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new Et
                },
                normalScale: {
                    value: new St(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new Et
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new Et
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new Et
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new Et
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new wi(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new wi(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Et
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Et
                }
            },
            sprite: {
                diffuse: {
                    value: new wi(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new St(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Et
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Et
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , Au = {
            basic: {
                uniforms: tr([gu.common, gu.specularmap, gu.envmap, gu.aomap, gu.lightmap, gu.fog]),
                vertexShader: mu.meshbasic_vert,
                fragmentShader: mu.meshbasic_frag
            },
            lambert: {
                uniforms: tr([gu.common, gu.specularmap, gu.envmap, gu.aomap, gu.lightmap, gu.emissivemap, gu.bumpmap, gu.normalmap, gu.displacementmap, gu.fog, gu.lights, {
                    emissive: {
                        value: new wi(0)
                    }
                }]),
                vertexShader: mu.meshlambert_vert,
                fragmentShader: mu.meshlambert_frag
            },
            phong: {
                uniforms: tr([gu.common, gu.specularmap, gu.envmap, gu.aomap, gu.lightmap, gu.emissivemap, gu.bumpmap, gu.normalmap, gu.displacementmap, gu.fog, gu.lights, {
                    emissive: {
                        value: new wi(0)
                    },
                    specular: {
                        value: new wi(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: mu.meshphong_vert,
                fragmentShader: mu.meshphong_frag
            },
            standard: {
                uniforms: tr([gu.common, gu.envmap, gu.aomap, gu.lightmap, gu.emissivemap, gu.bumpmap, gu.normalmap, gu.displacementmap, gu.roughnessmap, gu.metalnessmap, gu.fog, gu.lights, {
                    emissive: {
                        value: new wi(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: mu.meshphysical_vert,
                fragmentShader: mu.meshphysical_frag
            },
            toon: {
                uniforms: tr([gu.common, gu.aomap, gu.lightmap, gu.emissivemap, gu.bumpmap, gu.normalmap, gu.displacementmap, gu.gradientmap, gu.fog, gu.lights, {
                    emissive: {
                        value: new wi(0)
                    }
                }]),
                vertexShader: mu.meshtoon_vert,
                fragmentShader: mu.meshtoon_frag
            },
            matcap: {
                uniforms: tr([gu.common, gu.bumpmap, gu.normalmap, gu.displacementmap, gu.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: mu.meshmatcap_vert,
                fragmentShader: mu.meshmatcap_frag
            },
            points: {
                uniforms: tr([gu.points, gu.fog]),
                vertexShader: mu.points_vert,
                fragmentShader: mu.points_frag
            },
            dashed: {
                uniforms: tr([gu.common, gu.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: mu.linedashed_vert,
                fragmentShader: mu.linedashed_frag
            },
            depth: {
                uniforms: tr([gu.common, gu.displacementmap]),
                vertexShader: mu.depth_vert,
                fragmentShader: mu.depth_frag
            },
            normal: {
                uniforms: tr([gu.common, gu.bumpmap, gu.normalmap, gu.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: mu.meshnormal_vert,
                fragmentShader: mu.meshnormal_frag
            },
            sprite: {
                uniforms: tr([gu.sprite, gu.fog]),
                vertexShader: mu.sprite_vert,
                fragmentShader: mu.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Et
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: mu.background_vert,
                fragmentShader: mu.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new Et
                    }
                },
                vertexShader: mu.backgroundCube_vert,
                fragmentShader: mu.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: mu.cube_vert,
                fragmentShader: mu.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: mu.equirect_vert,
                fragmentShader: mu.equirect_frag
            },
            distanceRGBA: {
                uniforms: tr([gu.common, gu.displacementmap, {
                    referencePosition: {
                        value: new Zt
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: mu.distanceRGBA_vert,
                fragmentShader: mu.distanceRGBA_frag
            },
            shadow: {
                uniforms: tr([gu.lights, gu.fog, {
                    color: {
                        value: new wi(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: mu.shadow_vert,
                fragmentShader: mu.shadow_frag
            }
        };
        Au.physical = {
            uniforms: tr([Au.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Et
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Et
                },
                clearcoatNormalScale: {
                    value: new St(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Et
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Et
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Et
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new wi(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Et
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Et
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Et
                },
                transmissionSamplerSize: {
                    value: new St
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Et
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new wi(0)
                },
                specularColor: {
                    value: new wi(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Et
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Et
                },
                anisotropyVector: {
                    value: new St
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Et
                }
            }]),
            vertexShader: mu.meshphysical_vert,
            fragmentShader: mu.meshphysical_frag
        };
        const _u = {
            r: 0,
            b: 0,
            g: 0
        }
          , vu = new Fn
          , wu = new Cn;
        function yu(e, t, n, i, r, a, s) {
            const o = new wi(0);
            let l, c, h = !0 === a ? 0 : 1, d = null, u = 0, f = null;
            function p(e) {
                let i = !0 === e.isScene ? e.background : null;
                if (i && i.isTexture) {
                    i = (e.backgroundBlurriness > 0 ? n : t).get(i)
                }
                return i
            }
            function m(t, n) {
                t.getRGB(_u, nr(e)),
                i.buffers.color.setClear(_u.r, _u.g, _u.b, n, s)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(e, t=1) {
                    o.set(e),
                    h = t,
                    m(o, h)
                },
                getClearAlpha: function() {
                    return h
                },
                setClearAlpha: function(e) {
                    h = e,
                    m(o, h)
                },
                render: function(t) {
                    let n = !1;
                    const r = p(t);
                    null === r ? m(o, h) : r && r.isColor && (m(r, 1),
                    n = !0);
                    const a = e.xr.getEnvironmentBlendMode();
                    "additive" === a ? i.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === a && i.buffers.color.setClear(0, 0, 0, 0, s),
                    (e.autoClear || n) && (i.buffers.depth.setTest(!0),
                    i.buffers.depth.setMask(!0),
                    i.buffers.color.setMask(!0),
                    e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                },
                addToRenderList: function(t, n) {
                    const i = p(n);
                    i && (i.isCubeTexture || i.mapping === N) ? (void 0 === c && (c = new Zi(new $i(1,1,1),new rr({
                        name: "BackgroundCubeMaterial",
                        uniforms: er(Au.backgroundCube.uniforms),
                        vertexShader: Au.backgroundCube.vertexShader,
                        fragmentShader: Au.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    c.geometry.deleteAttribute("normal"),
                    c.geometry.deleteAttribute("uv"),
                    c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    r.update(c)),
                    vu.copy(n.backgroundRotation),
                    vu.x *= -1,
                    vu.y *= -1,
                    vu.z *= -1,
                    i.isCubeTexture && !1 === i.isRenderTargetTexture && (vu.y *= -1,
                    vu.z *= -1),
                    c.material.uniforms.envMap.value = i,
                    c.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                    c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness,
                    c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                    c.material.uniforms.backgroundRotation.value.setFromMatrix4(wu.makeRotationFromEuler(vu)),
                    c.material.toneMapped = Ut.getTransfer(i.colorSpace) !== Je,
                    d === i && u === i.version && f === e.toneMapping || (c.material.needsUpdate = !0,
                    d = i,
                    u = i.version,
                    f = e.toneMapping),
                    c.layers.enableAll(),
                    t.unshift(c, c.geometry, c.material, 0, 0, null)) : i && i.isTexture && (void 0 === l && (l = new Zi(new ya(2,2),new rr({
                        name: "BackgroundMaterial",
                        uniforms: er(Au.background.uniforms),
                        vertexShader: Au.background.vertexShader,
                        fragmentShader: Au.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    r.update(l)),
                    l.material.uniforms.t2D.value = i,
                    l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                    l.material.toneMapped = Ut.getTransfer(i.colorSpace) !== Je,
                    !0 === i.matrixAutoUpdate && i.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(i.matrix),
                    d === i && u === i.version && f === e.toneMapping || (l.material.needsUpdate = !0,
                    d = i,
                    u = i.version,
                    f = e.toneMapping),
                    l.layers.enableAll(),
                    t.unshift(l, l.geometry, l.material, 0, 0, null))
                },
                dispose: function() {
                    void 0 !== c && (c.geometry.dispose(),
                    c.material.dispose(),
                    c = void 0),
                    void 0 !== l && (l.geometry.dispose(),
                    l.material.dispose(),
                    l = void 0)
                }
            }
        }
        function xu(e, t) {
            const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , i = {}
              , r = c(null);
            let a = r
              , s = !1;
            function o(t) {
                return e.bindVertexArray(t)
            }
            function l(t) {
                return e.deleteVertexArray(t)
            }
            function c(e) {
                const t = []
                  , i = []
                  , r = [];
                for (let e = 0; e < n; e++)
                    t[e] = 0,
                    i[e] = 0,
                    r[e] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: i,
                    attributeDivisors: r,
                    object: e,
                    attributes: {},
                    index: null
                }
            }
            function h() {
                const e = a.newAttributes;
                for (let t = 0, n = e.length; t < n; t++)
                    e[t] = 0
            }
            function d(e) {
                u(e, 0)
            }
            function u(t, n) {
                const i = a.newAttributes
                  , r = a.enabledAttributes
                  , s = a.attributeDivisors;
                i[t] = 1,
                0 === r[t] && (e.enableVertexAttribArray(t),
                r[t] = 1),
                s[t] !== n && (e.vertexAttribDivisor(t, n),
                s[t] = n)
            }
            function f() {
                const t = a.newAttributes
                  , n = a.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== t[i] && (e.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function p(t, n, i, r, a, s, o) {
                !0 === o ? e.vertexAttribIPointer(t, n, i, a, s) : e.vertexAttribPointer(t, n, i, r, a, s)
            }
            function m() {
                g(),
                s = !0,
                a !== r && (a = r,
                o(a.object))
            }
            function g() {
                r.geometry = null,
                r.program = null,
                r.wireframe = !1
            }
            return {
                setup: function(n, r, l, m, g) {
                    let A = !1;
                    const _ = function(t, n, r) {
                        const a = !0 === r.wireframe;
                        let s = i[t.id];
                        void 0 === s && (s = {},
                        i[t.id] = s);
                        let o = s[n.id];
                        void 0 === o && (o = {},
                        s[n.id] = o);
                        let l = o[a];
                        void 0 === l && (l = c(e.createVertexArray()),
                        o[a] = l);
                        return l
                    }(m, l, r);
                    a !== _ && (a = _,
                    o(a.object)),
                    A = function(e, t, n, i) {
                        const r = a.attributes
                          , s = t.attributes;
                        let o = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                const n = r[t];
                                let i = s[t];
                                if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                                "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                                void 0 === n)
                                    return !0;
                                if (n.attribute !== i)
                                    return !0;
                                if (i && n.data !== i.data)
                                    return !0;
                                o++
                            }
                        }
                        return a.attributesNum !== o || a.index !== i
                    }(n, m, l, g),
                    A && function(e, t, n, i) {
                        const r = {}
                          , s = t.attributes;
                        let o = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                let n = s[t];
                                void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                const i = {};
                                i.attribute = n,
                                n && n.data && (i.data = n.data),
                                r[t] = i,
                                o++
                            }
                        }
                        a.attributes = r,
                        a.attributesNum = o,
                        a.index = i
                    }(n, m, l, g),
                    null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
                    (A || s) && (s = !1,
                    function(n, i, r, a) {
                        h();
                        const s = a.attributes
                          , o = r.getAttributes()
                          , l = i.defaultAttributeValues;
                        for (const i in o) {
                            const r = o[i];
                            if (r.location >= 0) {
                                let o = s[i];
                                if (void 0 === o && ("instanceMatrix" === i && n.instanceMatrix && (o = n.instanceMatrix),
                                "instanceColor" === i && n.instanceColor && (o = n.instanceColor)),
                                void 0 !== o) {
                                    const i = o.normalized
                                      , s = o.itemSize
                                      , l = t.get(o);
                                    if (void 0 === l)
                                        continue;
                                    const c = l.buffer
                                      , h = l.type
                                      , f = l.bytesPerElement
                                      , m = h === e.INT || h === e.UNSIGNED_INT || o.gpuType === K;
                                    if (o.isInterleavedBufferAttribute) {
                                        const t = o.data
                                          , l = t.stride
                                          , g = o.offset;
                                        if (t.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < r.locationSize; e++)
                                                u(r.location + e, t.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++)
                                                d(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++)
                                            p(r.location + e, s / r.locationSize, h, i, l * f, (g + s / r.locationSize * e) * f, m)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let e = 0; e < r.locationSize; e++)
                                                u(r.location + e, o.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++)
                                                d(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++)
                                            p(r.location + e, s / r.locationSize, h, i, s * f, s / r.locationSize * e * f, m)
                                    }
                                } else if (void 0 !== l) {
                                    const t = l[i];
                                    if (void 0 !== t)
                                        switch (t.length) {
                                        case 2:
                                            e.vertexAttrib2fv(r.location, t);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(r.location, t);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(r.location, t);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(r.location, t)
                                        }
                                }
                            }
                        }
                        f()
                    }(n, r, l, m),
                    null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
                },
                reset: m,
                resetDefaultState: g,
                dispose: function() {
                    m();
                    for (const e in i) {
                        const t = i[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                l(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete i[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === i[e.id])
                        return;
                    const t = i[e.id];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n)
                            l(n[e].object),
                            delete n[e];
                        delete t[e]
                    }
                    delete i[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in i) {
                        const n = i[t];
                        if (void 0 === n[e.id])
                            continue;
                        const r = n[e.id];
                        for (const e in r)
                            l(r[e].object),
                            delete r[e];
                        delete n[e.id]
                    }
                },
                initAttributes: h,
                enableAttribute: d,
                disableUnusedAttributes: f
            }
        }
        function bu(e, t, n) {
            let i;
            function r(t, r, a) {
                0 !== a && (e.drawArraysInstanced(i, t, r, a),
                n.update(r, i, a))
            }
            this.setMode = function(e) {
                i = e
            }
            ,
            this.render = function(t, r) {
                e.drawArrays(i, t, r),
                n.update(r, i, 1)
            }
            ,
            this.renderInstances = r,
            this.renderMultiDraw = function(e, r, a) {
                if (0 === a)
                    return;
                t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, a);
                let s = 0;
                for (let e = 0; e < a; e++)
                    s += r[e];
                n.update(s, i, 1)
            }
            ,
            this.renderMultiDrawInstances = function(e, a, s, o) {
                if (0 === s)
                    return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < e.length; t++)
                        r(e[t], a[t], o[t]);
                else {
                    l.multiDrawArraysInstancedWEBGL(i, e, 0, a, 0, o, 0, s);
                    let t = 0;
                    for (let e = 0; e < s; e++)
                        t += a[e] * o[e];
                    n.update(t, i, 1)
                }
            }
        }
        function Su(e, t, n, i) {
            let r;
            function a(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                        return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            let s = void 0 !== n.precision ? n.precision : "highp";
            const o = a(s);
            o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."),
            s = o);
            const l = !0 === n.logarithmicDepthBuffer
              , c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control")
              , h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
              , d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            return {
                isWebGL2: !0,
                getMaxAnisotropy: function() {
                    if (void 0 !== r)
                        return r;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        r = 0;
                    return r
                },
                getMaxPrecision: a,
                textureFormatReadable: function(t) {
                    return t === re || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                },
                textureTypeReadable: function(n) {
                    const r = n === $ && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                    return !(n !== X && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== J && !r)
                },
                precision: s,
                logarithmicDepthBuffer: l,
                reverseDepthBuffer: c,
                maxTextures: h,
                maxVertexTextures: d,
                maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                vertexTextures: d > 0,
                maxSamples: e.getParameter(e.MAX_SAMPLES)
            }
        }
        function Eu(e) {
            const t = this;
            let n = null
              , i = 0
              , r = !1
              , a = !1;
            const s = new Yr
              , o = new Et
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c(e, n, i, r) {
                const a = null !== e ? e.length : 0;
                let c = null;
                if (0 !== a) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const t = i + 4 * a
                          , r = n.matrixWorldInverse;
                        o.getNormalMatrix(r),
                        (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let t = 0, n = i; t !== a; ++t,
                        n += 4)
                            s.copy(e[t]).applyMatrix4(r, o),
                            s.normal.toArray(c, n),
                            c[n + 3] = s.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return t.numPlanes = a,
                t.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== i || r;
                return r = t,
                i = e.length,
                n
            }
            ,
            this.beginShadows = function() {
                a = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                a = !1
            }
            ,
            this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }
            ,
            this.setState = function(s, o, h) {
                const d = s.clippingPlanes
                  , u = s.clipIntersection
                  , f = s.clipShadows
                  , p = e.get(s);
                if (!r || null === d || 0 === d.length || a && !f)
                    a ? c(null) : function() {
                        l.value !== n && (l.value = n,
                        l.needsUpdate = i > 0);
                        t.numPlanes = i,
                        t.numIntersection = 0
                    }();
                else {
                    const e = a ? 0 : i
                      , t = 4 * e;
                    let r = p.clippingState || null;
                    l.value = r,
                    r = c(d, o, t, h);
                    for (let e = 0; e !== t; ++e)
                        r[e] = n[e];
                    p.clippingState = r,
                    this.numIntersection = u ? this.numPlanes : 0,
                    this.numPlanes += e
                }
            }
        }
        function Mu(e) {
            let t = new WeakMap;
            function n(e, t) {
                return t === L ? e.mapping = B : t === U && (e.mapping = D),
                e
            }
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const a = r.mapping;
                        if (a === L || a === U) {
                            if (t.has(r)) {
                                return n(t.get(r).texture, r.mapping)
                            }
                            {
                                const a = r.image;
                                if (a && a.height > 0) {
                                    const s = new fr(a.height);
                                    return s.fromEquirectangularTexture(e, r),
                                    t.set(r, s),
                                    r.addEventListener("dispose", i),
                                    n(s.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        const Tu = [.125, .215, .35, .446, .526, .582]
          , Cu = 20
          , Iu = new fs
          , Ru = new wi;
        let Pu = null
          , Bu = 0
          , Du = 0
          , Lu = !1;
        const Uu = (1 + Math.sqrt(5)) / 2
          , Nu = 1 / Uu
          , ku = [new Zt(-Uu,Nu,0), new Zt(Uu,Nu,0), new Zt(-Nu,0,Uu), new Zt(Nu,0,Uu), new Zt(0,Uu,-Nu), new Zt(0,Uu,Nu), new Zt(-1,1,-1), new Zt(1,1,-1), new Zt(-1,1,1), new Zt(1,1,1)]
          , Fu = new Zt;
        class Ou {
            constructor(e) {
                this._renderer = e,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t=0, n=.1, i=100, r={}) {
                const {size: a=256, position: s=Fu} = r;
                Pu = this._renderer.getRenderTarget(),
                Bu = this._renderer.getActiveCubeFace(),
                Du = this._renderer.getActiveMipmapLevel(),
                Lu = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1,
                this._setSize(a);
                const o = this._allocateTargets();
                return o.depthBuffer = !0,
                this._sceneToCubeUV(e, n, i, o, s),
                t > 0 && this._blur(o, 0, 0, t),
                this._applyPMREM(o),
                this._cleanup(o),
                o
            }
            fromEquirectangular(e, t=null) {
                return this._fromTexture(e, t)
            }
            fromCubemap(e, t=null) {
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Vu(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = Wu(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(Pu, Bu, Du),
                this._renderer.xr.enabled = Lu,
                e.scissorTest = !1,
                Hu(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === B || e.mapping === D ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                Pu = this._renderer.getRenderTarget(),
                Bu = this._renderer.getActiveCubeFace(),
                Du = this._renderer.getActiveMipmapLevel(),
                Lu = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1;
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112)
                  , t = 4 * this._cubeSize
                  , n = {
                    magFilter: V,
                    minFilter: V,
                    generateMipmaps: !1,
                    type: $,
                    format: re,
                    colorSpace: Ke,
                    depthBuffer: !1
                }
                  , i = zu(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = zu(e, t, n);
                    const {_lodMax: i} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                        const t = []
                          , n = []
                          , i = [];
                        let r = e;
                        const a = e - 4 + 1 + Tu.length;
                        for (let s = 0; s < a; s++) {
                            const a = Math.pow(2, r);
                            n.push(a);
                            let o = 1 / a;
                            s > e - 4 ? o = Tu[s - e + 4 - 1] : 0 === s && (o = 0),
                            i.push(o);
                            const l = 1 / (a - 2)
                              , c = -l
                              , h = 1 + l
                              , d = [c, c, h, c, h, h, c, c, h, h, c, h]
                              , u = 6
                              , f = 6
                              , p = 3
                              , m = 2
                              , g = 1
                              , A = new Float32Array(p * f * u)
                              , _ = new Float32Array(m * f * u)
                              , v = new Float32Array(g * f * u);
                            for (let e = 0; e < u; e++) {
                                const t = e % 3 * 2 / 3 - 1
                                  , n = e > 2 ? 0 : -1
                                  , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                A.set(i, p * f * e),
                                _.set(d, m * f * e);
                                const r = [e, e, e, e, e, e];
                                v.set(r, g * f * e)
                            }
                            const w = new Oi;
                            w.setAttribute("position", new Ci(A,p)),
                            w.setAttribute("uv", new Ci(_,m)),
                            w.setAttribute("faceIndex", new Ci(v,g)),
                            t.push(w),
                            r > 4 && r--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)),
                    this._blurMaterial = function(e, t, n) {
                        const i = new Float32Array(Cu)
                          , r = new Zt(0,1,0)
                          , a = new rr({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: Cu,
                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${e}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: Gu(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        });
                        return a
                    }(i, e, t)
                }
                return i
            }
            _compileMaterial(e) {
                const t = new Zi(this._lodPlanes[0],e);
                this._renderer.compile(t, Iu)
            }
            _sceneToCubeUV(e, t, n, i, r) {
                const a = new cr(90,1,t,n)
                  , s = [1, -1, 1, 1, 1, 1]
                  , o = [1, 1, 1, -1, -1, -1]
                  , l = this._renderer
                  , c = l.autoClear
                  , h = l.toneMapping;
                l.getClearColor(Ru),
                l.toneMapping = 0,
                l.autoClear = !1;
                const d = new Si({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , u = new Zi(new $i,d);
                let f = !1;
                const p = e.background;
                p ? p.isColor && (d.color.copy(p),
                e.background = null,
                f = !0) : (d.color.copy(Ru),
                f = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (a.up.set(0, s[t], 0),
                    a.position.set(r.x, r.y, r.z),
                    a.lookAt(r.x + o[t], r.y, r.z)) : 1 === n ? (a.up.set(0, 0, s[t]),
                    a.position.set(r.x, r.y, r.z),
                    a.lookAt(r.x, r.y + o[t], r.z)) : (a.up.set(0, s[t], 0),
                    a.position.set(r.x, r.y, r.z),
                    a.lookAt(r.x, r.y, r.z + o[t]));
                    const c = this._cubeSize;
                    Hu(i, n * c, t > 2 ? c : 0, c, c),
                    l.setRenderTarget(i),
                    f && l.render(u, a),
                    l.render(e, a)
                }
                u.geometry.dispose(),
                u.material.dispose(),
                l.toneMapping = h,
                l.autoClear = c,
                e.background = p
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer
                  , i = e.mapping === B || e.mapping === D;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Vu()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Wu());
                const r = i ? this._cubemapMaterial : this._equirectMaterial
                  , a = new Zi(this._lodPlanes[0],r);
                r.uniforms.envMap.value = e;
                const s = this._cubeSize;
                Hu(t, 0, 0, 3 * s, 2 * s),
                n.setRenderTarget(t),
                n.render(a, Iu)
            }
            _applyPMREM(e) {
                const t = this._renderer
                  , n = t.autoClear;
                t.autoClear = !1;
                const i = this._lodPlanes.length;
                for (let t = 1; t < i; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                      , r = ku[(i - t - 1) % ku.length];
                    this._blur(e, t - 1, t, n, r)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const a = this._pingPongRenderTarget;
                this._halfBlur(e, a, t, n, i, "latitudinal", r),
                this._halfBlur(a, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, a, s) {
                const o = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new Zi(this._lodPlanes[i],l)
                  , h = l.uniforms
                  , d = this._sizeLods[n] - 1
                  , u = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / 39
                  , f = r / u
                  , p = isFinite(r) ? 1 + Math.floor(3 * f) : Cu;
                p > Cu && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let e = 0; e < Cu; ++e) {
                    const t = e / f
                      , n = Math.exp(-t * t / 2);
                    m.push(n),
                    0 === e ? g += n : e < p && (g += 2 * n)
                }
                for (let e = 0; e < m.length; e++)
                    m[e] = m[e] / g;
                h.envMap.value = e.texture,
                h.samples.value = p,
                h.weights.value = m,
                h.latitudinal.value = "latitudinal" === a,
                s && (h.poleAxis.value = s);
                const {_lodMax: A} = this;
                h.dTheta.value = u,
                h.mipInt.value = A - n;
                const _ = this._sizeLods[i];
                Hu(t, 3 * _ * (i > A - 4 ? i - A + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _),
                o.setRenderTarget(t),
                o.render(c, Iu)
            }
        }
        function zu(e, t, n) {
            const i = new jt(e,t,n);
            return i.texture.mapping = N,
            i.texture.name = "PMREM.cubeUv",
            i.scissorTest = !0,
            i
        }
        function Hu(e, t, n, i, r) {
            e.viewport.set(t, n, i, r),
            e.scissor.set(t, n, i, r)
        }
        function Wu() {
            return new rr({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: Gu(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Vu() {
            return new rr({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: Gu(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Gu() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function Qu(e) {
            let t = new WeakMap
              , n = null;
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const a = r.mapping
                          , s = a === L || a === U
                          , o = a === B || a === D;
                        if (s || o) {
                            let a = t.get(r);
                            const l = void 0 !== a ? a.texture.pmremVersion : 0;
                            if (r.isRenderTargetTexture && r.pmremVersion !== l)
                                return null === n && (n = new Ou(e)),
                                a = s ? n.fromEquirectangular(r, a) : n.fromCubemap(r, a),
                                a.texture.pmremVersion = r.pmremVersion,
                                t.set(r, a),
                                a.texture;
                            if (void 0 !== a)
                                return a.texture;
                            {
                                const l = r.image;
                                return s && l && l.height > 0 || o && l && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++)
                                        void 0 !== e[i] && t++;
                                    return t === n
                                }(l) ? (null === n && (n = new Ou(e)),
                                a = s ? n.fromEquirectangular(r) : n.fromCubemap(r),
                                a.texture.pmremVersion = r.pmremVersion,
                                t.set(r, a),
                                r.addEventListener("dispose", i),
                                a.texture) : null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function Xu(e) {
            const t = {};
            function n(n) {
                if (void 0 !== t[n])
                    return t[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
                }
                return t[n] = i,
                i
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function() {
                    n("EXT_color_buffer_float"),
                    n("WEBGL_clip_cull_distance"),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture"),
                    n("WEBGL_render_shared_exponent")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && Pt("THREE.WebGLRenderer: " + e + " extension not supported."),
                    t
                }
            }
        }
        function ju(e, t, n, i) {
            const r = {}
              , a = new WeakMap;
            function s(e) {
                const o = e.target;
                null !== o.index && t.remove(o.index);
                for (const e in o.attributes)
                    t.remove(o.attributes[e]);
                o.removeEventListener("dispose", s),
                delete r[o.id];
                const l = a.get(o);
                l && (t.remove(l),
                a.delete(o)),
                i.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                n.memory.geometries--
            }
            function o(e) {
                const n = []
                  , i = e.index
                  , r = e.attributes.position;
                let s = 0;
                if (null !== i) {
                    const e = i.array;
                    s = i.version;
                    for (let t = 0, i = e.length; t < i; t += 3) {
                        const i = e[t + 0]
                          , r = e[t + 1]
                          , a = e[t + 2];
                        n.push(i, r, r, a, a, i)
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const e = r.array;
                        s = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0
                              , i = t + 1
                              , r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                }
                const o = new (Tt(n) ? Ri : Ii)(n,1);
                o.version = s;
                const l = a.get(e);
                l && t.remove(l),
                a.set(e, o)
            }
            return {
                get: function(e, t) {
                    return !0 === r[t.id] || (t.addEventListener("dispose", s),
                    r[t.id] = !0,
                    n.memory.geometries++),
                    t
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i)
                        t.update(i[n], e.ARRAY_BUFFER)
                },
                getWireframeAttribute: function(e) {
                    const t = a.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && o(e)
                    } else
                        o(e);
                    return a.get(e)
                }
            }
        }
        function qu(e, t, n) {
            let i, r, a;
            function s(t, s, o) {
                0 !== o && (e.drawElementsInstanced(i, s, r, t * a, o),
                n.update(s, i, o))
            }
            this.setMode = function(e) {
                i = e
            }
            ,
            this.setIndex = function(e) {
                r = e.type,
                a = e.bytesPerElement
            }
            ,
            this.render = function(t, s) {
                e.drawElements(i, s, r, t * a),
                n.update(s, i, 1)
            }
            ,
            this.renderInstances = s,
            this.renderMultiDraw = function(e, a, s) {
                if (0 === s)
                    return;
                t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, a, 0, r, e, 0, s);
                let o = 0;
                for (let e = 0; e < s; e++)
                    o += a[e];
                n.update(o, i, 1)
            }
            ,
            this.renderMultiDrawInstances = function(e, o, l, c) {
                if (0 === l)
                    return;
                const h = t.get("WEBGL_multi_draw");
                if (null === h)
                    for (let t = 0; t < e.length; t++)
                        s(e[t] / a, o[t], c[t]);
                else {
                    h.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
                    let t = 0;
                    for (let e = 0; e < l; e++)
                        t += o[e] * c[e];
                    n.update(t, i, 1)
                }
            }
        }
        function Yu(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0,
                    t.triangles = 0,
                    t.points = 0,
                    t.lines = 0
                },
                update: function(n, i, r) {
                    switch (t.calls++,
                    i) {
                    case e.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case e.POINTS:
                        t.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }
        function Ku(e, t, n) {
            const i = new WeakMap
              , r = new Qt;
            return {
                update: function(a, s, o) {
                    const l = a.morphTargetInfluences
                      , c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color
                      , h = void 0 !== c ? c.length : 0;
                    let d = i.get(s);
                    if (void 0 === d || d.count !== h) {
                        void 0 !== d && d.texture.dispose();
                        const u = void 0 !== s.morphAttributes.position
                          , f = void 0 !== s.morphAttributes.normal
                          , p = void 0 !== s.morphAttributes.color
                          , m = s.morphAttributes.position || []
                          , g = s.morphAttributes.normal || []
                          , A = s.morphAttributes.color || [];
                        let _ = 0;
                        !0 === u && (_ = 1),
                        !0 === f && (_ = 2),
                        !0 === p && (_ = 3);
                        let v = s.attributes.position.count * _
                          , w = 1;
                        v > t.maxTextureSize && (w = Math.ceil(v / t.maxTextureSize),
                        v = t.maxTextureSize);
                        const y = new Float32Array(v * w * 4 * h)
                          , x = new qt(y,v,w,h);
                        x.type = J,
                        x.needsUpdate = !0;
                        const b = 4 * _;
                        for (let E = 0; E < h; E++) {
                            const M = m[E]
                              , T = g[E]
                              , C = A[E]
                              , I = v * w * 4 * E;
                            for (let R = 0; R < M.count; R++) {
                                const P = R * b;
                                !0 === u && (r.fromBufferAttribute(M, R),
                                y[I + P + 0] = r.x,
                                y[I + P + 1] = r.y,
                                y[I + P + 2] = r.z,
                                y[I + P + 3] = 0),
                                !0 === f && (r.fromBufferAttribute(T, R),
                                y[I + P + 4] = r.x,
                                y[I + P + 5] = r.y,
                                y[I + P + 6] = r.z,
                                y[I + P + 7] = 0),
                                !0 === p && (r.fromBufferAttribute(C, R),
                                y[I + P + 8] = r.x,
                                y[I + P + 9] = r.y,
                                y[I + P + 10] = r.z,
                                y[I + P + 11] = 4 === C.itemSize ? r.w : 1)
                            }
                        }
                        function S() {
                            x.dispose(),
                            i.delete(s),
                            s.removeEventListener("dispose", S)
                        }
                        d = {
                            count: h,
                            texture: x,
                            size: new St(v,w)
                        },
                        i.set(s, d),
                        s.addEventListener("dispose", S)
                    }
                    if (!0 === a.isInstancedMesh && null !== a.morphTexture)
                        o.getUniforms().setValue(e, "morphTexture", a.morphTexture, n);
                    else {
                        let B = 0;
                        for (let L = 0; L < l.length; L++)
                            B += l[L];
                        const D = s.morphTargetsRelative ? 1 : 1 - B;
                        o.getUniforms().setValue(e, "morphTargetBaseInfluence", D),
                        o.getUniforms().setValue(e, "morphTargetInfluences", l)
                    }
                    o.getUniforms().setValue(e, "morphTargetsTexture", d.texture, n),
                    o.getUniforms().setValue(e, "morphTargetsTextureSize", d.size)
                }
            }
        }
        function Zu(e, t, n, i) {
            let r = new WeakMap;
            function a(e) {
                const t = e.target;
                t.removeEventListener("dispose", a),
                n.remove(t.instanceMatrix),
                null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(s) {
                    const o = i.render.frame
                      , l = s.geometry
                      , c = t.get(s, l);
                    if (r.get(c) !== o && (t.update(c),
                    r.set(c, o)),
                    s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a),
                    r.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER),
                    null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER),
                    r.set(s, o))),
                    s.isSkinnedMesh) {
                        const e = s.skeleton;
                        r.get(e) !== o && (e.update(),
                        r.set(e, o))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        const Ju = new Gt
          , $u = new wa(1,1)
          , ef = new qt
          , tf = new Yt
          , nf = new ur
          , rf = []
          , af = []
          , sf = new Float32Array(16)
          , of = new Float32Array(9)
          , lf = new Float32Array(4);
        function cf(e, t, n) {
            const i = e[0];
            if (i <= 0 || i > 0)
                return e;
            const r = t * n;
            let a = rf[r];
            if (void 0 === a && (a = new Float32Array(r),
            rf[r] = a),
            0 !== t) {
                i.toArray(a, 0);
                for (let i = 1, r = 0; i !== t; ++i)
                    r += n,
                    e[i].toArray(a, r)
            }
            return a
        }
        function hf(e, t) {
            if (e.length !== t.length)
                return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        }
        function df(e, t) {
            for (let n = 0, i = t.length; n < i; n++)
                e[n] = t[n]
        }
        function uf(e, t) {
            let n = af[t];
            void 0 === n && (n = new Int32Array(t),
            af[t] = n);
            for (let i = 0; i !== t; ++i)
                n[i] = e.allocateTextureUnit();
            return n
        }
        function ff(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t),
            n[0] = t)
        }
        function pf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                e.uniform2fv(this.addr, t),
                df(n, t)
            }
        }
        function mf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else if (void 0 !== t.r)
                n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                n[0] = t.r,
                n[1] = t.g,
                n[2] = t.b);
            else {
                if (hf(n, t))
                    return;
                e.uniform3fv(this.addr, t),
                df(n, t)
            }
        }
        function gf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                e.uniform4fv(this.addr, t),
                df(n, t)
            }
        }
        function Af(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                e.uniformMatrix2fv(this.addr, !1, t),
                df(n, t)
            } else {
                if (hf(n, i))
                    return;
                lf.set(i),
                e.uniformMatrix2fv(this.addr, !1, lf),
                df(n, i)
            }
        }
        function _f(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                e.uniformMatrix3fv(this.addr, !1, t),
                df(n, t)
            } else {
                if (hf(n, i))
                    return;
                of.set(i),
                e.uniformMatrix3fv(this.addr, !1, of),
                df(n, i)
            }
        }
        function vf(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                e.uniformMatrix4fv(this.addr, !1, t),
                df(n, t)
            } else {
                if (hf(n, i))
                    return;
                sf.set(i),
                e.uniformMatrix4fv(this.addr, !1, sf),
                df(n, i)
            }
        }
        function wf(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t),
            n[0] = t)
        }
        function yf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                e.uniform2iv(this.addr, t),
                df(n, t)
            }
        }
        function xf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (hf(n, t))
                    return;
                e.uniform3iv(this.addr, t),
                df(n, t)
            }
        }
        function bf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                e.uniform4iv(this.addr, t),
                df(n, t)
            }
        }
        function Sf(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t),
            n[0] = t)
        }
        function Ef(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                e.uniform2uiv(this.addr, t),
                df(n, t)
            }
        }
        function Mf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (hf(n, t))
                    return;
                e.uniform3uiv(this.addr, t),
                df(n, t)
            }
        }
        function Tf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                e.uniform4uiv(this.addr, t),
                df(n, t)
            }
        }
        function Cf(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            let a;
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            this.type === e.SAMPLER_2D_SHADOW ? ($u.compareFunction = 515,
            a = $u) : a = Ju,
            n.setTexture2D(t || a, r)
        }
        function If(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(t || tf, r)
        }
        function Rf(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTextureCube(t || nf, r)
        }
        function Pf(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(t || ef, r)
        }
        function Bf(e, t) {
            e.uniform1fv(this.addr, t)
        }
        function Df(e, t) {
            const n = cf(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }
        function Lf(e, t) {
            const n = cf(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }
        function Uf(e, t) {
            const n = cf(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }
        function Nf(e, t) {
            const n = cf(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }
        function kf(e, t) {
            const n = cf(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }
        function Ff(e, t) {
            const n = cf(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }
        function Of(e, t) {
            e.uniform1iv(this.addr, t)
        }
        function zf(e, t) {
            e.uniform2iv(this.addr, t)
        }
        function Hf(e, t) {
            e.uniform3iv(this.addr, t)
        }
        function Wf(e, t) {
            e.uniform4iv(this.addr, t)
        }
        function Vf(e, t) {
            e.uniform1uiv(this.addr, t)
        }
        function Gf(e, t) {
            e.uniform2uiv(this.addr, t)
        }
        function Qf(e, t) {
            e.uniform3uiv(this.addr, t)
        }
        function Xf(e, t) {
            e.uniform4uiv(this.addr, t)
        }
        function jf(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = uf(n, r);
            hf(i, a) || (e.uniform1iv(this.addr, a),
            df(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture2D(t[e] || Ju, a[e])
        }
        function qf(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = uf(n, r);
            hf(i, a) || (e.uniform1iv(this.addr, a),
            df(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture3D(t[e] || tf, a[e])
        }
        function Yf(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = uf(n, r);
            hf(i, a) || (e.uniform1iv(this.addr, a),
            df(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTextureCube(t[e] || nf, a[e])
        }
        function Kf(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = uf(n, r);
            hf(i, a) || (e.uniform1iv(this.addr, a),
            df(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture2DArray(t[e] || ef, a[e])
        }
        class Zf {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return ff;
                    case 35664:
                        return pf;
                    case 35665:
                        return mf;
                    case 35666:
                        return gf;
                    case 35674:
                        return Af;
                    case 35675:
                        return _f;
                    case 35676:
                        return vf;
                    case 5124:
                    case 35670:
                        return wf;
                    case 35667:
                    case 35671:
                        return yf;
                    case 35668:
                    case 35672:
                        return xf;
                    case 35669:
                    case 35673:
                        return bf;
                    case 5125:
                        return Sf;
                    case 36294:
                        return Ef;
                    case 36295:
                        return Mf;
                    case 36296:
                        return Tf;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Cf;
                    case 35679:
                    case 36299:
                    case 36307:
                        return If;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Rf;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Pf
                    }
                }(t.type)
            }
        }
        class Jf {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.size = t.size,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return Bf;
                    case 35664:
                        return Df;
                    case 35665:
                        return Lf;
                    case 35666:
                        return Uf;
                    case 35674:
                        return Nf;
                    case 35675:
                        return kf;
                    case 35676:
                        return Ff;
                    case 5124:
                    case 35670:
                        return Of;
                    case 35667:
                    case 35671:
                        return zf;
                    case 35668:
                    case 35672:
                        return Hf;
                    case 35669:
                    case 35673:
                        return Wf;
                    case 5125:
                        return Vf;
                    case 36294:
                        return Gf;
                    case 36295:
                        return Qf;
                    case 36296:
                        return Xf;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return jf;
                    case 35679:
                    case 36299:
                    case 36307:
                        return qf;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Yf;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Kf
                    }
                }(t.type)
            }
        }
        class $f {
            constructor(e) {
                this.id = e,
                this.seq = [],
                this.map = {}
            }
            setValue(e, t, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(e, t[a.id], n)
                }
            }
        }
        const ep = /(\w+)(\])?(\[|\.)?/g;
        function tp(e, t) {
            e.seq.push(t),
            e.map[t.id] = t
        }
        function np(e, t, n) {
            const i = e.name
              , r = i.length;
            for (ep.lastIndex = 0; ; ) {
                const a = ep.exec(i)
                  , s = ep.lastIndex;
                let o = a[1];
                const l = "]" === a[2]
                  , c = a[3];
                if (l && (o |= 0),
                void 0 === c || "[" === c && s + 2 === r) {
                    tp(n, void 0 === c ? new Zf(o,e,t) : new Jf(o,e,t));
                    break
                }
                {
                    let e = n.map[o];
                    void 0 === e && (e = new $f(o),
                    tp(n, e)),
                    n = e
                }
            }
        }
        class ip {
            constructor(e, t) {
                this.seq = [],
                this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    np(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }
            setOptional(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }
            static upload(e, t, n, i) {
                for (let r = 0, a = t.length; r !== a; ++r) {
                    const a = t[r]
                      , s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, i)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            }
        }
        function rp(e, t, n) {
            const i = e.createShader(t);
            return e.shaderSource(i, n),
            e.compileShader(i),
            i
        }
        let ap = 0;
        const sp = new Et;
        function op(e, t, n) {
            const i = e.getShaderParameter(t, e.COMPILE_STATUS)
              , r = e.getShaderInfoLog(t).trim();
            if (i && "" === r)
                return "";
            const a = /ERROR: 0:(\d+)/.exec(r);
            if (a) {
                const i = parseInt(a[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                    const n = e.split("\n")
                      , i = []
                      , r = Math.max(t - 6, 0)
                      , a = Math.min(t + 6, n.length);
                    for (let e = r; e < a; e++) {
                        const r = e + 1;
                        i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
                    }
                    return i.join("\n")
                }(e.getShaderSource(t), i)
            }
            return r
        }
        function lp(e, t) {
            const n = function(e) {
                Ut._getMatrix(sp, Ut.workingColorSpace, e);
                const t = `mat3( ${sp.elements.map((e => e.toFixed(4)))} )`;
                switch (Ut.getTransfer(e)) {
                case Ze:
                    return [t, "LinearTransferOETF"];
                case Je:
                    return [t, "sRGBTransferOETF"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space: ", e),
                    [t, "LinearTransferOETF"]
                }
            }(t);
            return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
        }
        function cp(e, t) {
            let n;
            switch (t) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "Cineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 6:
                n = "AgX";
                break;
            case 7:
                n = "Neutral";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        const hp = new Zt;
        function dp() {
            Ut.getLuminanceCoefficients(hp);
            return ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${hp.x.toFixed(4)}, ${hp.y.toFixed(4)}, ${hp.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")
        }
        function up(e) {
            return "" !== e
        }
        function fp(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }
        function pp(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const mp = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function gp(e) {
            return e.replace(mp, _p)
        }
        const Ap = new Map;
        function _p(e, t) {
            let n = mu[t];
            if (void 0 === n) {
                const e = Ap.get(t);
                if (void 0 === e)
                    throw new Error("Can not resolve #include <" + t + ">");
                n = mu[e],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return gp(n)
        }
        const vp = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function wp(e) {
            return e.replace(vp, yp)
        }
        function yp(e, t, n, i) {
            let r = "";
            for (let e = parseInt(t); e < parseInt(n); e++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return r
        }
        function xp(e) {
            let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
            t
        }
        function bp(e, t, n, i) {
            const r = e.getContext()
              , a = n.defines;
            let s = n.vertexShader
              , o = n.fragmentShader;
            const l = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
                t
            }(n)
              , c = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap)
                    switch (e.envMapMode) {
                    case B:
                    case D:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case N:
                        t = "ENVMAP_TYPE_CUBE_UV"
                    }
                return t
            }(n)
              , h = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                e.envMap && e.envMapMode === D && (t = "ENVMAP_MODE_REFRACTION");
                return t
            }(n)
              , d = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap)
                    switch (e.combine) {
                    case 0:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        t = "ENVMAP_BLENDING_ADD"
                    }
                return t
            }(n)
              , u = function(e) {
                const t = e.envMapCubeUVHeight;
                if (null === t)
                    return null;
                const n = Math.log2(t) - 2
                  , i = 1 / t;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n)
              , f = function(e) {
                return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(up).join("\n")
            }(n)
              , p = function(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    !1 !== i && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }(a)
              , m = r.createProgram();
            let g, A, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p].filter(up).join("\n"),
            g.length > 0 && (g += "\n"),
            A = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p].filter(up).join("\n"),
            A.length > 0 && (A += "\n")) : (g = [xp(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(up).join("\n"),
            A = [xp(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? mu.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? cp("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", mu.colorspace_pars_fragment, lp("linearToOutputTexel", n.outputColorSpace), dp(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(up).join("\n")),
            s = gp(s),
            s = fp(s, n),
            s = pp(s, n),
            o = gp(o),
            o = fp(o, n),
            o = pp(o, n),
            s = wp(s),
            o = wp(o),
            !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n",
            g = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            A = ["#define varying in", n.glslVersion === ct ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === ct ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + A);
            const v = _ + g + s
              , w = _ + A + o
              , y = rp(r, r.VERTEX_SHADER, v)
              , x = rp(r, r.FRAGMENT_SHADER, w);
            function b(t) {
                if (e.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(m).trim()
                      , i = r.getShaderInfoLog(y).trim()
                      , a = r.getShaderInfoLog(x).trim();
                    let s = !0
                      , o = !0;
                    if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                        if (s = !1,
                        "function" == typeof e.debug.onShaderError)
                            e.debug.onShaderError(r, m, y, x);
                        else {
                            const e = op(r, y, "vertex")
                              , i = op(r, x, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + i)
                        }
                    else
                        "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== a || (o = !1);
                    o && (t.diagnostics = {
                        runnable: s,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: g
                        },
                        fragmentShader: {
                            log: a,
                            prefix: A
                        }
                    })
                }
                r.deleteShader(y),
                r.deleteShader(x),
                S = new ip(r,m),
                E = function(e, t) {
                    const n = {}
                      , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = e.getActiveAttrib(t, r)
                          , a = i.name;
                        let s = 1;
                        i.type === e.FLOAT_MAT2 && (s = 2),
                        i.type === e.FLOAT_MAT3 && (s = 3),
                        i.type === e.FLOAT_MAT4 && (s = 4),
                        n[a] = {
                            type: i.type,
                            location: e.getAttribLocation(t, a),
                            locationSize: s
                        }
                    }
                    return n
                }(r, m)
            }
            let S, E;
            r.attachShader(m, y),
            r.attachShader(m, x),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            this.getUniforms = function() {
                return void 0 === S && b(this),
                S
            }
            ,
            this.getAttributes = function() {
                return void 0 === E && b(this),
                E
            }
            ;
            let M = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === M && (M = r.getProgramParameter(m, 37297)),
                M
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = ap++,
            this.cacheKey = t,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = y,
            this.fragmentShader = x,
            this
        }
        let Sp = 0;
        class Ep {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader
                  , n = e.fragmentShader
                  , i = this._getShaderStage(t)
                  , r = this._getShaderStage(n)
                  , a = this._getShaderCacheForMaterial(e);
                return !1 === a.has(i) && (a.add(i),
                i.usedTimes++),
                !1 === a.has(r) && (a.add(r),
                r.usedTimes++),
                this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const e of t)
                    e.usedTimes--,
                    0 === e.usedTimes && this.shaderCache.delete(e.code);
                return this.materialCache.delete(e),
                this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set,
                t.set(e, n)),
                n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new Mp(e),
                t.set(e, n)),
                n
            }
        }
        class Mp {
            constructor(e) {
                this.id = Sp++,
                this.code = e,
                this.usedTimes = 0
            }
        }
        function Tp(e, t, n, i, r, a, s) {
            const o = new On
              , l = new Ep
              , c = new Set
              , h = []
              , d = r.logarithmicDepthBuffer
              , u = r.vertexTextures;
            let f = r.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function m(e) {
                return c.add(e),
                0 === e ? "uv" : `uv${e}`
            }
            return {
                getParameters: function(a, o, h, g, A) {
                    const _ = g.fog
                      , v = A.geometry
                      , w = a.isMeshStandardMaterial ? g.environment : null
                      , y = (a.isMeshStandardMaterial ? n : t).get(a.envMap || w)
                      , x = y && y.mapping === N ? y.image.height : null
                      , b = p[a.type];
                    null !== a.precision && (f = r.getMaxPrecision(a.precision),
                    f !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead."));
                    const S = v.morphAttributes.position || v.morphAttributes.normal || v.morphAttributes.color
                      , E = void 0 !== S ? S.length : 0;
                    let M, T, C, I, R = 0;
                    if (void 0 !== v.morphAttributes.position && (R = 1),
                    void 0 !== v.morphAttributes.normal && (R = 2),
                    void 0 !== v.morphAttributes.color && (R = 3),
                    b) {
                        const e = Au[b];
                        M = e.vertexShader,
                        T = e.fragmentShader
                    } else
                        M = a.vertexShader,
                        T = a.fragmentShader,
                        l.update(a),
                        C = l.getVertexShaderID(a),
                        I = l.getFragmentShaderID(a);
                    const P = e.getRenderTarget()
                      , B = e.state.buffers.depth.getReversed()
                      , D = !0 === A.isInstancedMesh
                      , L = !0 === A.isBatchedMesh
                      , U = !!a.map
                      , k = !!a.matcap
                      , F = !!y
                      , O = !!a.aoMap
                      , z = !!a.lightMap
                      , H = !!a.bumpMap
                      , W = !!a.normalMap
                      , V = !!a.displacementMap
                      , G = !!a.emissiveMap
                      , Q = !!a.metalnessMap
                      , X = !!a.roughnessMap
                      , j = a.anisotropy > 0
                      , q = a.clearcoat > 0
                      , Y = a.dispersion > 0
                      , K = a.iridescence > 0
                      , Z = a.sheen > 0
                      , J = a.transmission > 0
                      , $ = j && !!a.anisotropyMap
                      , ee = q && !!a.clearcoatMap
                      , te = q && !!a.clearcoatNormalMap
                      , ne = q && !!a.clearcoatRoughnessMap
                      , ie = K && !!a.iridescenceMap
                      , re = K && !!a.iridescenceThicknessMap
                      , ae = Z && !!a.sheenColorMap
                      , se = Z && !!a.sheenRoughnessMap
                      , oe = !!a.specularMap
                      , le = !!a.specularColorMap
                      , ce = !!a.specularIntensityMap
                      , he = J && !!a.transmissionMap
                      , de = J && !!a.thicknessMap
                      , ue = !!a.gradientMap
                      , fe = !!a.alphaMap
                      , pe = a.alphaTest > 0
                      , me = !!a.alphaHash
                      , ge = !!a.extensions;
                    let Ae = 0;
                    a.toneMapped && (null !== P && !0 !== P.isXRRenderTarget || (Ae = e.toneMapping));
                    const _e = {
                        shaderID: b,
                        shaderType: a.type,
                        shaderName: a.name,
                        vertexShader: M,
                        fragmentShader: T,
                        defines: a.defines,
                        customVertexShaderID: C,
                        customFragmentShaderID: I,
                        isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                        glslVersion: a.glslVersion,
                        precision: f,
                        batching: L,
                        batchingColor: L && null !== A._colorsTexture,
                        instancing: D,
                        instancingColor: D && null !== A.instanceColor,
                        instancingMorph: D && null !== A.morphTexture,
                        supportsVertexTextures: u,
                        outputColorSpace: null === P ? e.outputColorSpace : !0 === P.isXRRenderTarget ? P.texture.colorSpace : Ke,
                        alphaToCoverage: !!a.alphaToCoverage,
                        map: U,
                        matcap: k,
                        envMap: F,
                        envMapMode: F && y.mapping,
                        envMapCubeUVHeight: x,
                        aoMap: O,
                        lightMap: z,
                        bumpMap: H,
                        normalMap: W,
                        displacementMap: u && V,
                        emissiveMap: G,
                        normalMapObjectSpace: W && 1 === a.normalMapType,
                        normalMapTangentSpace: W && 0 === a.normalMapType,
                        metalnessMap: Q,
                        roughnessMap: X,
                        anisotropy: j,
                        anisotropyMap: $,
                        clearcoat: q,
                        clearcoatMap: ee,
                        clearcoatNormalMap: te,
                        clearcoatRoughnessMap: ne,
                        dispersion: Y,
                        iridescence: K,
                        iridescenceMap: ie,
                        iridescenceThicknessMap: re,
                        sheen: Z,
                        sheenColorMap: ae,
                        sheenRoughnessMap: se,
                        specularMap: oe,
                        specularColorMap: le,
                        specularIntensityMap: ce,
                        transmission: J,
                        transmissionMap: he,
                        thicknessMap: de,
                        gradientMap: ue,
                        opaque: !1 === a.transparent && 1 === a.blending && !1 === a.alphaToCoverage,
                        alphaMap: fe,
                        alphaTest: pe,
                        alphaHash: me,
                        combine: a.combine,
                        mapUv: U && m(a.map.channel),
                        aoMapUv: O && m(a.aoMap.channel),
                        lightMapUv: z && m(a.lightMap.channel),
                        bumpMapUv: H && m(a.bumpMap.channel),
                        normalMapUv: W && m(a.normalMap.channel),
                        displacementMapUv: V && m(a.displacementMap.channel),
                        emissiveMapUv: G && m(a.emissiveMap.channel),
                        metalnessMapUv: Q && m(a.metalnessMap.channel),
                        roughnessMapUv: X && m(a.roughnessMap.channel),
                        anisotropyMapUv: $ && m(a.anisotropyMap.channel),
                        clearcoatMapUv: ee && m(a.clearcoatMap.channel),
                        clearcoatNormalMapUv: te && m(a.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: ne && m(a.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: ie && m(a.iridescenceMap.channel),
                        iridescenceThicknessMapUv: re && m(a.iridescenceThicknessMap.channel),
                        sheenColorMapUv: ae && m(a.sheenColorMap.channel),
                        sheenRoughnessMapUv: se && m(a.sheenRoughnessMap.channel),
                        specularMapUv: oe && m(a.specularMap.channel),
                        specularColorMapUv: le && m(a.specularColorMap.channel),
                        specularIntensityMapUv: ce && m(a.specularIntensityMap.channel),
                        transmissionMapUv: he && m(a.transmissionMap.channel),
                        thicknessMapUv: de && m(a.thicknessMap.channel),
                        alphaMapUv: fe && m(a.alphaMap.channel),
                        vertexTangents: !!v.attributes.tangent && (W || j),
                        vertexColors: a.vertexColors,
                        vertexAlphas: !0 === a.vertexColors && !!v.attributes.color && 4 === v.attributes.color.itemSize,
                        pointsUvs: !0 === A.isPoints && !!v.attributes.uv && (U || fe),
                        fog: !!_,
                        useFog: !0 === a.fog,
                        fogExp2: !!_ && _.isFogExp2,
                        flatShading: !0 === a.flatShading,
                        sizeAttenuation: !0 === a.sizeAttenuation,
                        logarithmicDepthBuffer: d,
                        reverseDepthBuffer: B,
                        skinning: !0 === A.isSkinnedMesh,
                        morphTargets: void 0 !== v.morphAttributes.position,
                        morphNormals: void 0 !== v.morphAttributes.normal,
                        morphColors: void 0 !== v.morphAttributes.color,
                        morphTargetsCount: E,
                        morphTextureStride: R,
                        numDirLights: o.directional.length,
                        numPointLights: o.point.length,
                        numSpotLights: o.spot.length,
                        numSpotLightMaps: o.spotLightMap.length,
                        numRectAreaLights: o.rectArea.length,
                        numHemiLights: o.hemi.length,
                        numDirLightShadows: o.directionalShadowMap.length,
                        numPointLightShadows: o.pointShadowMap.length,
                        numSpotLightShadows: o.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                        numLightProbes: o.numLightProbes,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: a.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: Ae,
                        decodeVideoTexture: U && !0 === a.map.isVideoTexture && Ut.getTransfer(a.map.colorSpace) === Je,
                        decodeVideoTextureEmissive: G && !0 === a.emissiveMap.isVideoTexture && Ut.getTransfer(a.emissiveMap.colorSpace) === Je,
                        premultipliedAlpha: a.premultipliedAlpha,
                        doubleSided: 2 === a.side,
                        flipSided: 1 === a.side,
                        useDepthPacking: a.depthPacking >= 0,
                        depthPacking: a.depthPacking || 0,
                        index0AttributeName: a.index0AttributeName,
                        extensionClipCullDistance: ge && !0 === a.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: (ge && !0 === a.extensions.multiDraw || L) && i.has("WEBGL_multi_draw"),
                        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: a.customProgramCacheKey()
                    };
                    return _e.vertexUv1s = c.has(1),
                    _e.vertexUv2s = c.has(2),
                    _e.vertexUv3s = c.has(3),
                    c.clear(),
                    _e
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                    n.push(t.customFragmentShaderID)),
                    void 0 !== t.defines)
                        for (const e in t.defines)
                            n.push(e),
                            n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (!function(e, t) {
                        e.push(t.precision),
                        e.push(t.outputColorSpace),
                        e.push(t.envMapMode),
                        e.push(t.envMapCubeUVHeight),
                        e.push(t.mapUv),
                        e.push(t.alphaMapUv),
                        e.push(t.lightMapUv),
                        e.push(t.aoMapUv),
                        e.push(t.bumpMapUv),
                        e.push(t.normalMapUv),
                        e.push(t.displacementMapUv),
                        e.push(t.emissiveMapUv),
                        e.push(t.metalnessMapUv),
                        e.push(t.roughnessMapUv),
                        e.push(t.anisotropyMapUv),
                        e.push(t.clearcoatMapUv),
                        e.push(t.clearcoatNormalMapUv),
                        e.push(t.clearcoatRoughnessMapUv),
                        e.push(t.iridescenceMapUv),
                        e.push(t.iridescenceThicknessMapUv),
                        e.push(t.sheenColorMapUv),
                        e.push(t.sheenRoughnessMapUv),
                        e.push(t.specularMapUv),
                        e.push(t.specularColorMapUv),
                        e.push(t.specularIntensityMapUv),
                        e.push(t.transmissionMapUv),
                        e.push(t.thicknessMapUv),
                        e.push(t.combine),
                        e.push(t.fogExp2),
                        e.push(t.sizeAttenuation),
                        e.push(t.morphTargetsCount),
                        e.push(t.morphAttributeCount),
                        e.push(t.numDirLights),
                        e.push(t.numPointLights),
                        e.push(t.numSpotLights),
                        e.push(t.numSpotLightMaps),
                        e.push(t.numHemiLights),
                        e.push(t.numRectAreaLights),
                        e.push(t.numDirLightShadows),
                        e.push(t.numPointLightShadows),
                        e.push(t.numSpotLightShadows),
                        e.push(t.numSpotLightShadowsWithMaps),
                        e.push(t.numLightProbes),
                        e.push(t.shadowMapType),
                        e.push(t.toneMapping),
                        e.push(t.numClippingPlanes),
                        e.push(t.numClipIntersection),
                        e.push(t.depthPacking)
                    }(n, t),
                    function(e, t) {
                        o.disableAll(),
                        t.supportsVertexTextures && o.enable(0);
                        t.instancing && o.enable(1);
                        t.instancingColor && o.enable(2);
                        t.instancingMorph && o.enable(3);
                        t.matcap && o.enable(4);
                        t.envMap && o.enable(5);
                        t.normalMapObjectSpace && o.enable(6);
                        t.normalMapTangentSpace && o.enable(7);
                        t.clearcoat && o.enable(8);
                        t.iridescence && o.enable(9);
                        t.alphaTest && o.enable(10);
                        t.vertexColors && o.enable(11);
                        t.vertexAlphas && o.enable(12);
                        t.vertexUv1s && o.enable(13);
                        t.vertexUv2s && o.enable(14);
                        t.vertexUv3s && o.enable(15);
                        t.vertexTangents && o.enable(16);
                        t.anisotropy && o.enable(17);
                        t.alphaHash && o.enable(18);
                        t.batching && o.enable(19);
                        t.dispersion && o.enable(20);
                        t.batchingColor && o.enable(21);
                        e.push(o.mask),
                        o.disableAll(),
                        t.fog && o.enable(0);
                        t.useFog && o.enable(1);
                        t.flatShading && o.enable(2);
                        t.logarithmicDepthBuffer && o.enable(3);
                        t.reverseDepthBuffer && o.enable(4);
                        t.skinning && o.enable(5);
                        t.morphTargets && o.enable(6);
                        t.morphNormals && o.enable(7);
                        t.morphColors && o.enable(8);
                        t.premultipliedAlpha && o.enable(9);
                        t.shadowMapEnabled && o.enable(10);
                        t.doubleSided && o.enable(11);
                        t.flipSided && o.enable(12);
                        t.useDepthPacking && o.enable(13);
                        t.dithering && o.enable(14);
                        t.transmission && o.enable(15);
                        t.sheen && o.enable(16);
                        t.opaque && o.enable(17);
                        t.pointsUvs && o.enable(18);
                        t.decodeVideoTexture && o.enable(19);
                        t.decodeVideoTextureEmissive && o.enable(20);
                        t.alphaToCoverage && o.enable(21);
                        e.push(o.mask)
                    }(n, t),
                    n.push(e.outputColorSpace)),
                    n.push(t.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(e) {
                    const t = p[e.type];
                    let n;
                    if (t) {
                        const e = Au[t];
                        n = ir.clone(e.uniforms)
                    } else
                        n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let i;
                    for (let e = 0, t = h.length; e < t; e++) {
                        const t = h[e];
                        if (t.cacheKey === n) {
                            i = t,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new bp(e,n,t,a),
                    h.push(i)),
                    i
                },
                releaseProgram: function(e) {
                    if (0 == --e.usedTimes) {
                        const t = h.indexOf(e);
                        h[t] = h[h.length - 1],
                        h.pop(),
                        e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    l.remove(e)
                },
                programs: h,
                dispose: function() {
                    l.dispose()
                }
            }
        }
        function Cp() {
            let e = new WeakMap;
            return {
                has: function(t) {
                    return e.has(t)
                },
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {},
                    e.set(t, n)),
                    n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Ip(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }
        function Rp(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }
        function Pp() {
            const e = [];
            let t = 0;
            const n = []
              , i = []
              , r = [];
            function a(n, i, r, a, s, o) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: a,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: o
                },
                e[t] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = i,
                l.material = r,
                l.groupOrder = a,
                l.renderOrder = n.renderOrder,
                l.z = s,
                l.group = o),
                t++,
                l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    t = 0,
                    n.length = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(e, t, s, o, l, c) {
                    const h = a(e, t, s, o, l, c);
                    s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
                },
                unshift: function(e, t, s, o, l, c) {
                    const h = a(e, t, s, o, l, c);
                    s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
                },
                finish: function() {
                    for (let n = t, i = e.length; n < i; n++) {
                        const t = e[n];
                        if (null === t.id)
                            break;
                        t.id = null,
                        t.object = null,
                        t.geometry = null,
                        t.material = null,
                        t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || Ip),
                    i.length > 1 && i.sort(t || Rp),
                    r.length > 1 && r.sort(t || Rp)
                }
            }
        }
        function Bp() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const i = e.get(t);
                    let r;
                    return void 0 === i ? (r = new Pp,
                    e.set(t, [r])) : n >= i.length ? (r = new Pp,
                    i.push(r)) : r = i[n],
                    r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Dp() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new Zt,
                            color: new wi
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new Zt,
                            direction: new Zt,
                            color: new wi,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new Zt,
                            color: new wi,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new Zt,
                            skyColor: new wi,
                            groundColor: new wi
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new wi,
                            position: new Zt,
                            halfWidth: new Zt,
                            halfHeight: new Zt
                        }
                    }
                    return e[t.id] = n,
                    n
                }
            }
        }
        let Lp = 0;
        function Up(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }
        function Np(e) {
            const t = new Dp
              , n = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowIntensity: 1,
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new St
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowIntensity: 1,
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new St,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }()
              , i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let e = 0; e < 9; e++)
                i.probe.push(new Zt);
            const r = new Zt
              , a = new Cn
              , s = new Cn;
            return {
                setup: function(r) {
                    let a = 0
                      , s = 0
                      , o = 0;
                    for (let e = 0; e < 9; e++)
                        i.probe[e].set(0, 0, 0);
                    let l = 0
                      , c = 0
                      , h = 0
                      , d = 0
                      , u = 0
                      , f = 0
                      , p = 0
                      , m = 0
                      , g = 0
                      , A = 0
                      , _ = 0;
                    r.sort(Up);
                    for (let e = 0, v = r.length; e < v; e++) {
                        const v = r[e]
                          , w = v.color
                          , y = v.intensity
                          , x = v.distance
                          , b = v.shadow && v.shadow.map ? v.shadow.map.texture : null;
                        if (v.isAmbientLight)
                            a += w.r * y,
                            s += w.g * y,
                            o += w.b * y;
                        else if (v.isLightProbe) {
                            for (let e = 0; e < 9; e++)
                                i.probe[e].addScaledVector(v.sh.coefficients[e], y);
                            _++
                        } else if (v.isDirectionalLight) {
                            const e = t.get(v);
                            if (e.color.copy(v.color).multiplyScalar(v.intensity),
                            v.castShadow) {
                                const e = v.shadow
                                  , t = n.get(v);
                                t.shadowIntensity = e.intensity,
                                t.shadowBias = e.bias,
                                t.shadowNormalBias = e.normalBias,
                                t.shadowRadius = e.radius,
                                t.shadowMapSize = e.mapSize,
                                i.directionalShadow[l] = t,
                                i.directionalShadowMap[l] = b,
                                i.directionalShadowMatrix[l] = v.shadow.matrix,
                                f++
                            }
                            i.directional[l] = e,
                            l++
                        } else if (v.isSpotLight) {
                            const e = t.get(v);
                            e.position.setFromMatrixPosition(v.matrixWorld),
                            e.color.copy(w).multiplyScalar(y),
                            e.distance = x,
                            e.coneCos = Math.cos(v.angle),
                            e.penumbraCos = Math.cos(v.angle * (1 - v.penumbra)),
                            e.decay = v.decay,
                            i.spot[h] = e;
                            const r = v.shadow;
                            if (v.map && (i.spotLightMap[g] = v.map,
                            g++,
                            r.updateMatrices(v),
                            v.castShadow && A++),
                            i.spotLightMatrix[h] = r.matrix,
                            v.castShadow) {
                                const e = n.get(v);
                                e.shadowIntensity = r.intensity,
                                e.shadowBias = r.bias,
                                e.shadowNormalBias = r.normalBias,
                                e.shadowRadius = r.radius,
                                e.shadowMapSize = r.mapSize,
                                i.spotShadow[h] = e,
                                i.spotShadowMap[h] = b,
                                m++
                            }
                            h++
                        } else if (v.isRectAreaLight) {
                            const e = t.get(v);
                            e.color.copy(w).multiplyScalar(y),
                            e.halfWidth.set(.5 * v.width, 0, 0),
                            e.halfHeight.set(0, .5 * v.height, 0),
                            i.rectArea[d] = e,
                            d++
                        } else if (v.isPointLight) {
                            const e = t.get(v);
                            if (e.color.copy(v.color).multiplyScalar(v.intensity),
                            e.distance = v.distance,
                            e.decay = v.decay,
                            v.castShadow) {
                                const e = v.shadow
                                  , t = n.get(v);
                                t.shadowIntensity = e.intensity,
                                t.shadowBias = e.bias,
                                t.shadowNormalBias = e.normalBias,
                                t.shadowRadius = e.radius,
                                t.shadowMapSize = e.mapSize,
                                t.shadowCameraNear = e.camera.near,
                                t.shadowCameraFar = e.camera.far,
                                i.pointShadow[c] = t,
                                i.pointShadowMap[c] = b,
                                i.pointShadowMatrix[c] = v.shadow.matrix,
                                p++
                            }
                            i.point[c] = e,
                            c++
                        } else if (v.isHemisphereLight) {
                            const e = t.get(v);
                            e.skyColor.copy(v.color).multiplyScalar(y),
                            e.groundColor.copy(v.groundColor).multiplyScalar(y),
                            i.hemi[u] = e,
                            u++
                        }
                    }
                    d > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = gu.LTC_FLOAT_1,
                    i.rectAreaLTC2 = gu.LTC_FLOAT_2) : (i.rectAreaLTC1 = gu.LTC_HALF_1,
                    i.rectAreaLTC2 = gu.LTC_HALF_2)),
                    i.ambient[0] = a,
                    i.ambient[1] = s,
                    i.ambient[2] = o;
                    const v = i.hash;
                    v.directionalLength === l && v.pointLength === c && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === u && v.numDirectionalShadows === f && v.numPointShadows === p && v.numSpotShadows === m && v.numSpotMaps === g && v.numLightProbes === _ || (i.directional.length = l,
                    i.spot.length = h,
                    i.rectArea.length = d,
                    i.point.length = c,
                    i.hemi.length = u,
                    i.directionalShadow.length = f,
                    i.directionalShadowMap.length = f,
                    i.pointShadow.length = p,
                    i.pointShadowMap.length = p,
                    i.spotShadow.length = m,
                    i.spotShadowMap.length = m,
                    i.directionalShadowMatrix.length = f,
                    i.pointShadowMatrix.length = p,
                    i.spotLightMatrix.length = m + g - A,
                    i.spotLightMap.length = g,
                    i.numSpotLightShadowsWithMaps = A,
                    i.numLightProbes = _,
                    v.directionalLength = l,
                    v.pointLength = c,
                    v.spotLength = h,
                    v.rectAreaLength = d,
                    v.hemiLength = u,
                    v.numDirectionalShadows = f,
                    v.numPointShadows = p,
                    v.numSpotShadows = m,
                    v.numSpotMaps = g,
                    v.numLightProbes = _,
                    i.version = Lp++)
                },
                setupView: function(e, t) {
                    let n = 0
                      , o = 0
                      , l = 0
                      , c = 0
                      , h = 0;
                    const d = t.matrixWorldInverse;
                    for (let t = 0, u = e.length; t < u; t++) {
                        const u = e[t];
                        if (u.isDirectionalLight) {
                            const e = i.directional[n];
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            r.setFromMatrixPosition(u.target.matrixWorld),
                            e.direction.sub(r),
                            e.direction.transformDirection(d),
                            n++
                        } else if (u.isSpotLight) {
                            const e = i.spot[l];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            r.setFromMatrixPosition(u.target.matrixWorld),
                            e.direction.sub(r),
                            e.direction.transformDirection(d),
                            l++
                        } else if (u.isRectAreaLight) {
                            const e = i.rectArea[c];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            s.identity(),
                            a.copy(u.matrixWorld),
                            a.premultiply(d),
                            s.extractRotation(a),
                            e.halfWidth.set(.5 * u.width, 0, 0),
                            e.halfHeight.set(0, .5 * u.height, 0),
                            e.halfWidth.applyMatrix4(s),
                            e.halfHeight.applyMatrix4(s),
                            c++
                        } else if (u.isPointLight) {
                            const e = i.point[o];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            o++
                        } else if (u.isHemisphereLight) {
                            const e = i.hemi[h];
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            e.direction.transformDirection(d),
                            h++
                        }
                    }
                },
                state: i
            }
        }
        function kp(e) {
            const t = new Np(e)
              , n = []
              , i = [];
            const r = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: t,
                transmissionRenderTarget: {}
            };
            return {
                init: function(e) {
                    r.camera = e,
                    n.length = 0,
                    i.length = 0
                },
                state: r,
                setupLights: function() {
                    t.setup(n)
                },
                setupLightsView: function(e) {
                    t.setupView(n, e)
                },
                pushLight: function(e) {
                    n.push(e)
                },
                pushShadow: function(e) {
                    i.push(e)
                }
            }
        }
        function Fp(e) {
            let t = new WeakMap;
            return {
                get: function(n, i=0) {
                    const r = t.get(n);
                    let a;
                    return void 0 === r ? (a = new kp(e),
                    t.set(n, [a])) : i >= r.length ? (a = new kp(e),
                    r.push(a)) : a = r[i],
                    a
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Op(e, n, a) {
            let s = new Jr;
            const o = new St
              , l = new St
              , c = new Qt
              , h = new Sa({
                depthPacking: 3201
            })
              , d = new Ea
              , u = {}
              , f = a.maxTextureSize
              , p = {
                [t]: 1,
                [i]: 0,
                [r]: 2
            }
              , m = new rr({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new St
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , g = m.clone();
            g.defines.HORIZONTAL_PASS = 1;
            const A = new Oi;
            A.setAttribute("position", new Ci(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const _ = new Zi(A,m)
              , v = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = 1;
            let w = this.type;
            function y(t, i) {
                const r = n.update(_);
                m.defines.VSM_SAMPLES !== t.blurSamples && (m.defines.VSM_SAMPLES = t.blurSamples,
                g.defines.VSM_SAMPLES = t.blurSamples,
                m.needsUpdate = !0,
                g.needsUpdate = !0),
                null === t.mapPass && (t.mapPass = new jt(o.x,o.y)),
                m.uniforms.shadow_pass.value = t.map.texture,
                m.uniforms.resolution.value = t.mapSize,
                m.uniforms.radius.value = t.radius,
                e.setRenderTarget(t.mapPass),
                e.clear(),
                e.renderBufferDirect(i, null, r, m, _, null),
                g.uniforms.shadow_pass.value = t.mapPass.texture,
                g.uniforms.resolution.value = t.mapSize,
                g.uniforms.radius.value = t.radius,
                e.setRenderTarget(t.map),
                e.clear(),
                e.renderBufferDirect(i, null, r, g, _, null)
            }
            function x(t, n, i, r) {
                let a = null;
                const s = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== s)
                    a = s;
                else if (a = !0 === i.isPointLight ? d : h,
                e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = a.uuid
                      , t = n.uuid;
                    let i = u[e];
                    void 0 === i && (i = {},
                    u[e] = i);
                    let r = i[t];
                    void 0 === r && (r = a.clone(),
                    i[t] = r,
                    n.addEventListener("dispose", S)),
                    a = r
                }
                if (a.visible = n.visible,
                a.wireframe = n.wireframe,
                a.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : p[n.side],
                a.alphaMap = n.alphaMap,
                a.alphaTest = n.alphaTest,
                a.map = n.map,
                a.clipShadows = n.clipShadows,
                a.clippingPlanes = n.clippingPlanes,
                a.clipIntersection = n.clipIntersection,
                a.displacementMap = n.displacementMap,
                a.displacementScale = n.displacementScale,
                a.displacementBias = n.displacementBias,
                a.wireframeLinewidth = n.wireframeLinewidth,
                a.linewidth = n.linewidth,
                !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial) {
                    e.properties.get(a).light = i
                }
                return a
            }
            function b(t, i, r, a, o) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(i.layers) && (t.isMesh || t.isLine || t.isPoints) && (t.castShadow || t.receiveShadow && 3 === o) && (!t.frustumCulled || s.intersectsObject(t))) {
                    t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld);
                    const s = n.update(t)
                      , l = t.material;
                    if (Array.isArray(l)) {
                        const n = s.groups;
                        for (let c = 0, h = n.length; c < h; c++) {
                            const h = n[c]
                              , d = l[h.materialIndex];
                            if (d && d.visible) {
                                const n = x(t, d, a, o);
                                t.onBeforeShadow(e, t, i, r, s, n, h),
                                e.renderBufferDirect(r, null, s, n, t, h),
                                t.onAfterShadow(e, t, i, r, s, n, h)
                            }
                        }
                    } else if (l.visible) {
                        const n = x(t, l, a, o);
                        t.onBeforeShadow(e, t, i, r, s, n, null),
                        e.renderBufferDirect(r, null, s, n, t, null),
                        t.onAfterShadow(e, t, i, r, s, n, null)
                    }
                }
                const l = t.children;
                for (let e = 0, t = l.length; e < t; e++)
                    b(l[e], i, r, a, o)
            }
            function S(e) {
                e.target.removeEventListener("dispose", S);
                for (const t in u) {
                    const n = u[t]
                      , i = e.target.uuid;
                    if (i in n) {
                        n[i].dispose(),
                        delete n[i]
                    }
                }
            }
            this.render = function(t, n, i) {
                if (!1 === v.enabled)
                    return;
                if (!1 === v.autoUpdate && !1 === v.needsUpdate)
                    return;
                if (0 === t.length)
                    return;
                const r = e.getRenderTarget()
                  , a = e.getActiveCubeFace()
                  , h = e.getActiveMipmapLevel()
                  , d = e.state;
                d.setBlending(0),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                const u = 3 !== w && 3 === this.type
                  , p = 3 === w && 3 !== this.type;
                for (let r = 0, a = t.length; r < a; r++) {
                    const a = t[r]
                      , h = a.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", a, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                        continue;
                    o.copy(h.mapSize);
                    const m = h.getFrameExtents();
                    if (o.multiply(m),
                    l.copy(h.mapSize),
                    (o.x > f || o.y > f) && (o.x > f && (l.x = Math.floor(f / m.x),
                    o.x = l.x * m.x,
                    h.mapSize.x = l.x),
                    o.y > f && (l.y = Math.floor(f / m.y),
                    o.y = l.y * m.y,
                    h.mapSize.y = l.y)),
                    null === h.map || !0 === u || !0 === p) {
                        const e = 3 !== this.type ? {
                            minFilter: z,
                            magFilter: z
                        } : {};
                        null !== h.map && h.map.dispose(),
                        h.map = new jt(o.x,o.y,e),
                        h.map.texture.name = a.name + ".shadowMap",
                        h.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(h.map),
                    e.clear();
                    const g = h.getViewportCount();
                    for (let e = 0; e < g; e++) {
                        const t = h.getViewport(e);
                        c.set(l.x * t.x, l.y * t.y, l.x * t.z, l.y * t.w),
                        d.viewport(c),
                        h.updateMatrices(a, e),
                        s = h.getFrustum(),
                        b(n, i, h.camera, a, this.type)
                    }
                    !0 !== h.isPointLightShadow && 3 === this.type && y(h, i),
                    h.needsUpdate = !1
                }
                w = this.type,
                v.needsUpdate = !1,
                e.setRenderTarget(r, a, h)
            }
        }
        const zp = {
            [b]: 1,
            [E]: 6,
            [T]: 7,
            [M]: 5,
            [S]: 0,
            [I]: 2,
            [R]: 4,
            [C]: 3
        };
        function Hp(e, t) {
            const n = new function() {
                let t = !1;
                const n = new Qt;
                let i = null;
                const r = new Qt(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || t || (e.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, i, a, s, o) {
                        !0 === o && (t *= s,
                        i *= s,
                        a *= s),
                        n.set(t, i, a, s),
                        !1 === r.equals(n) && (e.clearColor(t, i, a, s),
                        r.copy(n))
                    },
                    reset: function() {
                        t = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , i = new function() {
                let n = !1
                  , i = !1
                  , r = null
                  , a = null
                  , s = null;
                return {
                    setReversed: function(e) {
                        if (i !== e) {
                            const e = t.get("EXT_clip_control");
                            i ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT);
                            const n = s;
                            s = null,
                            this.setClear(n)
                        }
                        i = e
                    },
                    getReversed: function() {
                        return i
                    },
                    setTest: function(t) {
                        t ? re(e.DEPTH_TEST) : ae(e.DEPTH_TEST)
                    },
                    setMask: function(t) {
                        r === t || n || (e.depthMask(t),
                        r = t)
                    },
                    setFunc: function(t) {
                        if (i && (t = zp[t]),
                        a !== t) {
                            switch (t) {
                            case 0:
                                e.depthFunc(e.NEVER);
                                break;
                            case 1:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case 2:
                                e.depthFunc(e.LESS);
                                break;
                            case 3:
                            default:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case 4:
                                e.depthFunc(e.EQUAL);
                                break;
                            case 5:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case 6:
                                e.depthFunc(e.GREATER);
                                break;
                            case 7:
                                e.depthFunc(e.NOTEQUAL)
                            }
                            a = t
                        }
                    },
                    setLocked: function(e) {
                        n = e
                    },
                    setClear: function(t) {
                        s !== t && (i && (t = 1 - t),
                        e.clearDepth(t),
                        s = t)
                    },
                    reset: function() {
                        n = !1,
                        r = null,
                        a = null,
                        s = null,
                        i = !1
                    }
                }
            }
              , r = new function() {
                let t = !1
                  , n = null
                  , i = null
                  , r = null
                  , a = null
                  , s = null
                  , o = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        t || (n ? re(e.STENCIL_TEST) : ae(e.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || t || (e.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(t, n, s) {
                        i === t && r === n && a === s || (e.stencilFunc(t, n, s),
                        i = t,
                        r = n,
                        a = s)
                    },
                    setOp: function(t, n, i) {
                        s === t && o === n && l === i || (e.stencilOp(t, n, i),
                        s = t,
                        o = n,
                        l = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t),
                        c = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        s = null,
                        o = null,
                        l = null,
                        c = null
                    }
                }
            }
              , b = new WeakMap
              , S = new WeakMap;
            let E = {}
              , M = {}
              , T = new WeakMap
              , C = []
              , I = null
              , R = !1
              , P = null
              , B = null
              , D = null
              , L = null
              , U = null
              , N = null
              , k = null
              , F = new wi(0,0,0)
              , O = 0
              , z = !1
              , H = null
              , W = null
              , V = null
              , G = null
              , Q = null;
            const X = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let j = !1
              , q = 0;
            const Y = e.getParameter(e.VERSION);
            -1 !== Y.indexOf("WebGL") ? (q = parseFloat(/^WebGL (\d)/.exec(Y)[1]),
            j = q >= 1) : -1 !== Y.indexOf("OpenGL ES") && (q = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]),
            j = q >= 2);
            let K = null
              , Z = {};
            const J = e.getParameter(e.SCISSOR_BOX)
              , $ = e.getParameter(e.VIEWPORT)
              , ee = (new Qt).fromArray(J)
              , te = (new Qt).fromArray($);
            function ne(t, n, i, r) {
                const a = new Uint8Array(4)
                  , s = e.createTexture();
                e.bindTexture(t, s),
                e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let s = 0; s < i; s++)
                    t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a);
                return s
            }
            const ie = {};
            function re(t) {
                !0 !== E[t] && (e.enable(t),
                E[t] = !0)
            }
            function ae(t) {
                !1 !== E[t] && (e.disable(t),
                E[t] = !1)
            }
            ie[e.TEXTURE_2D] = ne(e.TEXTURE_2D, e.TEXTURE_2D, 1),
            ie[e.TEXTURE_CUBE_MAP] = ne(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            ie[e.TEXTURE_2D_ARRAY] = ne(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
            ie[e.TEXTURE_3D] = ne(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
            n.setClear(0, 0, 0, 1),
            i.setClear(1),
            r.setClear(0),
            re(e.DEPTH_TEST),
            i.setFunc(3),
            ce(!1),
            he(1),
            re(e.CULL_FACE),
            le(0);
            const se = {
                [a]: e.FUNC_ADD,
                [s]: e.FUNC_SUBTRACT,
                [o]: e.FUNC_REVERSE_SUBTRACT
            };
            se[103] = e.MIN,
            se[104] = e.MAX;
            const oe = {
                [l]: e.ZERO,
                [c]: e.ONE,
                [h]: e.SRC_COLOR,
                [u]: e.SRC_ALPHA,
                [_]: e.SRC_ALPHA_SATURATE,
                [g]: e.DST_COLOR,
                [p]: e.DST_ALPHA,
                [d]: e.ONE_MINUS_SRC_COLOR,
                [f]: e.ONE_MINUS_SRC_ALPHA,
                [A]: e.ONE_MINUS_DST_COLOR,
                [m]: e.ONE_MINUS_DST_ALPHA,
                [v]: e.CONSTANT_COLOR,
                [w]: e.ONE_MINUS_CONSTANT_COLOR,
                [y]: e.CONSTANT_ALPHA,
                [x]: e.ONE_MINUS_CONSTANT_ALPHA
            };
            function le(t, n, i, r, s, o, l, c, h, d) {
                if (0 !== t) {
                    if (!1 === R && (re(e.BLEND),
                    R = !0),
                    5 === t)
                        s = s || n,
                        o = o || i,
                        l = l || r,
                        n === B && s === U || (e.blendEquationSeparate(se[n], se[s]),
                        B = n,
                        U = s),
                        i === D && r === L && o === N && l === k || (e.blendFuncSeparate(oe[i], oe[r], oe[o], oe[l]),
                        D = i,
                        L = r,
                        N = o,
                        k = l),
                        !1 !== c.equals(F) && h === O || (e.blendColor(c.r, c.g, c.b, h),
                        F.copy(c),
                        O = h),
                        P = t,
                        z = !1;
                    else if (t !== P || d !== z) {
                        if (B === a && U === a || (e.blendEquation(e.FUNC_ADD),
                        B = a,
                        U = a),
                        d)
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        else
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        D = null,
                        L = null,
                        N = null,
                        k = null,
                        F.set(0, 0, 0),
                        O = 0,
                        P = t,
                        z = d
                    }
                } else
                    !0 === R && (ae(e.BLEND),
                    R = !1)
            }
            function ce(t) {
                H !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                H = t)
            }
            function he(t) {
                0 !== t ? (re(e.CULL_FACE),
                t !== W && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : ae(e.CULL_FACE),
                W = t
            }
            function de(t, n, i) {
                t ? (re(e.POLYGON_OFFSET_FILL),
                G === n && Q === i || (e.polygonOffset(n, i),
                G = n,
                Q = i)) : ae(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: n,
                    depth: i,
                    stencil: r
                },
                enable: re,
                disable: ae,
                bindFramebuffer: function(t, n) {
                    return M[t] !== n && (e.bindFramebuffer(t, n),
                    M[t] = n,
                    t === e.DRAW_FRAMEBUFFER && (M[e.FRAMEBUFFER] = n),
                    t === e.FRAMEBUFFER && (M[e.DRAW_FRAMEBUFFER] = n),
                    !0)
                },
                drawBuffers: function(t, n) {
                    let i = C
                      , r = !1;
                    if (t) {
                        i = T.get(n),
                        void 0 === i && (i = [],
                        T.set(n, i));
                        const a = t.textures;
                        if (i.length !== a.length || i[0] !== e.COLOR_ATTACHMENT0) {
                            for (let t = 0, n = a.length; t < n; t++)
                                i[t] = e.COLOR_ATTACHMENT0 + t;
                            i.length = a.length,
                            r = !0
                        }
                    } else
                        i[0] !== e.BACK && (i[0] = e.BACK,
                        r = !0);
                    r && e.drawBuffers(i)
                },
                useProgram: function(t) {
                    return I !== t && (e.useProgram(t),
                    I = t,
                    !0)
                },
                setBlending: le,
                setMaterial: function(t, a) {
                    2 === t.side ? ae(e.CULL_FACE) : re(e.CULL_FACE);
                    let s = 1 === t.side;
                    a && (s = !s),
                    ce(s),
                    1 === t.blending && !1 === t.transparent ? le(0) : le(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                    i.setFunc(t.depthFunc),
                    i.setTest(t.depthTest),
                    i.setMask(t.depthWrite),
                    n.setMask(t.colorWrite);
                    const o = t.stencilWrite;
                    r.setTest(o),
                    o && (r.setMask(t.stencilWriteMask),
                    r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    de(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? re(e.SAMPLE_ALPHA_TO_COVERAGE) : ae(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: ce,
                setCullFace: he,
                setLineWidth: function(t) {
                    t !== V && (j && e.lineWidth(t),
                    V = t)
                },
                setPolygonOffset: de,
                setScissorTest: function(t) {
                    t ? re(e.SCISSOR_TEST) : ae(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + X - 1),
                    K !== t && (e.activeTexture(t),
                    K = t)
                },
                bindTexture: function(t, n, i) {
                    void 0 === i && (i = null === K ? e.TEXTURE0 + X - 1 : K);
                    let r = Z[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    },
                    Z[i] = r),
                    r.type === t && r.texture === n || (K !== i && (e.activeTexture(i),
                    K = i),
                    e.bindTexture(t, n || ie[t]),
                    r.type = t,
                    r.texture = n)
                },
                unbindTexture: function() {
                    const t = Z[K];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                    t.type = void 0,
                    t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let i = S.get(n);
                    void 0 === i && (i = new WeakMap,
                    S.set(n, i));
                    let r = i.get(t);
                    void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
                    i.set(t, r))
                },
                uniformBlockBinding: function(t, n) {
                    const i = S.get(n).get(t);
                    b.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
                    b.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D(...arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function(t) {
                    !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                    ee.copy(t))
                },
                viewport: function(t) {
                    !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                    te.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND),
                    e.disable(e.CULL_FACE),
                    e.disable(e.DEPTH_TEST),
                    e.disable(e.POLYGON_OFFSET_FILL),
                    e.disable(e.SCISSOR_TEST),
                    e.disable(e.STENCIL_TEST),
                    e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                    e.blendEquation(e.FUNC_ADD),
                    e.blendFunc(e.ONE, e.ZERO),
                    e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                    e.blendColor(0, 0, 0, 0),
                    e.colorMask(!0, !0, !0, !0),
                    e.clearColor(0, 0, 0, 0),
                    e.depthMask(!0),
                    e.depthFunc(e.LESS),
                    i.setReversed(!1),
                    e.clearDepth(1),
                    e.stencilMask(4294967295),
                    e.stencilFunc(e.ALWAYS, 0, 4294967295),
                    e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                    e.clearStencil(0),
                    e.cullFace(e.BACK),
                    e.frontFace(e.CCW),
                    e.polygonOffset(0, 0),
                    e.activeTexture(e.TEXTURE0),
                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                    e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                    e.useProgram(null),
                    e.lineWidth(1),
                    e.scissor(0, 0, e.canvas.width, e.canvas.height),
                    e.viewport(0, 0, e.canvas.width, e.canvas.height),
                    E = {},
                    K = null,
                    Z = {},
                    M = {},
                    T = new WeakMap,
                    C = [],
                    I = null,
                    R = !1,
                    P = null,
                    B = null,
                    D = null,
                    L = null,
                    U = null,
                    N = null,
                    k = null,
                    F = new wi(0,0,0),
                    O = 0,
                    z = !1,
                    H = null,
                    W = null,
                    V = null,
                    G = null,
                    Q = null,
                    ee.set(0, 0, e.canvas.width, e.canvas.height),
                    te.set(0, 0, e.canvas.width, e.canvas.height),
                    n.reset(),
                    i.reset(),
                    r.reset()
                }
            }
        }
        function Wp(e, t, n, i, r, a, s) {
            const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
              , l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , c = new St
              , h = new WeakMap;
            let d;
            const u = new WeakMap;
            let f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (e) {}
            function p(e, t) {
                return f ? new OffscreenCanvas(e,t) : Ct("canvas")
            }
            function m(e, t, n) {
                let i = 1;
                const r = ee(e);
                if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)),
                i < 1) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                        const n = Math.floor(i * r.width)
                          , a = Math.floor(i * r.height);
                        void 0 === d && (d = p(n, a));
                        const s = t ? p(n, a) : d;
                        s.width = n,
                        s.height = a;
                        return s.getContext("2d").drawImage(e, 0, 0, n, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + n + "x" + a + ")."),
                        s
                    }
                    return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."),
                    e
                }
                return e
            }
            function g(e) {
                return e.generateMipmaps
            }
            function A(t) {
                e.generateMipmap(t)
            }
            function _(t) {
                return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
            }
            function v(n, i, r, a, s=!1) {
                if (null !== n) {
                    if (void 0 !== e[n])
                        return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let o = i;
                if (i === e.RED && (r === e.FLOAT && (o = e.R32F),
                r === e.HALF_FLOAT && (o = e.R16F),
                r === e.UNSIGNED_BYTE && (o = e.R8)),
                i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI),
                r === e.UNSIGNED_SHORT && (o = e.R16UI),
                r === e.UNSIGNED_INT && (o = e.R32UI),
                r === e.BYTE && (o = e.R8I),
                r === e.SHORT && (o = e.R16I),
                r === e.INT && (o = e.R32I)),
                i === e.RG && (r === e.FLOAT && (o = e.RG32F),
                r === e.HALF_FLOAT && (o = e.RG16F),
                r === e.UNSIGNED_BYTE && (o = e.RG8)),
                i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
                r === e.UNSIGNED_SHORT && (o = e.RG16UI),
                r === e.UNSIGNED_INT && (o = e.RG32UI),
                r === e.BYTE && (o = e.RG8I),
                r === e.SHORT && (o = e.RG16I),
                r === e.INT && (o = e.RG32I)),
                i === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
                r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
                r === e.UNSIGNED_INT && (o = e.RGB32UI),
                r === e.BYTE && (o = e.RGB8I),
                r === e.SHORT && (o = e.RGB16I),
                r === e.INT && (o = e.RGB32I)),
                i === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
                r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
                r === e.UNSIGNED_INT && (o = e.RGBA32UI),
                r === e.BYTE && (o = e.RGBA8I),
                r === e.SHORT && (o = e.RGBA16I),
                r === e.INT && (o = e.RGBA32I)),
                i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
                i === e.RGBA) {
                    const t = s ? Ze : Ut.getTransfer(a);
                    r === e.FLOAT && (o = e.RGBA32F),
                    r === e.HALF_FLOAT && (o = e.RGBA16F),
                    r === e.UNSIGNED_BYTE && (o = t === Je ? e.SRGB8_ALPHA8 : e.RGBA8),
                    r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
                    r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
                }
                return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                o
            }
            function w(t, n) {
                let i;
                return t ? null === n || n === Z || n === ne ? i = e.DEPTH24_STENCIL8 : n === J ? i = e.DEPTH32F_STENCIL8 : n === Y && (i = e.DEPTH24_STENCIL8,
                console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === Z || n === ne ? i = e.DEPTH_COMPONENT24 : n === J ? i = e.DEPTH_COMPONENT32F : n === Y && (i = e.DEPTH_COMPONENT16),
                i
            }
            function y(e, t) {
                return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== z && e.minFilter !== V ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }
            function x(e) {
                const t = e.target;
                t.removeEventListener("dispose", x),
                function(e) {
                    const t = i.get(e);
                    if (void 0 === t.__webglInit)
                        return;
                    const n = e.source
                      , r = u.get(n);
                    if (r) {
                        const i = r[t.__cacheKey];
                        i.usedTimes--,
                        0 === i.usedTimes && S(e),
                        0 === Object.keys(r).length && u.delete(n)
                    }
                    i.remove(e)
                }(t),
                t.isVideoTexture && h.delete(t)
            }
            function b(t) {
                const n = t.target;
                n.removeEventListener("dispose", b),
                function(t) {
                    const n = i.get(t);
                    t.depthTexture && (t.depthTexture.dispose(),
                    i.remove(t.depthTexture));
                    if (t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) {
                            if (Array.isArray(n.__webglFramebuffer[t]))
                                for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                                    e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                            else
                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                        }
                    else {
                        if (Array.isArray(n.__webglFramebuffer))
                            for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                        else
                            e.deleteFramebuffer(n.__webglFramebuffer);
                        if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                        n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                        n.__webglColorRenderbuffer)
                            for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                        n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                    }
                    const r = t.textures;
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = i.get(r[t]);
                        n.__webglTexture && (e.deleteTexture(n.__webglTexture),
                        s.memory.textures--),
                        i.remove(r[t])
                    }
                    i.remove(t)
                }(n)
            }
            function S(t) {
                const n = i.get(t);
                e.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete u.get(r)[n.__cacheKey],
                s.memory.textures--
            }
            let E = 0;
            function M(t, r) {
                const a = i.get(t);
                if (t.isVideoTexture && function(e) {
                    const t = s.render.frame;
                    h.get(e) !== t && (h.set(e, t),
                    e.update())
                }(t),
                !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                    const e = t.image;
                    if (null === e)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete)
                            return void B(a, t, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + r)
            }
            const T = {
                [k]: e.REPEAT,
                [F]: e.CLAMP_TO_EDGE,
                [O]: e.MIRRORED_REPEAT
            }
              , C = {
                [z]: e.NEAREST,
                [H]: e.NEAREST_MIPMAP_NEAREST,
                [W]: e.NEAREST_MIPMAP_LINEAR,
                [V]: e.LINEAR,
                [G]: e.LINEAR_MIPMAP_NEAREST,
                [Q]: e.LINEAR_MIPMAP_LINEAR
            }
              , I = {
                [et]: e.NEVER,
                [ot]: e.ALWAYS,
                [tt]: e.LESS,
                [it]: e.LEQUAL,
                [nt]: e.EQUAL,
                [st]: e.GEQUAL,
                [rt]: e.GREATER,
                [at]: e.NOTEQUAL
            };
            function R(n, a) {
                if (a.type !== J || !1 !== t.has("OES_texture_float_linear") || a.magFilter !== V && a.magFilter !== G && a.magFilter !== W && a.magFilter !== Q && a.minFilter !== V && a.minFilter !== G && a.minFilter !== W && a.minFilter !== Q || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                e.texParameteri(n, e.TEXTURE_WRAP_S, T[a.wrapS]),
                e.texParameteri(n, e.TEXTURE_WRAP_T, T[a.wrapT]),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, T[a.wrapR]),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[a.magFilter]),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[a.minFilter]),
                a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, I[a.compareFunction])),
                !0 === t.has("EXT_texture_filter_anisotropic")) {
                    if (a.magFilter === z)
                        return;
                    if (a.minFilter !== W && a.minFilter !== Q)
                        return;
                    if (a.type === J && !1 === t.has("OES_texture_float_linear"))
                        return;
                    if (a.anisotropy > 1 || i.get(a).__currentAnisotropy) {
                        const s = t.get("EXT_texture_filter_anisotropic");
                        e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                        i.get(a).__currentAnisotropy = a.anisotropy
                    }
                }
            }
            function P(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0,
                n.addEventListener("dispose", x));
                const r = n.source;
                let a = u.get(r);
                void 0 === a && (a = {},
                u.set(r, a));
                const o = function(e) {
                    const t = [];
                    return t.push(e.wrapS),
                    t.push(e.wrapT),
                    t.push(e.wrapR || 0),
                    t.push(e.magFilter),
                    t.push(e.minFilter),
                    t.push(e.anisotropy),
                    t.push(e.internalFormat),
                    t.push(e.format),
                    t.push(e.type),
                    t.push(e.generateMipmaps),
                    t.push(e.premultiplyAlpha),
                    t.push(e.flipY),
                    t.push(e.unpackAlignment),
                    t.push(e.colorSpace),
                    t.join()
                }(n);
                if (o !== t.__cacheKey) {
                    void 0 === a[o] && (a[o] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    },
                    s.memory.textures++,
                    i = !0),
                    a[o].usedTimes++;
                    const r = a[t.__cacheKey];
                    void 0 !== r && (a[t.__cacheKey].usedTimes--,
                    0 === r.usedTimes && S(n)),
                    t.__cacheKey = o,
                    t.__webglTexture = a[o].texture
                }
                return i
            }
            function B(t, s, o) {
                let l = e.TEXTURE_2D;
                (s.isDataArrayTexture || s.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
                s.isData3DTexture && (l = e.TEXTURE_3D);
                const c = P(t, s)
                  , h = s.source;
                n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
                const d = i.get(h);
                if (h.version !== d.__version || !0 === c) {
                    n.activeTexture(e.TEXTURE0 + o);
                    const t = Ut.getPrimaries(Ut.workingColorSpace)
                      , i = s.colorSpace === qe ? null : Ut.getPrimaries(s.colorSpace)
                      , u = s.colorSpace === qe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                    e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                    let f = m(s.image, !1, r.maxTextureSize);
                    f = $(s, f);
                    const p = a.convert(s.format, s.colorSpace)
                      , _ = a.convert(s.type);
                    let x, b = v(s.internalFormat, p, _, s.colorSpace, s.isVideoTexture);
                    R(l, s);
                    const S = s.mipmaps
                      , E = !0 !== s.isVideoTexture
                      , M = void 0 === d.__version || !0 === c
                      , T = h.dataReady
                      , C = y(s, f);
                    if (s.isDepthTexture)
                        b = w(s.format === se, s.type),
                        M && (E ? n.texStorage2D(e.TEXTURE_2D, 1, b, f.width, f.height) : n.texImage2D(e.TEXTURE_2D, 0, b, f.width, f.height, 0, p, _, null));
                    else if (s.isDataTexture)
                        if (S.length > 0) {
                            E && M && n.texStorage2D(e.TEXTURE_2D, C, b, S[0].width, S[0].height);
                            for (let t = 0, i = S.length; t < i; t++)
                                x = S[t],
                                E ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, p, _, x.data) : n.texImage2D(e.TEXTURE_2D, t, b, x.width, x.height, 0, p, _, x.data);
                            s.generateMipmaps = !1
                        } else
                            E ? (M && n.texStorage2D(e.TEXTURE_2D, C, b, f.width, f.height),
                            T && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f.width, f.height, p, _, f.data)) : n.texImage2D(e.TEXTURE_2D, 0, b, f.width, f.height, 0, p, _, f.data);
                    else if (s.isCompressedTexture)
                        if (s.isCompressedArrayTexture) {
                            E && M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, b, S[0].width, S[0].height, f.depth);
                            for (let t = 0, i = S.length; t < i; t++)
                                if (x = S[t],
                                s.format !== re)
                                    if (null !== p)
                                        if (E) {
                                            if (T)
                                                if (s.layerUpdates.size > 0) {
                                                    const i = Ms(x.width, x.height, s.format, s.type);
                                                    for (const r of s.layerUpdates) {
                                                        const a = x.data.subarray(r * i / x.data.BYTES_PER_ELEMENT, (r + 1) * i / x.data.BYTES_PER_ELEMENT);
                                                        n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, x.width, x.height, 1, p, a)
                                                    }
                                                    s.clearLayerUpdates()
                                                } else
                                                    n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, f.depth, p, x.data)
                                        } else
                                            n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, b, x.width, x.height, f.depth, 0, x.data, 0, 0);
                                    else
                                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                else
                                    E ? T && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, f.depth, p, _, x.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, b, x.width, x.height, f.depth, 0, p, _, x.data)
                        } else {
                            E && M && n.texStorage2D(e.TEXTURE_2D, C, b, S[0].width, S[0].height);
                            for (let t = 0, i = S.length; t < i; t++)
                                x = S[t],
                                s.format !== re ? null !== p ? E ? T && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, p, x.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, b, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, p, _, x.data) : n.texImage2D(e.TEXTURE_2D, t, b, x.width, x.height, 0, p, _, x.data)
                        }
                    else if (s.isDataArrayTexture)
                        if (E) {
                            if (M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, b, f.width, f.height, f.depth),
                            T)
                                if (s.layerUpdates.size > 0) {
                                    const t = Ms(f.width, f.height, s.format, s.type);
                                    for (const i of s.layerUpdates) {
                                        const r = f.data.subarray(i * t / f.data.BYTES_PER_ELEMENT, (i + 1) * t / f.data.BYTES_PER_ELEMENT);
                                        n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, f.width, f.height, 1, p, _, r)
                                    }
                                    s.clearLayerUpdates()
                                } else
                                    n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, f.width, f.height, f.depth, p, _, f.data)
                        } else
                            n.texImage3D(e.TEXTURE_2D_ARRAY, 0, b, f.width, f.height, f.depth, 0, p, _, f.data);
                    else if (s.isData3DTexture)
                        E ? (M && n.texStorage3D(e.TEXTURE_3D, C, b, f.width, f.height, f.depth),
                        T && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, f.width, f.height, f.depth, p, _, f.data)) : n.texImage3D(e.TEXTURE_3D, 0, b, f.width, f.height, f.depth, 0, p, _, f.data);
                    else if (s.isFramebufferTexture) {
                        if (M)
                            if (E)
                                n.texStorage2D(e.TEXTURE_2D, C, b, f.width, f.height);
                            else {
                                let t = f.width
                                  , i = f.height;
                                for (let r = 0; r < C; r++)
                                    n.texImage2D(e.TEXTURE_2D, r, b, t, i, 0, p, _, null),
                                    t >>= 1,
                                    i >>= 1
                            }
                    } else if (S.length > 0) {
                        if (E && M) {
                            const t = ee(S[0]);
                            n.texStorage2D(e.TEXTURE_2D, C, b, t.width, t.height)
                        }
                        for (let t = 0, i = S.length; t < i; t++)
                            x = S[t],
                            E ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, p, _, x) : n.texImage2D(e.TEXTURE_2D, t, b, p, _, x);
                        s.generateMipmaps = !1
                    } else if (E) {
                        if (M) {
                            const t = ee(f);
                            n.texStorage2D(e.TEXTURE_2D, C, b, t.width, t.height)
                        }
                        T && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p, _, f)
                    } else
                        n.texImage2D(e.TEXTURE_2D, 0, b, p, _, f);
                    g(s) && A(l),
                    d.__version = h.version,
                    s.onUpdate && s.onUpdate(s)
                }
                t.__version = s.version
            }
            function D(t, r, s, l, c, h) {
                const d = a.convert(s.format, s.colorSpace)
                  , u = a.convert(s.type)
                  , f = v(s.internalFormat, d, u, s.colorSpace)
                  , p = i.get(r)
                  , m = i.get(s);
                if (m.__renderTarget = r,
                !p.__hasExternalTextures) {
                    const t = Math.max(1, r.width >> h)
                      , i = Math.max(1, r.height >> h);
                    c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, f, t, i, r.depth, 0, d, u, null) : n.texImage2D(c, h, f, t, i, 0, d, u, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t),
                K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, m.__webglTexture, 0, q(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, m.__webglTexture, h),
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function L(t, n, i) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                n.depthBuffer) {
                    const r = n.depthTexture
                      , a = r && r.isDepthTexture ? r.type : null
                      , s = w(n.stencilBuffer, a)
                      , l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , c = q(n);
                    K(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, s, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, s, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, s, n.width, n.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
                } else {
                    const t = n.textures;
                    for (let r = 0; r < t.length; r++) {
                        const s = t[r]
                          , l = a.convert(s.format, s.colorSpace)
                          , c = a.convert(s.type)
                          , h = v(s.internalFormat, l, c, s.colorSpace)
                          , d = q(n);
                        i && !1 === K(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, h, n.width, n.height) : K(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, h, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, h, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }
            function U(t) {
                const r = i.get(t)
                  , a = !0 === t.isWebGLCubeRenderTarget;
                if (r.__boundDepthTexture !== t.depthTexture) {
                    const e = t.depthTexture;
                    if (r.__depthDisposeCallback && r.__depthDisposeCallback(),
                    e) {
                        const t = () => {
                            delete r.__boundDepthTexture,
                            delete r.__depthDisposeCallback,
                            e.removeEventListener("dispose", t)
                        }
                        ;
                        e.addEventListener("dispose", t),
                        r.__depthDisposeCallback = t
                    }
                    r.__boundDepthTexture = e
                }
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (a)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(t, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const a = i.get(r.depthTexture);
                        a.__renderTarget = r,
                        a.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        M(r.depthTexture, 0);
                        const s = a.__webglTexture
                          , l = q(r);
                        if (r.depthTexture.format === ae)
                            K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0);
                        else {
                            if (r.depthTexture.format !== se)
                                throw new Error("Unknown depthTexture format");
                            K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0)
                        }
                    }(r.__webglFramebuffer, t)
                } else if (a) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                        void 0 === r.__webglDepthbuffer[i])
                            r.__webglDepthbuffer[i] = e.createRenderbuffer(),
                            L(r.__webglDepthbuffer[i], t, !1);
                        else {
                            const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , a = r.__webglDepthbuffer[i];
                            e.bindRenderbuffer(e.RENDERBUFFER, a),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, a)
                        }
                } else if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
                void 0 === r.__webglDepthbuffer)
                    r.__webglDepthbuffer = e.createRenderbuffer(),
                    L(r.__webglDepthbuffer, t, !1);
                else {
                    const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , i = r.__webglDepthbuffer;
                    e.bindRenderbuffer(e.RENDERBUFFER, i),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            const N = []
              , j = [];
            function q(e) {
                return Math.min(r.maxSamples, e.samples)
            }
            function K(e) {
                const n = i.get(e);
                return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function $(e, t) {
                const n = e.colorSpace
                  , i = e.format
                  , r = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== Ke && n !== qe && (Ut.getTransfer(n) === Je ? i === re && r === X || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)),
                t
            }
            function ee(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width,
                c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth,
                c.height = e.displayHeight) : (c.width = e.width,
                c.height = e.height),
                c
            }
            this.allocateTextureUnit = function() {
                const e = E;
                return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures),
                E += 1,
                e
            }
            ,
            this.resetTextureUnits = function() {
                E = 0
            }
            ,
            this.setTexture2D = M,
            this.setTexture2DArray = function(t, r) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? B(a, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTexture3D = function(t, r) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? B(a, t, r) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTextureCube = function(t, s) {
                const o = i.get(t);
                t.version > 0 && o.__version !== t.version ? function(t, s, o) {
                    if (6 !== s.image.length)
                        return;
                    const l = P(t, s)
                      , c = s.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                    const h = i.get(c);
                    if (c.version !== h.__version || !0 === l) {
                        n.activeTexture(e.TEXTURE0 + o);
                        const t = Ut.getPrimaries(Ut.workingColorSpace)
                          , i = s.colorSpace === qe ? null : Ut.getPrimaries(s.colorSpace)
                          , d = s.colorSpace === qe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                        const u = s.isCompressedTexture || s.image[0].isCompressedTexture
                          , f = s.image[0] && s.image[0].isDataTexture
                          , p = [];
                        for (let e = 0; e < 6; e++)
                            p[e] = u || f ? f ? s.image[e].image : s.image[e] : m(s.image[e], !0, r.maxCubemapSize),
                            p[e] = $(s, p[e]);
                        const _ = p[0]
                          , w = a.convert(s.format, s.colorSpace)
                          , x = a.convert(s.type)
                          , b = v(s.internalFormat, w, x, s.colorSpace)
                          , S = !0 !== s.isVideoTexture
                          , E = void 0 === h.__version || !0 === l
                          , M = c.dataReady;
                        let T, C = y(s, _);
                        if (R(e.TEXTURE_CUBE_MAP, s),
                        u) {
                            S && E && n.texStorage2D(e.TEXTURE_CUBE_MAP, C, b, _.width, _.height);
                            for (let t = 0; t < 6; t++) {
                                T = p[t].mipmaps;
                                for (let i = 0; i < T.length; i++) {
                                    const r = T[i];
                                    s.format !== re ? null !== w ? S ? M && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, w, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, b, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : S ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, w, x, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, b, r.width, r.height, 0, w, x, r.data)
                                }
                            }
                        } else {
                            if (T = s.mipmaps,
                            S && E) {
                                T.length > 0 && C++;
                                const t = ee(p[0]);
                                n.texStorage2D(e.TEXTURE_CUBE_MAP, C, b, t.width, t.height)
                            }
                            for (let t = 0; t < 6; t++)
                                if (f) {
                                    S ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, p[t].width, p[t].height, w, x, p[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, b, p[t].width, p[t].height, 0, w, x, p[t].data);
                                    for (let i = 0; i < T.length; i++) {
                                        const r = T[i].image[t].image;
                                        S ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, w, x, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, b, r.width, r.height, 0, w, x, r.data)
                                    }
                                } else {
                                    S ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, w, x, p[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, b, w, x, p[t]);
                                    for (let i = 0; i < T.length; i++) {
                                        const r = T[i];
                                        S ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, w, x, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, b, w, x, r.image[t])
                                    }
                                }
                        }
                        g(s) && A(e.TEXTURE_CUBE_MAP),
                        h.__version = c.version,
                        s.onUpdate && s.onUpdate(s)
                    }
                    t.__version = s.version
                }(o, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + s)
            }
            ,
            this.rebindTextures = function(t, n, r) {
                const a = i.get(t);
                void 0 !== n && D(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                void 0 !== r && U(t)
            }
            ,
            this.setupRenderTarget = function(t) {
                const r = t.texture
                  , o = i.get(t)
                  , l = i.get(r);
                t.addEventListener("dispose", b);
                const c = t.textures
                  , h = !0 === t.isWebGLCubeRenderTarget
                  , d = c.length > 1;
                if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()),
                l.__version = r.version,
                s.memory.textures++),
                h) {
                    o.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            o.__webglFramebuffer[t] = [];
                            for (let n = 0; n < r.mipmaps.length; n++)
                                o.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else
                            o.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        o.__webglFramebuffer = [];
                        for (let t = 0; t < r.mipmaps.length; t++)
                            o.__webglFramebuffer[t] = e.createFramebuffer()
                    } else
                        o.__webglFramebuffer = e.createFramebuffer();
                    if (d)
                        for (let t = 0, n = c.length; t < n; t++) {
                            const n = i.get(c[t]);
                            void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(),
                            s.memory.textures++)
                        }
                    if (t.samples > 0 && !1 === K(t)) {
                        o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                        o.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                        for (let n = 0; n < c.length; n++) {
                            const i = c[n];
                            o.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[n]);
                            const r = a.convert(i.format, i.colorSpace)
                              , s = a.convert(i.type)
                              , l = v(i.internalFormat, r, s, i.colorSpace, !0 === t.isXRRenderTarget)
                              , h = q(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, o.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null),
                        t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                        L(o.__webglDepthRenderbuffer, t, !0)),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (h) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
                    R(e.TEXTURE_CUBE_MAP, r);
                    for (let n = 0; n < 6; n++)
                        if (r.mipmaps && r.mipmaps.length > 0)
                            for (let i = 0; i < r.mipmaps.length; i++)
                                D(o.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            D(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    g(r) && A(e.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (d) {
                    for (let r = 0, a = c.length; r < a; r++) {
                        const a = c[r]
                          , s = i.get(a);
                        n.bindTexture(e.TEXTURE_2D, s.__webglTexture),
                        R(e.TEXTURE_2D, a),
                        D(o.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0),
                        g(a) && A(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                    n.bindTexture(i, l.__webglTexture),
                    R(i, r),
                    r.mipmaps && r.mipmaps.length > 0)
                        for (let n = 0; n < r.mipmaps.length; n++)
                            D(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                    else
                        D(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                    g(r) && A(i),
                    n.unbindTexture()
                }
                t.depthBuffer && U(t)
            }
            ,
            this.updateRenderTargetMipmap = function(e) {
                const t = e.textures;
                for (let r = 0, a = t.length; r < a; r++) {
                    const a = t[r];
                    if (g(a)) {
                        const t = _(e)
                          , r = i.get(a).__webglTexture;
                        n.bindTexture(t, r),
                        A(t),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(t) {
                if (t.samples > 0)
                    if (!1 === K(t)) {
                        const r = t.textures
                          , a = t.width
                          , s = t.height;
                        let o = e.COLOR_BUFFER_BIT;
                        const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                          , h = i.get(t)
                          , d = r.length > 1;
                        if (d)
                            for (let t = 0; t < r.length; t++)
                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(e.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                            t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                            d) {
                                e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, h.__webglColorRenderbuffer[n]);
                                const t = i.get(r[n]).__webglTexture;
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                            }
                            e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST),
                            !0 === l && (N.length = 0,
                            j.length = 0,
                            N.push(e.COLOR_ATTACHMENT0 + n),
                            t.depthBuffer && !1 === t.resolveDepthBuffer && (N.push(c),
                            j.push(c),
                            e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, j)),
                            e.invalidateFramebuffer(e.READ_FRAMEBUFFER, N))
                        }
                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        d)
                            for (let t = 0; t < r.length; t++) {
                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, h.__webglColorRenderbuffer[t]);
                                const a = i.get(r[t]).__webglTexture;
                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                            }
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                    } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                    }
            }
            ,
            this.setupDepthRenderbuffer = U,
            this.setupFrameBufferTexture = D,
            this.useMultisampledRTT = K
        }
        function Vp(e, t) {
            return {
                convert: function(n, i="") {
                    let r;
                    const a = Ut.getTransfer(i);
                    if (n === X)
                        return e.UNSIGNED_BYTE;
                    if (n === ee)
                        return e.UNSIGNED_SHORT_4_4_4_4;
                    if (n === te)
                        return e.UNSIGNED_SHORT_5_5_5_1;
                    if (n === ie)
                        return e.UNSIGNED_INT_5_9_9_9_REV;
                    if (n === j)
                        return e.BYTE;
                    if (n === q)
                        return e.SHORT;
                    if (n === Y)
                        return e.UNSIGNED_SHORT;
                    if (n === K)
                        return e.INT;
                    if (n === Z)
                        return e.UNSIGNED_INT;
                    if (n === J)
                        return e.FLOAT;
                    if (n === $)
                        return e.HALF_FLOAT;
                    if (1021 === n)
                        return e.ALPHA;
                    if (1022 === n)
                        return e.RGB;
                    if (n === re)
                        return e.RGBA;
                    if (1024 === n)
                        return e.LUMINANCE;
                    if (1025 === n)
                        return e.LUMINANCE_ALPHA;
                    if (n === ae)
                        return e.DEPTH_COMPONENT;
                    if (n === se)
                        return e.DEPTH_STENCIL;
                    if (n === oe)
                        return e.RED;
                    if (n === le)
                        return e.RED_INTEGER;
                    if (1030 === n)
                        return e.RG;
                    if (n === ce)
                        return e.RG_INTEGER;
                    if (n === he)
                        return e.RGBA_INTEGER;
                    if (n === de || n === ue || n === fe || n === pe)
                        if (a === Je) {
                            if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === r)
                                return null;
                            if (n === de)
                                return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === ue)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === fe)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === pe)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (r = t.get("WEBGL_compressed_texture_s3tc"),
                            null === r)
                                return null;
                            if (n === de)
                                return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === ue)
                                return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === fe)
                                return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === pe)
                                return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === me || n === ge || n === Ae || n === _e) {
                        if (r = t.get("WEBGL_compressed_texture_pvrtc"),
                        null === r)
                            return null;
                        if (n === me)
                            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === ge)
                            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === Ae)
                            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === _e)
                            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === ve || n === we || n === ye) {
                        if (r = t.get("WEBGL_compressed_texture_etc"),
                        null === r)
                            return null;
                        if (n === ve || n === we)
                            return a === Je ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (n === ye)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === xe || n === be || n === Se || n === Ee || n === Me || n === Te || n === Ce || n === Ie || n === Re || n === Pe || n === Be || n === De || n === Le || n === Ue) {
                        if (r = t.get("WEBGL_compressed_texture_astc"),
                        null === r)
                            return null;
                        if (n === xe)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === be)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === Se)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === Ee)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === Me)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === Te)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === Ce)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === Ie)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === Re)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === Pe)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === Be)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === De)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === Le)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === Ue)
                            return a === Je ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === Ne || n === ke || n === Fe) {
                        if (r = t.get("EXT_texture_compression_bptc"),
                        null === r)
                            return null;
                        if (n === Ne)
                            return a === Je ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (n === ke)
                            return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (n === Fe)
                            return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || n === Oe || n === ze || n === He) {
                        if (r = t.get("EXT_texture_compression_rgtc"),
                        null === r)
                            return null;
                        if (n === Ne)
                            return r.COMPRESSED_RED_RGTC1_EXT;
                        if (n === Oe)
                            return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (n === ze)
                            return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (n === He)
                            return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === ne ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class Gp {
            constructor() {
                this.texture = null,
                this.mesh = null,
                this.depthNear = 0,
                this.depthFar = 0
            }
            init(e, t, n) {
                if (null === this.texture) {
                    const i = new Gt;
                    e.properties.get(i).__webglTexture = t.texture,
                    t.depthNear === n.depthNear && t.depthFar === n.depthFar || (this.depthNear = t.depthNear,
                    this.depthFar = t.depthFar),
                    this.texture = i
                }
            }
            getMesh(e) {
                if (null !== this.texture && null === this.mesh) {
                    const t = e.cameras[0].viewport
                      , n = new rr({
                        vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                        fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                    this.mesh = new Zi(new ya(20,20),n)
                }
                return this.mesh
            }
            reset() {
                this.texture = null,
                this.mesh = null
            }
            getDepthTexture() {
                return this.texture
            }
        }
        class Qp extends ut {
            constructor(e, t) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , a = null
                  , s = "local-floor"
                  , o = 1
                  , l = null
                  , c = null
                  , h = null
                  , d = null
                  , u = null
                  , f = null;
                const p = new Gp
                  , m = t.getContextAttributes();
                let g = null
                  , A = null;
                const _ = []
                  , v = []
                  , w = new St;
                let y = null;
                const x = new cr;
                x.viewport = new Qt;
                const b = new cr;
                b.viewport = new Qt;
                const S = [x, b]
                  , E = new _s;
                let M = null
                  , T = null;
                function C(e) {
                    const t = v.indexOf(e.inputSource);
                    if (-1 === t)
                        return;
                    const n = _[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || a),
                    n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }
                function I() {
                    i.removeEventListener("select", C),
                    i.removeEventListener("selectstart", C),
                    i.removeEventListener("selectend", C),
                    i.removeEventListener("squeeze", C),
                    i.removeEventListener("squeezestart", C),
                    i.removeEventListener("squeezeend", C),
                    i.removeEventListener("end", I),
                    i.removeEventListener("inputsourceschange", R);
                    for (let e = 0; e < _.length; e++) {
                        const t = v[e];
                        null !== t && (v[e] = null,
                        _[e].disconnect(t))
                    }
                    M = null,
                    T = null,
                    p.reset(),
                    e.setRenderTarget(g),
                    u = null,
                    d = null,
                    h = null,
                    i = null,
                    A = null,
                    U.stop(),
                    n.isPresenting = !1,
                    e.setPixelRatio(y),
                    e.setSize(w.width, w.height, !1),
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function R(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t]
                          , i = v.indexOf(n);
                        i >= 0 && (v[i] = null,
                        _[i].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let i = v.indexOf(n);
                        if (-1 === i) {
                            for (let e = 0; e < _.length; e++) {
                                if (e >= v.length) {
                                    v.push(n),
                                    i = e;
                                    break
                                }
                                if (null === v[e]) {
                                    v[e] = n,
                                    i = e;
                                    break
                                }
                            }
                            if (-1 === i)
                                break
                        }
                        const r = _[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(e) {
                    let t = _[e];
                    return void 0 === t && (t = new gr,
                    _[e] = t),
                    t.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(e) {
                    let t = _[e];
                    return void 0 === t && (t = new gr,
                    _[e] = t),
                    t.getGripSpace()
                }
                ,
                this.getHand = function(e) {
                    let t = _[e];
                    return void 0 === t && (t = new gr,
                    _[e] = t),
                    t.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(e) {
                    r = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(e) {
                    s = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return l || a
                }
                ,
                this.setReferenceSpace = function(e) {
                    l = e
                }
                ,
                this.getBaseLayer = function() {
                    return null !== d ? d : u
                }
                ,
                this.getBinding = function() {
                    return h
                }
                ,
                this.getFrame = function() {
                    return f
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(c) {
                    if (i = c,
                    null !== i) {
                        g = e.getRenderTarget(),
                        i.addEventListener("select", C),
                        i.addEventListener("selectstart", C),
                        i.addEventListener("selectend", C),
                        i.addEventListener("squeeze", C),
                        i.addEventListener("squeezestart", C),
                        i.addEventListener("squeezeend", C),
                        i.addEventListener("end", I),
                        i.addEventListener("inputsourceschange", R),
                        !0 !== m.xrCompatible && await t.makeXRCompatible(),
                        y = e.getPixelRatio(),
                        e.getSize(w);
                        if ("undefined" != typeof XRWebGLBinding && "createProjectionLayer"in XRWebGLBinding.prototype) {
                            let n = null
                              , a = null
                              , s = null;
                            m.depth && (s = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                            n = m.stencil ? se : ae,
                            a = m.stencil ? ne : Z);
                            const o = {
                                colorFormat: t.RGBA8,
                                depthFormat: s,
                                scaleFactor: r
                            };
                            h = new XRWebGLBinding(i,t),
                            d = h.createProjectionLayer(o),
                            i.updateRenderState({
                                layers: [d]
                            }),
                            e.setPixelRatio(1),
                            e.setSize(d.textureWidth, d.textureHeight, !1),
                            A = new jt(d.textureWidth,d.textureHeight,{
                                format: re,
                                type: X,
                                depthTexture: new wa(d.textureWidth,d.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: m.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: m.antialias ? 4 : 0,
                                resolveDepthBuffer: !1 === d.ignoreDepthValues,
                                resolveStencilBuffer: !1 === d.ignoreDepthValues
                            })
                        } else {
                            const n = {
                                antialias: m.antialias,
                                alpha: !0,
                                depth: m.depth,
                                stencil: m.stencil,
                                framebufferScaleFactor: r
                            };
                            u = new XRWebGLLayer(i,t,n),
                            i.updateRenderState({
                                baseLayer: u
                            }),
                            e.setPixelRatio(1),
                            e.setSize(u.framebufferWidth, u.framebufferHeight, !1),
                            A = new jt(u.framebufferWidth,u.framebufferHeight,{
                                format: re,
                                type: X,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: m.stencil,
                                resolveDepthBuffer: !1 === u.ignoreDepthValues,
                                resolveStencilBuffer: !1 === u.ignoreDepthValues
                            })
                        }
                        A.isXRRenderTarget = !0,
                        this.setFoveation(o),
                        l = null,
                        a = await i.requestReferenceSpace(s),
                        U.setContext(i),
                        U.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== i)
                        return i.environmentBlendMode
                }
                ,
                this.getDepthTexture = function() {
                    return p.getDepthTexture()
                }
                ;
                const P = new Zt
                  , B = new Zt;
                function D(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === i)
                        return;
                    let t = e.near
                      , n = e.far;
                    null !== p.texture && (p.depthNear > 0 && (t = p.depthNear),
                    p.depthFar > 0 && (n = p.depthFar)),
                    E.near = b.near = x.near = t,
                    E.far = b.far = x.far = n,
                    M === E.near && T === E.far || (i.updateRenderState({
                        depthNear: E.near,
                        depthFar: E.far
                    }),
                    M = E.near,
                    T = E.far),
                    x.layers.mask = 2 | e.layers.mask,
                    b.layers.mask = 4 | e.layers.mask,
                    E.layers.mask = x.layers.mask | b.layers.mask;
                    const r = e.parent
                      , a = E.cameras;
                    D(E, r);
                    for (let e = 0; e < a.length; e++)
                        D(a[e], r);
                    2 === a.length ? function(e, t, n) {
                        P.setFromMatrixPosition(t.matrixWorld),
                        B.setFromMatrixPosition(n.matrixWorld);
                        const i = P.distanceTo(B)
                          , r = t.projectionMatrix.elements
                          , a = n.projectionMatrix.elements
                          , s = r[14] / (r[10] - 1)
                          , o = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , h = (r[8] - 1) / r[0]
                          , d = (a[8] + 1) / a[0]
                          , u = s * h
                          , f = s * d
                          , p = i / (-h + d)
                          , m = p * -h;
                        if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                        e.translateX(m),
                        e.translateZ(p),
                        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                        -1 === r[10])
                            e.projectionMatrix.copy(t.projectionMatrix),
                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                        else {
                            const t = s + p
                              , n = o + p
                              , r = u - m
                              , a = f + (i - m)
                              , h = l * o / n * t
                              , d = c * o / n * t;
                            e.projectionMatrix.makePerspective(r, a, h, d, t, n),
                            e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }
                    }(E, x, b) : E.projectionMatrix.copy(x.projectionMatrix),
                    function(e, t, n) {
                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                        e.matrix.invert(),
                        e.matrix.multiply(t.matrixWorld));
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        e.updateMatrixWorld(!0),
                        e.projectionMatrix.copy(t.projectionMatrix),
                        e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        e.isPerspectiveCamera && (e.fov = 2 * gt * Math.atan(1 / e.projectionMatrix.elements[5]),
                        e.zoom = 1)
                    }(e, E, r)
                }
                ,
                this.getCamera = function() {
                    return E
                }
                ,
                this.getFoveation = function() {
                    if (null !== d || null !== u)
                        return o
                }
                ,
                this.setFoveation = function(e) {
                    o = e,
                    null !== d && (d.fixedFoveation = e),
                    null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                }
                ,
                this.hasDepthSensing = function() {
                    return null !== p.texture
                }
                ,
                this.getDepthSensingMesh = function() {
                    return p.getMesh(E)
                }
                ;
                let L = null;
                const U = new fu;
                U.setAnimationLoop((function(t, r) {
                    if (c = r.getViewerPose(l || a),
                    f = r,
                    null !== c) {
                        const t = c.views;
                        null !== u && (e.setRenderTargetFramebuffer(A, u.framebuffer),
                        e.setRenderTarget(A));
                        let n = !1;
                        t.length !== E.cameras.length && (E.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let a = null;
                            if (null !== u)
                                a = u.getViewport(r);
                            else {
                                const t = h.getViewSubImage(d, r);
                                a = t.viewport,
                                0 === i && (e.setRenderTargetTextures(A, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                e.setRenderTarget(A))
                            }
                            let s = S[i];
                            void 0 === s && (s = new cr,
                            s.layers.enable(i),
                            s.viewport = new Qt,
                            S[i] = s),
                            s.matrix.fromArray(r.transform.matrix),
                            s.matrix.decompose(s.position, s.quaternion, s.scale),
                            s.projectionMatrix.fromArray(r.projectionMatrix),
                            s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),
                            s.viewport.set(a.x, a.y, a.width, a.height),
                            0 === i && (E.matrix.copy(s.matrix),
                            E.matrix.decompose(E.position, E.quaternion, E.scale)),
                            !0 === n && E.cameras.push(s)
                        }
                        const r = i.enabledFeatures;
                        if (r && r.includes("depth-sensing") && "gpu-optimized" == i.depthUsage && h) {
                            const n = h.getDepthInformation(t[0]);
                            n && n.isValid && n.texture && p.init(e, n, i.renderState)
                        }
                    }
                    for (let e = 0; e < _.length; e++) {
                        const t = v[e]
                          , n = _[e];
                        null !== t && void 0 !== n && n.update(t, r, l || a)
                    }
                    L && L(t, r),
                    r.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }),
                    f = null
                }
                )),
                this.setAnimationLoop = function(e) {
                    L = e
                }
                ,
                this.dispose = function() {}
            }
        }
        const Xp = new Fn
          , jp = new Cn;
        function qp(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(),
                t.value.copy(e.matrix)
            }
            function i(e, i) {
                e.opacity.value = i.opacity,
                i.color && e.diffuse.value.copy(i.color),
                i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                i.map && (e.map.value = i.map,
                n(i.map, e.mapTransform)),
                i.alphaMap && (e.alphaMap.value = i.alphaMap,
                n(i.alphaMap, e.alphaMapTransform)),
                i.bumpMap && (e.bumpMap.value = i.bumpMap,
                n(i.bumpMap, e.bumpMapTransform),
                e.bumpScale.value = i.bumpScale,
                1 === i.side && (e.bumpScale.value *= -1)),
                i.normalMap && (e.normalMap.value = i.normalMap,
                n(i.normalMap, e.normalMapTransform),
                e.normalScale.value.copy(i.normalScale),
                1 === i.side && e.normalScale.value.negate()),
                i.displacementMap && (e.displacementMap.value = i.displacementMap,
                n(i.displacementMap, e.displacementMapTransform),
                e.displacementScale.value = i.displacementScale,
                e.displacementBias.value = i.displacementBias),
                i.emissiveMap && (e.emissiveMap.value = i.emissiveMap,
                n(i.emissiveMap, e.emissiveMapTransform)),
                i.specularMap && (e.specularMap.value = i.specularMap,
                n(i.specularMap, e.specularMapTransform)),
                i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
                const r = t.get(i)
                  , a = r.envMap
                  , s = r.envMapRotation;
                a && (e.envMap.value = a,
                Xp.copy(s),
                Xp.x *= -1,
                Xp.y *= -1,
                Xp.z *= -1,
                a.isCubeTexture && !1 === a.isRenderTargetTexture && (Xp.y *= -1,
                Xp.z *= -1),
                e.envMapRotation.value.setFromMatrix4(jp.makeRotationFromEuler(Xp)),
                e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1,
                e.reflectivity.value = i.reflectivity,
                e.ior.value = i.ior,
                e.refractionRatio.value = i.refractionRatio),
                i.lightMap && (e.lightMap.value = i.lightMap,
                e.lightMapIntensity.value = i.lightMapIntensity,
                n(i.lightMap, e.lightMapTransform)),
                i.aoMap && (e.aoMap.value = i.aoMap,
                e.aoMapIntensity.value = i.aoMapIntensity,
                n(i.aoMap, e.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, nr(e)),
                    n.isFog ? (t.fogNear.value = n.near,
                    t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, r, a, s, o) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r),
                    function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, r)) : r.isMeshPhongMaterial ? (i(e, r),
                    function(e, t) {
                        e.specular.value.copy(t.specular),
                        e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, r)) : r.isMeshStandardMaterial ? (i(e, r),
                    function(e, t) {
                        e.metalness.value = t.metalness,
                        t.metalnessMap && (e.metalnessMap.value = t.metalnessMap,
                        n(t.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = t.roughness,
                        t.roughnessMap && (e.roughnessMap.value = t.roughnessMap,
                        n(t.roughnessMap, e.roughnessMapTransform));
                        t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                    }(e, r),
                    r.isMeshPhysicalMaterial && function(e, t, i) {
                        e.ior.value = t.ior,
                        t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                        e.sheenRoughness.value = t.sheenRoughness,
                        t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                        n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                        n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                        e.clearcoatRoughness.value = t.clearcoatRoughness,
                        t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                        t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                        n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                        t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                        1 === t.side && e.clearcoatNormalScale.value.negate()));
                        t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                        e.iridescenceIOR.value = t.iridescenceIOR,
                        e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                        e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                        t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                        t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                        n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission,
                        e.transmissionSamplerMap.value = i.texture,
                        e.transmissionSamplerSize.value.set(i.width, i.height),
                        t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                        n(t.transmissionMap, e.transmissionMapTransform)),
                        e.thickness.value = t.thickness,
                        t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                        n(t.thicknessMap, e.thicknessMapTransform)),
                        e.attenuationDistance.value = t.attenuationDistance,
                        e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                        t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity,
                        e.specularColor.value.copy(t.specularColor),
                        t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                        n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                        n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r),
                    function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r),
                    function(e, n) {
                        const i = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                        e.nearDistance.value = i.shadow.camera.near,
                        e.farDistance.value = i.shadow.camera.far
                    }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform))
                    }(e, r),
                    r.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize,
                        e.totalSize.value = t.dashSize + t.gapSize,
                        e.scale.value = t.scale
                    }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.size.value = t.size * i,
                        e.scale.value = .5 * r,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r, a, s) : r.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.rotation.value = t.rotation,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                    e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }
        function Yp(e, t, n, i) {
            let r = {}
              , a = {}
              , s = [];
            const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
            function l(e, t, n, i) {
                const r = e.value
                  , a = t + "_" + n;
                if (void 0 === i[a])
                    return i[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
                    !0;
                {
                    const e = i[a];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (e !== r)
                            return i[a] = r,
                            !0
                    } else if (!1 === e.equals(r))
                        return e.copy(r),
                        !0
                }
                return !1
            }
            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                t
            }
            function h(t) {
                const n = t.target;
                n.removeEventListener("dispose", h);
                const i = s.indexOf(n.__bindingPointIndex);
                s.splice(i, 1),
                e.deleteBuffer(r[n.id]),
                delete r[n.id],
                delete a[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    i.uniformBlockBinding(e, n)
                },
                update: function(n, d) {
                    let u = r[n.id];
                    void 0 === u && (!function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                            for (let e = 0, t = r.length; e < t; e++) {
                                const t = r[e]
                                  , a = Array.isArray(t.value) ? t.value : [t.value];
                                for (let e = 0, r = a.length; e < r; e++) {
                                    const r = c(a[e])
                                      , s = n % i
                                      , o = s % r.boundary
                                      , l = s + o;
                                    n += o,
                                    0 !== l && i - l < r.storage && (n += i - l),
                                    t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT),
                                    t.__offset = n,
                                    n += r.storage
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        e.__size = n,
                        e.__cache = {}
                    }(n),
                    u = function(t) {
                        const n = function() {
                            for (let e = 0; e < o; e++)
                                if (-1 === s.indexOf(e))
                                    return s.push(e),
                                    e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        t.__bindingPointIndex = n;
                        const i = e.createBuffer()
                          , r = t.__size
                          , a = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, i),
                        e.bufferData(e.UNIFORM_BUFFER, r, a),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                        i
                    }(n),
                    r[n.id] = u,
                    n.addEventListener("dispose", h));
                    const f = d.program;
                    i.updateUBOMapping(n, f);
                    const p = t.render.frame;
                    a[n.id] !== p && (!function(t) {
                        const n = r[t.id]
                          , i = t.uniforms
                          , a = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === l(r, t, i, a)) {
                                    const t = r.__offset
                                      , n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let a = 0; a < n.length; a++) {
                                        const s = n[a]
                                          , o = c(s);
                                        "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s,
                                        e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0],
                                        r.__data[1] = s.elements[1],
                                        r.__data[2] = s.elements[2],
                                        r.__data[3] = 0,
                                        r.__data[4] = s.elements[3],
                                        r.__data[5] = s.elements[4],
                                        r.__data[6] = s.elements[5],
                                        r.__data[7] = 0,
                                        r.__data[8] = s.elements[6],
                                        r.__data[9] = s.elements[7],
                                        r.__data[10] = s.elements[8],
                                        r.__data[11] = 0) : (s.toArray(r.__data, i),
                                        i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n),
                    a[n.id] = p)
                },
                dispose: function() {
                    for (const t in r)
                        e.deleteBuffer(r[t]);
                    s = [],
                    r = {},
                    a = {}
                }
            }
        }
        class Kp {
            constructor(t={}) {
                const {canvas: n=It(), context: i=null, depth: r=!0, stencil: a=!1, alpha: s=!1, antialias: o=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: d=!1, reverseDepthBuffer: u=!1} = t;
                let f;
                if (this.isWebGLRenderer = !0,
                null !== i) {
                    if ("undefined" != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext)
                        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                    f = i.getContextAttributes().alpha
                } else
                    f = s;
                const p = new Uint32Array(4)
                  , m = new Int32Array(4);
                let g = null
                  , A = null;
                const _ = []
                  , v = [];
                this.domElement = n,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = Ye,
                this.toneMapping = 0,
                this.toneMappingExposure = 1;
                const w = this;
                let y = !1
                  , x = 0
                  , b = 0
                  , S = null
                  , E = -1
                  , M = null;
                const T = new Qt
                  , C = new Qt;
                let I = null;
                const R = new wi(0);
                let P = 0
                  , B = n.width
                  , D = n.height
                  , L = 1
                  , U = null
                  , N = null;
                const k = new Qt(0,0,B,D)
                  , F = new Qt(0,0,B,D);
                let O = !1;
                const z = new Jr;
                let H = !1
                  , W = !1;
                this.transmissionResolutionScale = 1;
                const V = new Cn
                  , G = new Cn
                  , j = new Zt
                  , q = new Qt
                  , K = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                let J = !1;
                function ie() {
                    return null === S ? L : 1
                }
                let re, ae, se, oe, de, ue, fe, pe, me, ge, Ae, _e, ve, we, ye, xe, be, Se, Ee, Me, Te, Ce, Ie, Re, Pe = i;
                function Be(e, t) {
                    return n.getContext(e, t)
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: r,
                        stencil: a,
                        antialias: o,
                        premultipliedAlpha: l,
                        preserveDrawingBuffer: c,
                        powerPreference: h,
                        failIfMajorPerformanceCaveat: d
                    };
                    if ("setAttribute"in n && n.setAttribute("data-engine", `three.js r${e}`),
                    n.addEventListener("webglcontextlost", Ue, !1),
                    n.addEventListener("webglcontextrestored", Ne, !1),
                    n.addEventListener("webglcontextcreationerror", ke, !1),
                    null === Pe) {
                        const e = "webgl2";
                        if (Pe = Be(e, t),
                        null === Pe)
                            throw Be(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message),
                    e
                }
                function De() {
                    re = new Xu(Pe),
                    re.init(),
                    Ce = new Vp(Pe,re),
                    ae = new Su(Pe,re,t,Ce),
                    se = new Hp(Pe,re),
                    ae.reverseDepthBuffer && u && se.buffers.depth.setReversed(!0),
                    oe = new Yu(Pe),
                    de = new Cp,
                    ue = new Wp(Pe,re,se,de,ae,Ce,oe),
                    fe = new Mu(w),
                    pe = new Qu(w),
                    me = new pu(Pe),
                    Ie = new xu(Pe,me),
                    ge = new ju(Pe,me,oe,Ie),
                    Ae = new Zu(Pe,ge,me,oe),
                    Ee = new Ku(Pe,ae,ue),
                    xe = new Eu(de),
                    _e = new Tp(w,fe,pe,re,ae,Ie,xe),
                    ve = new qp(w,de),
                    we = new Bp,
                    ye = new Fp(re),
                    Se = new yu(w,fe,pe,se,Ae,f,l),
                    be = new Op(w,Ae,ae),
                    Re = new Yp(Pe,oe,ae,se),
                    Me = new bu(Pe,re,oe),
                    Te = new qu(Pe,re,oe),
                    oe.programs = _e.programs,
                    w.capabilities = ae,
                    w.extensions = re,
                    w.properties = de,
                    w.renderLists = we,
                    w.shadowMap = be,
                    w.state = se,
                    w.info = oe
                }
                De();
                const Le = new Qp(w,Pe);
                function Ue(e) {
                    e.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    y = !0
                }
                function Ne() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    y = !1;
                    const e = oe.autoReset
                      , t = be.enabled
                      , n = be.autoUpdate
                      , i = be.needsUpdate
                      , r = be.type;
                    De(),
                    oe.autoReset = e,
                    be.enabled = t,
                    be.autoUpdate = n,
                    be.needsUpdate = i,
                    be.type = r
                }
                function ke(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }
                function Fe(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Fe),
                    function(e) {
                        (function(e) {
                            const t = de.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                _e.releaseProgram(e)
                            }
                            )),
                            e.isShaderMaterial && _e.releaseShaderCache(e))
                        }
                        )(e),
                        de.remove(e)
                    }(t)
                }
                function Oe(e, t, n) {
                    !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1,
                    e.needsUpdate = !0,
                    Ze(e, t, n),
                    e.side = 0,
                    e.needsUpdate = !0,
                    Ze(e, t, n),
                    e.side = 2) : Ze(e, t, n)
                }
                this.xr = Le,
                this.getContext = function() {
                    return Pe
                }
                ,
                this.getContextAttributes = function() {
                    return Pe.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const e = re.get("WEBGL_lose_context");
                    e && e.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const e = re.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return L
                }
                ,
                this.setPixelRatio = function(e) {
                    void 0 !== e && (L = e,
                    this.setSize(B, D, !1))
                }
                ,
                this.getSize = function(e) {
                    return e.set(B, D)
                }
                ,
                this.setSize = function(e, t, i=!0) {
                    Le.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = e,
                    D = t,
                    n.width = Math.floor(e * L),
                    n.height = Math.floor(t * L),
                    !0 === i && (n.style.width = e + "px",
                    n.style.height = t + "px"),
                    this.setViewport(0, 0, e, t))
                }
                ,
                this.getDrawingBufferSize = function(e) {
                    return e.set(B * L, D * L).floor()
                }
                ,
                this.setDrawingBufferSize = function(e, t, i) {
                    B = e,
                    D = t,
                    L = i,
                    n.width = Math.floor(e * i),
                    n.height = Math.floor(t * i),
                    this.setViewport(0, 0, e, t)
                }
                ,
                this.getCurrentViewport = function(e) {
                    return e.copy(T)
                }
                ,
                this.getViewport = function(e) {
                    return e.copy(k)
                }
                ,
                this.setViewport = function(e, t, n, i) {
                    e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, i),
                    se.viewport(T.copy(k).multiplyScalar(L).round())
                }
                ,
                this.getScissor = function(e) {
                    return e.copy(F)
                }
                ,
                this.setScissor = function(e, t, n, i) {
                    e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, i),
                    se.scissor(C.copy(F).multiplyScalar(L).round())
                }
                ,
                this.getScissorTest = function() {
                    return O
                }
                ,
                this.setScissorTest = function(e) {
                    se.setScissorTest(O = e)
                }
                ,
                this.setOpaqueSort = function(e) {
                    U = e
                }
                ,
                this.setTransparentSort = function(e) {
                    N = e
                }
                ,
                this.getClearColor = function(e) {
                    return e.copy(Se.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    Se.setClearColor(...arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return Se.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    Se.setClearAlpha(...arguments)
                }
                ,
                this.clear = function(e=!0, t=!0, n=!0) {
                    let i = 0;
                    if (e) {
                        let e = !1;
                        if (null !== S) {
                            const t = S.texture.format;
                            e = t === he || t === ce || t === le
                        }
                        if (e) {
                            const e = S.texture.type
                              , t = e === X || e === Z || e === Y || e === ne || e === ee || e === te
                              , n = Se.getClearColor()
                              , i = Se.getClearAlpha()
                              , r = n.r
                              , a = n.g
                              , s = n.b;
                            t ? (p[0] = r,
                            p[1] = a,
                            p[2] = s,
                            p[3] = i,
                            Pe.clearBufferuiv(Pe.COLOR, 0, p)) : (m[0] = r,
                            m[1] = a,
                            m[2] = s,
                            m[3] = i,
                            Pe.clearBufferiv(Pe.COLOR, 0, m))
                        } else
                            i |= Pe.COLOR_BUFFER_BIT
                    }
                    t && (i |= Pe.DEPTH_BUFFER_BIT),
                    n && (i |= Pe.STENCIL_BUFFER_BIT,
                    this.state.buffers.stencil.setMask(4294967295)),
                    Pe.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    n.removeEventListener("webglcontextlost", Ue, !1),
                    n.removeEventListener("webglcontextrestored", Ne, !1),
                    n.removeEventListener("webglcontextcreationerror", ke, !1),
                    Se.dispose(),
                    we.dispose(),
                    ye.dispose(),
                    de.dispose(),
                    fe.dispose(),
                    pe.dispose(),
                    Ae.dispose(),
                    Ie.dispose(),
                    Re.dispose(),
                    _e.dispose(),
                    Le.dispose(),
                    Le.removeEventListener("sessionstart", He),
                    Le.removeEventListener("sessionend", We),
                    Ve.stop()
                }
                ,
                this.renderBufferDirect = function(e, t, n, i, r, a) {
                    null === t && (t = K);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0
                      , o = function(e, t, n, i, r) {
                        !0 !== t.isScene && (t = K);
                        ue.resetTextureUnits();
                        const a = t.fog
                          , s = i.isMeshStandardMaterial ? t.environment : null
                          , o = null === S ? w.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : Ke
                          , l = (i.isMeshStandardMaterial ? pe : fe).get(i.envMap || s)
                          , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                          , h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                          , d = !!n.morphAttributes.position
                          , u = !!n.morphAttributes.normal
                          , f = !!n.morphAttributes.color;
                        let p = 0;
                        i.toneMapped && (null !== S && !0 !== S.isXRRenderTarget || (p = w.toneMapping));
                        const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                          , g = void 0 !== m ? m.length : 0
                          , _ = de.get(i)
                          , v = A.state.lights;
                        if (!0 === H && (!0 === W || e !== M)) {
                            const t = e === M && i.id === E;
                            xe.setState(i, e, t)
                        }
                        let y = !1;
                        i.version === _.__version ? _.needsLights && _.lightsStateVersion !== v.state.version || _.outputColorSpace !== o || r.isBatchedMesh && !1 === _.batching ? y = !0 : r.isBatchedMesh || !0 !== _.batching ? r.isBatchedMesh && !0 === _.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === _.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === _.instancing ? y = !0 : r.isInstancedMesh || !0 !== _.instancing ? r.isSkinnedMesh && !1 === _.skinning ? y = !0 : r.isSkinnedMesh || !0 !== _.skinning ? r.isInstancedMesh && !0 === _.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === _.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === _.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === _.instancingMorph && null !== r.morphTexture || _.envMap !== l || !0 === i.fog && _.fog !== a ? y = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === xe.numPlanes && _.numIntersection === xe.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== h || _.morphTargets !== d || _.morphNormals !== u || _.morphColors !== f || _.toneMapping !== p || _.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : y = !0 : (y = !0,
                        _.__version = i.version);
                        let x = _.currentProgram;
                        !0 === y && (x = Ze(i, t, r));
                        let b = !1
                          , T = !1
                          , C = !1;
                        const I = x.getUniforms()
                          , R = _.uniforms;
                        se.useProgram(x.program) && (b = !0,
                        T = !0,
                        C = !0);
                        i.id !== E && (E = i.id,
                        T = !0);
                        if (b || M !== e) {
                            se.buffers.depth.getReversed() ? (V.copy(e.projectionMatrix),
                            function(e) {
                                const t = e.elements;
                                t[2] = .5 * t[2] + .5 * t[3],
                                t[6] = .5 * t[6] + .5 * t[7],
                                t[10] = .5 * t[10] + .5 * t[11],
                                t[14] = .5 * t[14] + .5 * t[15]
                            }(V),
                            function(e) {
                                const t = e.elements;
                                -1 === t[11] ? (t[10] = -t[10] - 1,
                                t[14] = -t[14]) : (t[10] = -t[10],
                                t[14] = 1 - t[14])
                            }(V),
                            I.setValue(Pe, "projectionMatrix", V)) : I.setValue(Pe, "projectionMatrix", e.projectionMatrix),
                            I.setValue(Pe, "viewMatrix", e.matrixWorldInverse);
                            const t = I.map.cameraPosition;
                            void 0 !== t && t.setValue(Pe, j.setFromMatrixPosition(e.matrixWorld)),
                            ae.logarithmicDepthBuffer && I.setValue(Pe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && I.setValue(Pe, "isOrthographic", !0 === e.isOrthographicCamera),
                            M !== e && (M = e,
                            T = !0,
                            C = !0)
                        }
                        if (r.isSkinnedMesh) {
                            I.setOptional(Pe, r, "bindMatrix"),
                            I.setOptional(Pe, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            e && (null === e.boneTexture && e.computeBoneTexture(),
                            I.setValue(Pe, "boneTexture", e.boneTexture, ue))
                        }
                        r.isBatchedMesh && (I.setOptional(Pe, r, "batchingTexture"),
                        I.setValue(Pe, "batchingTexture", r._matricesTexture, ue),
                        I.setOptional(Pe, r, "batchingIdTexture"),
                        I.setValue(Pe, "batchingIdTexture", r._indirectTexture, ue),
                        I.setOptional(Pe, r, "batchingColorTexture"),
                        null !== r._colorsTexture && I.setValue(Pe, "batchingColorTexture", r._colorsTexture, ue));
                        const P = n.morphAttributes;
                        void 0 === P.position && void 0 === P.normal && void 0 === P.color || Ee.update(r, n, x);
                        (T || _.receiveShadow !== r.receiveShadow) && (_.receiveShadow = r.receiveShadow,
                        I.setValue(Pe, "receiveShadow", r.receiveShadow));
                        i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l,
                        R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                        i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (R.envMapIntensity.value = t.environmentIntensity);
                        T && (I.setValue(Pe, "toneMappingExposure", w.toneMappingExposure),
                        _.needsLights && (U = C,
                        (B = R).ambientLightColor.needsUpdate = U,
                        B.lightProbe.needsUpdate = U,
                        B.directionalLights.needsUpdate = U,
                        B.directionalLightShadows.needsUpdate = U,
                        B.pointLights.needsUpdate = U,
                        B.pointLightShadows.needsUpdate = U,
                        B.spotLights.needsUpdate = U,
                        B.spotLightShadows.needsUpdate = U,
                        B.rectAreaLights.needsUpdate = U,
                        B.hemisphereLights.needsUpdate = U),
                        a && !0 === i.fog && ve.refreshFogUniforms(R, a),
                        ve.refreshMaterialUniforms(R, i, L, D, A.state.transmissionRenderTarget[e.id]),
                        ip.upload(Pe, Je(_), R, ue));
                        var B, U;
                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ip.upload(Pe, Je(_), R, ue),
                        i.uniformsNeedUpdate = !1);
                        i.isSpriteMaterial && I.setValue(Pe, "center", r.center);
                        if (I.setValue(Pe, "modelViewMatrix", r.modelViewMatrix),
                        I.setValue(Pe, "normalMatrix", r.normalMatrix),
                        I.setValue(Pe, "modelMatrix", r.matrixWorld),
                        i.isShaderMaterial || i.isRawShaderMaterial) {
                            const e = i.uniformsGroups;
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                Re.update(n, x),
                                Re.bind(n, x)
                            }
                        }
                        return x
                    }(e, t, n, i, r);
                    se.setMaterial(i, s);
                    let l = n.index
                      , c = 1;
                    if (!0 === i.wireframe) {
                        if (l = ge.getWireframeAttribute(n),
                        void 0 === l)
                            return;
                        c = 2
                    }
                    const h = n.drawRange
                      , d = n.attributes.position;
                    let u = h.start * c
                      , f = (h.start + h.count) * c;
                    null !== a && (u = Math.max(u, a.start * c),
                    f = Math.min(f, (a.start + a.count) * c)),
                    null !== l ? (u = Math.max(u, 0),
                    f = Math.min(f, l.count)) : null != d && (u = Math.max(u, 0),
                    f = Math.min(f, d.count));
                    const p = f - u;
                    if (p < 0 || p === 1 / 0)
                        return;
                    let m;
                    Ie.setup(r, i, o, n, l);
                    let g = Me;
                    if (null !== l && (m = me.get(l),
                    g = Te,
                    g.setIndex(m)),
                    r.isMesh)
                        !0 === i.wireframe ? (se.setLineWidth(i.wireframeLinewidth * ie()),
                        g.setMode(Pe.LINES)) : g.setMode(Pe.TRIANGLES);
                    else if (r.isLine) {
                        let e = i.linewidth;
                        void 0 === e && (e = 1),
                        se.setLineWidth(e * ie()),
                        r.isLineSegments ? g.setMode(Pe.LINES) : r.isLineLoop ? g.setMode(Pe.LINE_LOOP) : g.setMode(Pe.LINE_STRIP)
                    } else
                        r.isPoints ? g.setMode(Pe.POINTS) : r.isSprite && g.setMode(Pe.TRIANGLES);
                    if (r.isBatchedMesh)
                        if (null !== r._multiDrawInstances)
                            Pt("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                            g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                        else if (re.get("WEBGL_multi_draw"))
                            g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                        else {
                            const e = r._multiDrawStarts
                              , t = r._multiDrawCounts
                              , n = r._multiDrawCount
                              , a = l ? me.get(l).bytesPerElement : 1
                              , s = de.get(i).currentProgram.getUniforms();
                            for (let i = 0; i < n; i++)
                                s.setValue(Pe, "_gl_DrawID", i),
                                g.render(e[i] / a, t[i])
                        }
                    else if (r.isInstancedMesh)
                        g.renderInstances(u, p, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , t = Math.min(n.instanceCount, e);
                        g.renderInstances(u, p, t)
                    } else
                        g.render(u, p)
                }
                ,
                this.compile = function(e, t, n=null) {
                    null === n && (n = e),
                    A = ye.get(n),
                    A.init(t),
                    v.push(A),
                    n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (A.pushLight(e),
                        e.castShadow && A.pushShadow(e))
                    }
                    )),
                    e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (A.pushLight(e),
                        e.castShadow && A.pushShadow(e))
                    }
                    )),
                    A.setupLights();
                    const i = new Set;
                    return e.traverse((function(e) {
                        if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                            return;
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let r = 0; r < t.length; r++) {
                                    const a = t[r];
                                    Oe(a, n, e),
                                    i.add(a)
                                }
                            else
                                Oe(t, n, e),
                                i.add(t)
                    }
                    )),
                    A = v.pop(),
                    i
                }
                ,
                this.compileAsync = function(e, t, n=null) {
                    const i = this.compile(e, t, n);
                    return new Promise((t => {
                        function n() {
                            i.forEach((function(e) {
                                de.get(e).currentProgram.isReady() && i.delete(e)
                            }
                            )),
                            0 !== i.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== re.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }
                    ))
                }
                ;
                let ze = null;
                function He() {
                    Ve.stop()
                }
                function We() {
                    Ve.start()
                }
                const Ve = new fu;
                function Ge(e, t, n, i) {
                    if (!1 === e.visible)
                        return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup)
                            n = e.renderOrder;
                        else if (e.isLOD)
                            !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight)
                            A.pushLight(e),
                            e.castShadow && A.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || z.intersectsSprite(e)) {
                                i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                                const t = Ae.update(e)
                                  , r = e.material;
                                r.visible && g.push(e, t, r, n, q.z, null)
                            }
                        } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || z.intersectsObject(e))) {
                            const t = Ae.update(e)
                              , r = e.material;
                            if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                            q.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                            q.copy(t.boundingSphere.center)),
                            q.applyMatrix4(e.matrixWorld).applyMatrix4(G)),
                            Array.isArray(r)) {
                                const i = t.groups;
                                for (let a = 0, s = i.length; a < s; a++) {
                                    const s = i[a]
                                      , o = r[s.materialIndex];
                                    o && o.visible && g.push(e, t, o, n, q.z, s)
                                }
                            } else
                                r.visible && g.push(e, t, r, n, q.z, null)
                        }
                    const r = e.children;
                    for (let e = 0, a = r.length; e < a; e++)
                        Ge(r[e], t, n, i)
                }
                function Qe(e, t, n, i) {
                    const r = e.opaque
                      , a = e.transmissive
                      , s = e.transparent;
                    A.setupLightsView(n),
                    !0 === H && xe.setGlobalState(w.clippingPlanes, n),
                    i && se.viewport(T.copy(i)),
                    r.length > 0 && je(r, t, n),
                    a.length > 0 && je(a, t, n),
                    s.length > 0 && je(s, t, n),
                    se.buffers.depth.setTest(!0),
                    se.buffers.depth.setMask(!0),
                    se.buffers.color.setMask(!0),
                    se.setPolygonOffset(!1)
                }
                function Xe(e, t, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                        return;
                    void 0 === A.state.transmissionRenderTarget[i.id] && (A.state.transmissionRenderTarget[i.id] = new jt(1,1,{
                        generateMipmaps: !0,
                        type: re.has("EXT_color_buffer_half_float") || re.has("EXT_color_buffer_float") ? $ : X,
                        minFilter: Q,
                        samples: 4,
                        stencilBuffer: a,
                        resolveDepthBuffer: !1,
                        resolveStencilBuffer: !1,
                        colorSpace: Ut.workingColorSpace
                    }));
                    const r = A.state.transmissionRenderTarget[i.id]
                      , s = i.viewport || T;
                    r.setSize(s.z * w.transmissionResolutionScale, s.w * w.transmissionResolutionScale);
                    const o = w.getRenderTarget();
                    w.setRenderTarget(r),
                    w.getClearColor(R),
                    P = w.getClearAlpha(),
                    P < 1 && w.setClearColor(16777215, .5),
                    w.clear(),
                    J && Se.render(n);
                    const l = w.toneMapping;
                    w.toneMapping = 0;
                    const c = i.viewport;
                    if (void 0 !== i.viewport && (i.viewport = void 0),
                    A.setupLightsView(i),
                    !0 === H && xe.setGlobalState(w.clippingPlanes, i),
                    je(e, n, i),
                    ue.updateMultisampleRenderTarget(r),
                    ue.updateRenderTargetMipmap(r),
                    !1 === re.has("WEBGL_multisampled_render_to_texture")) {
                        let e = !1;
                        for (let r = 0, a = t.length; r < a; r++) {
                            const a = t[r]
                              , s = a.object
                              , o = a.geometry
                              , l = a.material
                              , c = a.group;
                            if (2 === l.side && s.layers.test(i.layers)) {
                                const t = l.side;
                                l.side = 1,
                                l.needsUpdate = !0,
                                qe(s, n, i, o, l, c),
                                l.side = t,
                                l.needsUpdate = !0,
                                e = !0
                            }
                        }
                        !0 === e && (ue.updateMultisampleRenderTarget(r),
                        ue.updateRenderTargetMipmap(r))
                    }
                    w.setRenderTarget(o),
                    w.setClearColor(R, P),
                    void 0 !== c && (i.viewport = c),
                    w.toneMapping = l
                }
                function je(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, a = e.length; r < a; r++) {
                        const a = e[r]
                          , s = a.object
                          , o = a.geometry
                          , l = null === i ? a.material : i
                          , c = a.group;
                        s.layers.test(n.layers) && qe(s, t, n, o, l, c)
                    }
                }
                function qe(e, t, n, i, r, a) {
                    e.onBeforeRender(w, t, n, i, r, a),
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                    e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                    r.onBeforeRender(w, t, n, i, e, a),
                    !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1,
                    r.needsUpdate = !0,
                    w.renderBufferDirect(n, t, i, r, e, a),
                    r.side = 0,
                    r.needsUpdate = !0,
                    w.renderBufferDirect(n, t, i, r, e, a),
                    r.side = 2) : w.renderBufferDirect(n, t, i, r, e, a),
                    e.onAfterRender(w, t, n, i, r, a)
                }
                function Ze(e, t, n) {
                    !0 !== t.isScene && (t = K);
                    const i = de.get(e)
                      , r = A.state.lights
                      , a = A.state.shadowsArray
                      , s = r.state.version
                      , o = _e.getParameters(e, r.state, a, t, n)
                      , l = _e.getProgramCacheKey(o);
                    let c = i.programs;
                    i.environment = e.isMeshStandardMaterial ? t.environment : null,
                    i.fog = t.fog,
                    i.envMap = (e.isMeshStandardMaterial ? pe : fe).get(e.envMap || i.environment),
                    i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
                    void 0 === c && (e.addEventListener("dispose", Fe),
                    c = new Map,
                    i.programs = c);
                    let h = c.get(l);
                    if (void 0 !== h) {
                        if (i.currentProgram === h && i.lightsStateVersion === s)
                            return $e(e, o),
                            h
                    } else
                        o.uniforms = _e.getUniforms(e),
                        e.onBeforeCompile(o, w),
                        h = _e.acquireProgram(o, l),
                        c.set(l, h),
                        i.uniforms = o.uniforms;
                    const d = i.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = xe.uniform),
                    $e(e, o),
                    i.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e),
                    i.lightsStateVersion = s,
                    i.needsLights && (d.ambientLightColor.value = r.state.ambient,
                    d.lightProbe.value = r.state.probe,
                    d.directionalLights.value = r.state.directional,
                    d.directionalLightShadows.value = r.state.directionalShadow,
                    d.spotLights.value = r.state.spot,
                    d.spotLightShadows.value = r.state.spotShadow,
                    d.rectAreaLights.value = r.state.rectArea,
                    d.ltc_1.value = r.state.rectAreaLTC1,
                    d.ltc_2.value = r.state.rectAreaLTC2,
                    d.pointLights.value = r.state.point,
                    d.pointLightShadows.value = r.state.pointShadow,
                    d.hemisphereLights.value = r.state.hemi,
                    d.directionalShadowMap.value = r.state.directionalShadowMap,
                    d.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    d.spotShadowMap.value = r.state.spotShadowMap,
                    d.spotLightMatrix.value = r.state.spotLightMatrix,
                    d.spotLightMap.value = r.state.spotLightMap,
                    d.pointShadowMap.value = r.state.pointShadowMap,
                    d.pointShadowMatrix.value = r.state.pointShadowMatrix),
                    i.currentProgram = h,
                    i.uniformsList = null,
                    h
                }
                function Je(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = ip.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }
                function $e(e, t) {
                    const n = de.get(e);
                    n.outputColorSpace = t.outputColorSpace,
                    n.batching = t.batching,
                    n.batchingColor = t.batchingColor,
                    n.instancing = t.instancing,
                    n.instancingColor = t.instancingColor,
                    n.instancingMorph = t.instancingMorph,
                    n.skinning = t.skinning,
                    n.morphTargets = t.morphTargets,
                    n.morphNormals = t.morphNormals,
                    n.morphColors = t.morphColors,
                    n.morphTargetsCount = t.morphTargetsCount,
                    n.numClippingPlanes = t.numClippingPlanes,
                    n.numIntersection = t.numClipIntersection,
                    n.vertexAlphas = t.vertexAlphas,
                    n.vertexTangents = t.vertexTangents,
                    n.toneMapping = t.toneMapping
                }
                Ve.setAnimationLoop((function(e) {
                    ze && ze(e)
                }
                )),
                "undefined" != typeof self && Ve.setContext(self),
                this.setAnimationLoop = function(e) {
                    ze = e,
                    Le.setAnimationLoop(e),
                    null === e ? Ve.stop() : Ve.start()
                }
                ,
                Le.addEventListener("sessionstart", He),
                Le.addEventListener("sessionend", We),
                this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === y)
                        return;
                    if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    !0 === Le.enabled && !0 === Le.isPresenting && (!0 === Le.cameraAutoUpdate && Le.updateCamera(t),
                    t = Le.getCamera()),
                    !0 === e.isScene && e.onBeforeRender(w, e, t, S),
                    A = ye.get(e, v.length),
                    A.init(t),
                    v.push(A),
                    G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    z.setFromProjectionMatrix(G),
                    W = this.localClippingEnabled,
                    H = xe.init(this.clippingPlanes, W),
                    g = we.get(e, _.length),
                    g.init(),
                    _.push(g),
                    !0 === Le.enabled && !0 === Le.isPresenting) {
                        const e = w.xr.getDepthSensingMesh();
                        null !== e && Ge(e, t, -1 / 0, w.sortObjects)
                    }
                    Ge(e, t, 0, w.sortObjects),
                    g.finish(),
                    !0 === w.sortObjects && g.sort(U, N),
                    J = !1 === Le.enabled || !1 === Le.isPresenting || !1 === Le.hasDepthSensing(),
                    J && Se.addToRenderList(g, e),
                    this.info.render.frame++,
                    !0 === H && xe.beginShadows();
                    const n = A.state.shadowsArray;
                    be.render(n, e, t),
                    !0 === H && xe.endShadows(),
                    !0 === this.info.autoReset && this.info.reset();
                    const i = g.opaque
                      , r = g.transmissive;
                    if (A.setupLights(),
                    t.isArrayCamera) {
                        const n = t.cameras;
                        if (r.length > 0)
                            for (let t = 0, a = n.length; t < a; t++) {
                                Xe(i, r, e, n[t])
                            }
                        J && Se.render(e);
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            Qe(g, e, i, i.viewport)
                        }
                    } else
                        r.length > 0 && Xe(i, r, e, t),
                        J && Se.render(e),
                        Qe(g, e, t);
                    null !== S && 0 === b && (ue.updateMultisampleRenderTarget(S),
                    ue.updateRenderTargetMipmap(S)),
                    !0 === e.isScene && e.onAfterRender(w, e, t),
                    Ie.resetDefaultState(),
                    E = -1,
                    M = null,
                    v.pop(),
                    v.length > 0 ? (A = v[v.length - 1],
                    !0 === H && xe.setGlobalState(w.clippingPlanes, A.state.camera)) : A = null,
                    _.pop(),
                    g = _.length > 0 ? _[_.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return x
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return b
                }
                ,
                this.getRenderTarget = function() {
                    return S
                }
                ,
                this.setRenderTargetTextures = function(e, t, n) {
                    de.get(e.texture).__webglTexture = t,
                    de.get(e.depthTexture).__webglTexture = n;
                    const i = de.get(e);
                    i.__hasExternalTextures = !0,
                    i.__autoAllocateDepthBuffer = void 0 === n,
                    i.__autoAllocateDepthBuffer || !0 === re.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    i.__useRenderToTexture = !1)
                }
                ,
                this.setRenderTargetFramebuffer = function(e, t) {
                    const n = de.get(e);
                    n.__webglFramebuffer = t,
                    n.__useDefaultFramebuffer = void 0 === t
                }
                ;
                const et = Pe.createFramebuffer();
                this.setRenderTarget = function(e, t=0, n=0) {
                    S = e,
                    x = t,
                    b = n;
                    let i = !0
                      , r = null
                      , a = !1
                      , s = !1;
                    if (e) {
                        const o = de.get(e);
                        if (void 0 !== o.__useDefaultFramebuffer)
                            se.bindFramebuffer(Pe.FRAMEBUFFER, null),
                            i = !1;
                        else if (void 0 === o.__webglFramebuffer)
                            ue.setupRenderTarget(e);
                        else if (o.__hasExternalTextures)
                            ue.rebindTextures(e, de.get(e.texture).__webglTexture, de.get(e.depthTexture).__webglTexture);
                        else if (e.depthBuffer) {
                            const t = e.depthTexture;
                            if (o.__boundDepthTexture !== t) {
                                if (null !== t && de.has(t) && (e.width !== t.image.width || e.height !== t.image.height))
                                    throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                ue.setupDepthRenderbuffer(e)
                            }
                        }
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                        const c = de.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t],
                        a = !0) : r = e.samples > 0 && !1 === ue.useMultisampledRTT(e) ? de.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                        T.copy(e.viewport),
                        C.copy(e.scissor),
                        I = e.scissorTest
                    } else
                        T.copy(k).multiplyScalar(L).floor(),
                        C.copy(F).multiplyScalar(L).floor(),
                        I = O;
                    0 !== n && (r = et);
                    if (se.bindFramebuffer(Pe.FRAMEBUFFER, r) && i && se.drawBuffers(e, r),
                    se.viewport(T),
                    se.scissor(C),
                    se.setScissorTest(I),
                    a) {
                        const i = de.get(e.texture);
                        Pe.framebufferTexture2D(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                    } else if (s) {
                        const i = de.get(e.texture)
                          , r = t;
                        Pe.framebufferTextureLayer(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, i.__webglTexture, n, r)
                    } else if (null !== e && 0 !== n) {
                        const t = de.get(e.texture);
                        Pe.framebufferTexture2D(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_2D, t.__webglTexture, n)
                    }
                    E = -1
                }
                ,
                this.readRenderTargetPixels = function(e, t, n, i, r, a, s) {
                    if (!e || !e.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = de.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                    o) {
                        se.bindFramebuffer(Pe.FRAMEBUFFER, o);
                        try {
                            const s = e.texture
                              , o = s.format
                              , l = s.type;
                            if (!ae.textureFormatReadable(o))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!ae.textureTypeReadable(l))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Pe.readPixels(t, n, i, r, Ce.convert(o), Ce.convert(l), a)
                        } finally {
                            const e = null !== S ? de.get(S).__webglFramebuffer : null;
                            se.bindFramebuffer(Pe.FRAMEBUFFER, e)
                        }
                    }
                }
                ,
                this.readRenderTargetPixelsAsync = async function(e, t, n, i, r, a, s) {
                    if (!e || !e.isWebGLRenderTarget)
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = de.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                    o) {
                        const s = e.texture
                          , l = s.format
                          , c = s.type;
                        if (!ae.textureFormatReadable(l))
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                        if (!ae.textureTypeReadable(c))
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                        if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                            se.bindFramebuffer(Pe.FRAMEBUFFER, o);
                            const e = Pe.createBuffer();
                            Pe.bindBuffer(Pe.PIXEL_PACK_BUFFER, e),
                            Pe.bufferData(Pe.PIXEL_PACK_BUFFER, a.byteLength, Pe.STREAM_READ),
                            Pe.readPixels(t, n, i, r, Ce.convert(l), Ce.convert(c), 0);
                            const s = null !== S ? de.get(S).__webglFramebuffer : null;
                            se.bindFramebuffer(Pe.FRAMEBUFFER, s);
                            const h = Pe.fenceSync(Pe.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            return Pe.flush(),
                            await function(e, t, n) {
                                return new Promise((function(i, r) {
                                    setTimeout((function a() {
                                        switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                        case e.WAIT_FAILED:
                                            r();
                                            break;
                                        case e.TIMEOUT_EXPIRED:
                                            setTimeout(a, n);
                                            break;
                                        default:
                                            i()
                                        }
                                    }
                                    ), n)
                                }
                                ))
                            }(Pe, h, 4),
                            Pe.bindBuffer(Pe.PIXEL_PACK_BUFFER, e),
                            Pe.getBufferSubData(Pe.PIXEL_PACK_BUFFER, 0, a),
                            Pe.deleteBuffer(e),
                            Pe.deleteSync(h),
                            a
                        }
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                    }
                }
                ,
                this.copyFramebufferToTexture = function(e, t=null, n=0) {
                    !0 !== e.isTexture && (Pt("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
                    t = arguments[0] || null,
                    e = arguments[1]);
                    const i = Math.pow(2, -n)
                      , r = Math.floor(e.image.width * i)
                      , a = Math.floor(e.image.height * i)
                      , s = null !== t ? t.x : 0
                      , o = null !== t ? t.y : 0;
                    ue.setTexture2D(e, 0),
                    Pe.copyTexSubImage2D(Pe.TEXTURE_2D, n, 0, 0, s, o, r, a),
                    se.unbindTexture()
                }
                ;
                const tt = Pe.createFramebuffer()
                  , nt = Pe.createFramebuffer();
                this.copyTextureToTexture = function(e, t, n=null, i=null, r=0, a=null) {
                    let s, o, l, c, h, d, u, f, p;
                    !0 !== e.isTexture && (Pt("WebGLRenderer: copyTextureToTexture function signature has changed."),
                    i = arguments[0] || null,
                    e = arguments[1],
                    t = arguments[2],
                    a = arguments[3] || 0,
                    n = null),
                    null === a && (0 !== r ? (Pt("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                    a = r,
                    r = 0) : a = 0);
                    const m = e.isCompressedTexture ? e.mipmaps[a] : e.image;
                    if (null !== n)
                        s = n.max.x - n.min.x,
                        o = n.max.y - n.min.y,
                        l = n.isBox3 ? n.max.z - n.min.z : 1,
                        c = n.min.x,
                        h = n.min.y,
                        d = n.isBox3 ? n.min.z : 0;
                    else {
                        const t = Math.pow(2, -r);
                        s = Math.floor(m.width * t),
                        o = Math.floor(m.height * t),
                        l = e.isDataArrayTexture ? m.depth : e.isData3DTexture ? Math.floor(m.depth * t) : 1,
                        c = 0,
                        h = 0,
                        d = 0
                    }
                    null !== i ? (u = i.x,
                    f = i.y,
                    p = i.z) : (u = 0,
                    f = 0,
                    p = 0);
                    const g = Ce.convert(t.format)
                      , A = Ce.convert(t.type);
                    let _;
                    t.isData3DTexture ? (ue.setTexture3D(t, 0),
                    _ = Pe.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (ue.setTexture2DArray(t, 0),
                    _ = Pe.TEXTURE_2D_ARRAY) : (ue.setTexture2D(t, 0),
                    _ = Pe.TEXTURE_2D),
                    Pe.pixelStorei(Pe.UNPACK_FLIP_Y_WEBGL, t.flipY),
                    Pe.pixelStorei(Pe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
                    Pe.pixelStorei(Pe.UNPACK_ALIGNMENT, t.unpackAlignment);
                    const v = Pe.getParameter(Pe.UNPACK_ROW_LENGTH)
                      , w = Pe.getParameter(Pe.UNPACK_IMAGE_HEIGHT)
                      , y = Pe.getParameter(Pe.UNPACK_SKIP_PIXELS)
                      , x = Pe.getParameter(Pe.UNPACK_SKIP_ROWS)
                      , b = Pe.getParameter(Pe.UNPACK_SKIP_IMAGES);
                    Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, m.width),
                    Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, m.height),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, c),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, h),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, d);
                    const S = e.isDataArrayTexture || e.isData3DTexture
                      , E = t.isDataArrayTexture || t.isData3DTexture;
                    if (e.isDepthTexture) {
                        const n = de.get(e)
                          , i = de.get(t)
                          , m = de.get(n.__renderTarget)
                          , g = de.get(i.__renderTarget);
                        se.bindFramebuffer(Pe.READ_FRAMEBUFFER, m.__webglFramebuffer),
                        se.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, g.__webglFramebuffer);
                        for (let n = 0; n < l; n++)
                            S && (Pe.framebufferTextureLayer(Pe.READ_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, de.get(e).__webglTexture, r, d + n),
                            Pe.framebufferTextureLayer(Pe.DRAW_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, de.get(t).__webglTexture, a, p + n)),
                            Pe.blitFramebuffer(c, h, s, o, u, f, s, o, Pe.DEPTH_BUFFER_BIT, Pe.NEAREST);
                        se.bindFramebuffer(Pe.READ_FRAMEBUFFER, null),
                        se.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, null)
                    } else if (0 !== r || e.isRenderTargetTexture || de.has(e)) {
                        const n = de.get(e)
                          , i = de.get(t);
                        se.bindFramebuffer(Pe.READ_FRAMEBUFFER, tt),
                        se.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, nt);
                        for (let e = 0; e < l; e++)
                            S ? Pe.framebufferTextureLayer(Pe.READ_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, n.__webglTexture, r, d + e) : Pe.framebufferTexture2D(Pe.READ_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_2D, n.__webglTexture, r),
                            E ? Pe.framebufferTextureLayer(Pe.DRAW_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, i.__webglTexture, a, p + e) : Pe.framebufferTexture2D(Pe.DRAW_FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_2D, i.__webglTexture, a),
                            0 !== r ? Pe.blitFramebuffer(c, h, s, o, u, f, s, o, Pe.COLOR_BUFFER_BIT, Pe.NEAREST) : E ? Pe.copyTexSubImage3D(_, a, u, f, p + e, c, h, s, o) : Pe.copyTexSubImage2D(_, a, u, f, c, h, s, o);
                        se.bindFramebuffer(Pe.READ_FRAMEBUFFER, null),
                        se.bindFramebuffer(Pe.DRAW_FRAMEBUFFER, null)
                    } else
                        E ? e.isDataTexture || e.isData3DTexture ? Pe.texSubImage3D(_, a, u, f, p, s, o, l, g, A, m.data) : t.isCompressedArrayTexture ? Pe.compressedTexSubImage3D(_, a, u, f, p, s, o, l, g, m.data) : Pe.texSubImage3D(_, a, u, f, p, s, o, l, g, A, m) : e.isDataTexture ? Pe.texSubImage2D(Pe.TEXTURE_2D, a, u, f, s, o, g, A, m.data) : e.isCompressedTexture ? Pe.compressedTexSubImage2D(Pe.TEXTURE_2D, a, u, f, m.width, m.height, g, m.data) : Pe.texSubImage2D(Pe.TEXTURE_2D, a, u, f, s, o, g, A, m);
                    Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, v),
                    Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, w),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, y),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, x),
                    Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, b),
                    0 === a && t.generateMipmaps && Pe.generateMipmap(_),
                    se.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(e, t, n=null, i=null, r=0) {
                    return !0 !== e.isTexture && (Pt("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
                    n = arguments[0] || null,
                    i = arguments[1] || null,
                    e = arguments[2],
                    t = arguments[3],
                    r = arguments[4] || 0),
                    Pt('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
                    this.copyTextureToTexture(e, t, n, i, r)
                }
                ,
                this.initRenderTarget = function(e) {
                    void 0 === de.get(e).__webglFramebuffer && ue.setupRenderTarget(e)
                }
                ,
                this.initTexture = function(e) {
                    e.isCubeTexture ? ue.setTextureCube(e, 0) : e.isData3DTexture ? ue.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? ue.setTexture2DArray(e, 0) : ue.setTexture2D(e, 0),
                    se.unbindTexture()
                }
                ,
                this.resetState = function() {
                    x = 0,
                    b = 0,
                    S = null,
                    se.reset(),
                    Ie.reset()
                }
                ,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return ht
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorspace = Ut._getDrawingBufferColorSpace(e),
                t.unpackColorSpace = Ut._getUnpackColorSpace()
            }
        }
        const Zp = new Cn;
        class Jp {
            constructor(e) {
                e = e || {},
                this.zNear = !0 === e.webGL ? -1 : 0,
                this.vertices = {
                    near: [new Zt, new Zt, new Zt, new Zt],
                    far: [new Zt, new Zt, new Zt, new Zt]
                },
                void 0 !== e.projectionMatrix && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4)
            }
            setFromProjectionMatrix(e, t) {
                const n = this.zNear
                  , i = 0 === e.elements[11];
                return Zp.copy(e).invert(),
                this.vertices.near[0].set(1, 1, n),
                this.vertices.near[1].set(1, -1, n),
                this.vertices.near[2].set(-1, -1, n),
                this.vertices.near[3].set(-1, 1, n),
                this.vertices.near.forEach((function(e) {
                    e.applyMatrix4(Zp)
                }
                )),
                this.vertices.far[0].set(1, 1, 1),
                this.vertices.far[1].set(1, -1, 1),
                this.vertices.far[2].set(-1, -1, 1),
                this.vertices.far[3].set(-1, 1, 1),
                this.vertices.far.forEach((function(e) {
                    e.applyMatrix4(Zp);
                    const n = Math.abs(e.z);
                    i ? e.z *= Math.min(t / n, 1) : e.multiplyScalar(Math.min(t / n, 1))
                }
                )),
                this.vertices
            }
            split(e, t) {
                for (; e.length > t.length; )
                    t.push(new Jp);
                t.length = e.length;
                for (let n = 0; n < e.length; n++) {
                    const i = t[n];
                    if (0 === n)
                        for (let e = 0; e < 4; e++)
                            i.vertices.near[e].copy(this.vertices.near[e]);
                    else
                        for (let t = 0; t < 4; t++)
                            i.vertices.near[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], e[n - 1]);
                    if (n === e.length - 1)
                        for (let e = 0; e < 4; e++)
                            i.vertices.far[e].copy(this.vertices.far[e]);
                    else
                        for (let t = 0; t < 4; t++)
                            i.vertices.far[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], e[n])
                }
            }
            toSpace(e, t) {
                for (let n = 0; n < 4; n++)
                    t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e),
                    t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e)
            }
        }
        const $p = {
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometryClearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n \tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\t\tvec2 cascade;\n\t\tfloat cascadeCenter;\n\t\tfloat closestEdge;\n\t\tfloat margin;\n\t\tfloat csmx;\n\t\tfloat csmy;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\t\tcascade = CSM_cascades[ i ];\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#elif defined (USE_SHADOWMAP)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\n\t\t// note: no loop here - all CSM lights are in fact one light only\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
            lights_pars_begin: "\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t" + mu.lights_pars_begin
        }
          , em = new Cn
          , tm = new Jp({
            webGL: !0
        })
          , nm = new Zt
          , im = new en
          , rm = []
          , am = []
          , sm = new Cn
          , om = new Cn
          , lm = new Zt(0,1,0);
        class cm {
            constructor(e) {
                this.camera = e.camera,
                this.parent = e.parent,
                this.cascades = e.cascades || 3,
                this.maxFar = e.maxFar || 1e5,
                this.mode = e.mode || "practical",
                this.shadowMapSize = e.shadowMapSize || 2048,
                this.shadowBias = e.shadowBias || 1e-6,
                this.lightDirection = e.lightDirection || new Zt(1,-1,1).normalize(),
                this.lightIntensity = e.lightIntensity || 3,
                this.lightNear = e.lightNear || 1,
                this.lightFar = e.lightFar || 2e3,
                this.lightMargin = e.lightMargin || 200,
                this.customSplitsCallback = e.customSplitsCallback,
                this.fade = !1,
                this.mainFrustum = new Jp({
                    webGL: !0
                }),
                this.frustums = [],
                this.breaks = [],
                this.lights = [],
                this.shaders = new Map,
                this.createLights(),
                this.updateFrustums(),
                this.injectInclude()
            }
            createLights() {
                for (let e = 0; e < this.cascades; e++) {
                    const e = new ms(16777215,this.lightIntensity);
                    e.castShadow = !0,
                    e.shadow.mapSize.width = this.shadowMapSize,
                    e.shadow.mapSize.height = this.shadowMapSize,
                    e.shadow.camera.near = this.lightNear,
                    e.shadow.camera.far = this.lightFar,
                    e.shadow.bias = this.shadowBias,
                    this.parent.add(e),
                    this.parent.add(e.target),
                    this.lights.push(e)
                }
            }
            initCascades() {
                const e = this.camera;
                e.updateProjectionMatrix(),
                this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar),
                this.mainFrustum.split(this.breaks, this.frustums)
            }
            updateShadowBounds() {
                const e = this.frustums;
                for (let t = 0; t < e.length; t++) {
                    const e = this.lights[t].shadow.camera
                      , n = this.frustums[t]
                      , i = n.vertices.near
                      , r = n.vertices.far
                      , a = r[0];
                    let s;
                    s = a.distanceTo(r[2]) > a.distanceTo(i[2]) ? r[2] : i[2];
                    let o = a.distanceTo(s);
                    if (this.fade) {
                        const e = this.camera
                          , t = Math.max(e.far, this.maxFar)
                          , i = n.vertices.far[0].z / (t - e.near);
                        o += .25 * Math.pow(i, 2) * (t - e.near)
                    }
                    e.left = -o / 2,
                    e.right = o / 2,
                    e.top = o / 2,
                    e.bottom = -o / 2,
                    e.updateProjectionMatrix()
                }
            }
            getBreaks() {
                const e = this.camera
                  , t = Math.min(e.far, this.maxFar);
                switch (this.breaks.length = 0,
                this.mode) {
                case "uniform":
                    n(this.cascades, e.near, t, this.breaks);
                    break;
                case "logarithmic":
                    i(this.cascades, e.near, t, this.breaks);
                    break;
                case "practical":
                    !function(e, t, r, a, s) {
                        rm.length = 0,
                        am.length = 0,
                        i(e, t, r, am),
                        n(e, t, r, rm);
                        for (let t = 1; t < e; t++)
                            s.push(bt.lerp(rm[t - 1], am[t - 1], a));
                        s.push(1)
                    }(this.cascades, e.near, t, .5, this.breaks);
                    break;
                case "custom":
                    void 0 === this.customSplitsCallback && console.error("CSM: Custom split scheme callback not defined."),
                    this.customSplitsCallback(this.cascades, e.near, t, this.breaks)
                }
                function n(e, t, n, i) {
                    for (let r = 1; r < e; r++)
                        i.push((t + (n - t) * r / e) / n);
                    i.push(1)
                }
                function i(e, t, n, i) {
                    for (let r = 1; r < e; r++)
                        i.push(t * (n / t) ** (r / e) / n);
                    i.push(1)
                }
            }
            update() {
                const e = this.camera
                  , t = this.frustums;
                sm.lookAt(new Zt, this.lightDirection, lm),
                om.copy(sm).invert();
                for (let n = 0; n < t.length; n++) {
                    const i = this.lights[n]
                      , r = i.shadow.camera
                      , a = (r.right - r.left) / this.shadowMapSize
                      , s = (r.top - r.bottom) / this.shadowMapSize;
                    em.multiplyMatrices(om, e.matrixWorld),
                    t[n].toSpace(em, tm);
                    const o = tm.vertices.near
                      , l = tm.vertices.far;
                    im.makeEmpty();
                    for (let e = 0; e < 4; e++)
                        im.expandByPoint(o[e]),
                        im.expandByPoint(l[e]);
                    im.getCenter(nm),
                    nm.z = im.max.z + this.lightMargin,
                    nm.x = Math.floor(nm.x / a) * a,
                    nm.y = Math.floor(nm.y / s) * s,
                    nm.applyMatrix4(sm),
                    i.position.copy(nm),
                    i.target.position.copy(nm),
                    i.target.position.x += this.lightDirection.x,
                    i.target.position.y += this.lightDirection.y,
                    i.target.position.z += this.lightDirection.z
                }
            }
            injectInclude() {
                mu.lights_fragment_begin = $p.lights_fragment_begin,
                mu.lights_pars_begin = $p.lights_pars_begin
            }
            setupMaterial(e) {
                e.defines = e.defines || {},
                e.defines.USE_CSM = 1,
                e.defines.CSM_CASCADES = this.cascades,
                this.fade && (e.defines.CSM_FADE = "");
                const t = []
                  , n = this
                  , i = this.shaders;
                e.onBeforeCompile = function(r) {
                    const a = Math.min(n.camera.far, n.maxFar);
                    n.getExtendedBreaks(t),
                    r.uniforms.CSM_cascades = {
                        value: t
                    },
                    r.uniforms.cameraNear = {
                        value: n.camera.near
                    },
                    r.uniforms.shadowFar = {
                        value: a
                    },
                    i.set(e, r)
                }
                ,
                i.set(e, null)
            }
            updateUniforms() {
                const e = Math.min(this.camera.far, this.maxFar);
                this.shaders.forEach((function(t, n) {
                    if (null !== t) {
                        const n = t.uniforms;
                        this.getExtendedBreaks(n.CSM_cascades.value),
                        n.cameraNear.value = this.camera.near,
                        n.shadowFar.value = e
                    }
                    !this.fade && "CSM_FADE"in n.defines ? (delete n.defines.CSM_FADE,
                    n.needsUpdate = !0) : this.fade && !("CSM_FADE"in n.defines) && (n.defines.CSM_FADE = "",
                    n.needsUpdate = !0)
                }
                ), this)
            }
            getExtendedBreaks(e) {
                for (; e.length < this.breaks.length; )
                    e.push(new St);
                e.length = this.breaks.length;
                for (let t = 0; t < this.cascades; t++) {
                    const n = this.breaks[t]
                      , i = this.breaks[t - 1] || 0;
                    e[t].x = i,
                    e[t].y = n
                }
            }
            updateFrustums() {
                this.getBreaks(),
                this.initCascades(),
                this.updateShadowBounds(),
                this.updateUniforms()
            }
            remove() {
                for (let e = 0; e < this.lights.length; e++)
                    this.parent.remove(this.lights[e].target),
                    this.parent.remove(this.lights[e])
            }
            dispose() {
                const e = this.shaders;
                e.forEach((function(e, t) {
                    delete t.onBeforeCompile,
                    delete t.defines.USE_CSM,
                    delete t.defines.CSM_CASCADES,
                    delete t.defines.CSM_FADE,
                    null !== e && (delete e.uniforms.CSM_cascades,
                    delete e.uniforms.cameraNear,
                    delete e.uniforms.shadowFar),
                    t.needsUpdate = !0
                }
                )),
                e.clear()
            }
        }
        var hm;
        !function(e) {
            e[e.ImperialUnitsEnabled = 0] = "ImperialUnitsEnabled",
            e[e.ResetHintEnabled = 1] = "ResetHintEnabled",
            e[e.GhostCarEnabled = 2] = "GhostCarEnabled",
            e[e.DefaultCameraMode = 3] = "DefaultCameraMode",
            e[e.CockpitCameraToggle = 4] = "CockpitCameraToggle",
            e[e.Checkpoints = 5] = "Checkpoints",
            e[e.Timer = 6] = "Timer",
            e[e.Speedometer = 7] = "Speedometer",
            e[e.Language = 8] = "Language",
            e[e.ShadowQuality = 9] = "ShadowQuality",
            e[e.CloudsEnabled = 10] = "CloudsEnabled",
            e[e.ParticlesEnabled = 11] = "ParticlesEnabled",
            e[e.SkidmarksEnabled = 12] = "SkidmarksEnabled",
            e[e.RenderScale = 13] = "RenderScale",
            e[e.Antialiasing = 14] = "Antialiasing",
            e[e.SoundEffectVolume = 15] = "SoundEffectVolume",
            e[e.MusicVolume = 16] = "MusicVolume",
            e[e.CheckpointVolume = 17] = "CheckpointVolume",
            e[e.VibrationEnabled = 18] = "VibrationEnabled",
            e[e.TouchSteeringSide = 19] = "TouchSteeringSide"
        }(hm || (hm = {}));
        const dm = hm
          , um = JSON.parse('{"rE":"0.5.2","l$":{"r":1,"M":4}}');
        const fm = !1
          , pm = um.l$.r;
        if (!Number.isSafeInteger(pm) || pm < 1)
            throw new Error("package.json beta version property must be a positive integer");
        let mm = "";
        um.rE;
        const gm = um.l$.M;
        if (!Number.isSafeInteger(gm) || gm < 1)
            throw new Error("package.json beta physicsVersion property must be a positive integer");
        var Am, _m, vm, wm, ym, xm, bm, Sm, Em, Mm, Tm, Cm, Im, Rm, Pm, Bm, Dm, Lm, Um, Nm, km = function(e, t, n, i) {
            return new (n || (n = Promise))((function(r, a) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function o(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value,
                    t instanceof n ? t : new n((function(e) {
                        e(t)
                    }
                    ))).then(s, o)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        }, Fm = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Om = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class zm {
            constructor(e, t, n=!0, i=!1) {
                var r;
                Am.add(this),
                _m.set(this, void 0),
                vm.set(this, void 0),
                wm.set(this, void 0),
                ym.set(this, !1),
                xm.set(this, void 0),
                bm.set(this, new cr),
                Sm.set(this, null),
                Em.set(this, null),
                Mm.set(this, []),
                Tm.set(this, null),
                Cm.set(this, new Zt(8,10,10)),
                Im.set(this, []),
                Rm.set(this, []),
                Fm(this, _m, e, "f"),
                Fm(this, vm, t, "f");
                const a = {
                    antialias: null === (r = null == t ? void 0 : t.getSettingBoolean(dm.Antialiasing)) || void 0 === r || r,
                    powerPreference: "high-performance",
                    canvas: e,
                    alpha: i
                };
                try {
                    a.failIfMajorPerformanceCaveat = !0,
                    Fm(this, wm, new Kp(a), "f"),
                    Fm(this, ym, !1, "f")
                } catch (e) {
                    a.failIfMajorPerformanceCaveat = !1,
                    Fm(this, wm, new Kp(a), "f"),
                    Fm(this, ym, !0, "f")
                }
                Om(this, wm, "f").outputColorSpace = Ke,
                Om(this, wm, "f").debug.checkShaderErrors = fm,
                Fm(this, xm, new _r, "f"),
                n && (Om(this, xm, "f").fog = new Ar(10211839,0,zm.maxViewDistance)),
                Om(this, xm, "f").add(new ts(3891597,11714755,4.7)),
                document.addEventListener("fullscreenchange", ( () => {
                    Om(this, Am, "m", Um).call(this)
                }
                )),
                Om(this, _m, "f").addEventListener("webglcontextrestored", ( () => {
                    for (const e of Om(this, Rm, "f"))
                        e()
                }
                )),
                null != window.electron && window.electron.addFullscreenChangeListener(( () => {
                    Om(this, Am, "m", Um).call(this)
                }
                ))
            }
            clear() {
                Om(this, wm, "f").clear()
            }
            update(e) {
                var t, n, i;
                Om(this, Cm, "f").copy(e.getSunPosition());
                let r = null !== (n = null === (t = Om(this, vm, "f")) || void 0 === t ? void 0 : t.getSettingInteger(dm.ShadowQuality)) && void 0 !== n ? n : 0;
                if (this.isShadowQualitySupported(r) || (r = 0),
                !Number.isSafeInteger(r) || r <= 2 || r > 5)
                    if (null != Om(this, Sm, "f") && (Om(this, Sm, "f").remove(),
                    Om(this, Sm, "f").dispose(),
                    Fm(this, Sm, null, "f"),
                    Fm(this, Em, null, "f")),
                    null == Om(this, Tm, "f") && (Fm(this, Tm, new ms(16777215,4.7), "f"),
                    Om(this, Tm, "f").position.copy(Om(this, Cm, "f")),
                    Om(this, xm, "f").add(Om(this, Tm, "f")),
                    Om(this, xm, "f").add(Om(this, Tm, "f").target)),
                    1 == r || 2 == r) {
                        if (!Om(this, Tm, "f").castShadow) {
                            const e = Om(this, Am, "m", Lm).call(this, r);
                            Om(this, Tm, "f").castShadow = !0,
                            Om(this, Tm, "f").shadow.camera.top = 10,
                            Om(this, Tm, "f").shadow.camera.right = 10,
                            Om(this, Tm, "f").shadow.camera.bottom = -10,
                            Om(this, Tm, "f").shadow.camera.left = -10,
                            Om(this, Tm, "f").shadow.camera.near = 1,
                            Om(this, Tm, "f").shadow.camera.far = 50,
                            Om(this, Tm, "f").shadow.mapSize.width = e,
                            Om(this, Tm, "f").shadow.mapSize.height = e,
                            Om(this, Tm, "f").shadow.normalBias = .03,
                            Om(this, Tm, "f").shadow.intensity = .6
                        }
                        Om(this, Tm, "f").position.addVectors(Om(this, bm, "f").position, Om(this, Cm, "f").multiplyScalar(12.5)),
                        Om(this, Tm, "f").target.position.copy(Om(this, bm, "f").position),
                        Om(this, wm, "f").shadowMap.type = 1,
                        Om(this, wm, "f").shadowMap.enabled = !0
                    } else
                        Om(this, Tm, "f").castShadow = !1,
                        null === (i = Om(this, Tm, "f").shadow.map) || void 0 === i || i.dispose(),
                        Om(this, Tm, "f").shadow.map = null,
                        Om(this, wm, "f").shadowMap.enabled = !1;
                else {
                    if (null != Om(this, Sm, "f") && Om(this, Em, "f") != r && (Om(this, Sm, "f").remove(),
                    Om(this, Sm, "f").dispose(),
                    Fm(this, Sm, null, "f"),
                    Fm(this, Em, null, "f"),
                    Om(this, wm, "f").compile(Om(this, xm, "f"), Om(this, bm, "f"))),
                    null == Om(this, Sm, "f")) {
                        Om(this, wm, "f").shadowMap.enabled = !0,
                        Om(this, wm, "f").shadowMap.type = 2,
                        Fm(this, Sm, Om(this, Am, "m", Pm).call(this, r), "f"),
                        Fm(this, Em, r, "f");
                        for (const {material: e, onBeforeCompile: t, customProgramCacheKey: n} of Om(this, Mm, "f"))
                            Om(this, Am, "m", Dm).call(this, e, t, n)
                    }
                    null != Om(this, Tm, "f") && (Om(this, xm, "f").remove(Om(this, Tm, "f")),
                    Om(this, xm, "f").remove(Om(this, Tm, "f").target),
                    Fm(this, Tm, null, "f")),
                    Om(this, Sm, "f").lightDirection = Om(this, Cm, "f").clone().negate().normalize(),
                    Om(this, Sm, "f").update()
                }
                Om(this, Am, "m", Bm).call(this),
                Om(this, wm, "f").render(Om(this, xm, "f"), Om(this, bm, "f"))
            }
            addMaterial(e) {
                const t = Array.isArray(e) ? e : [e];
                for (const e of t) {
                    const t = e.onBeforeCompile.bind(e)
                      , n = e.onBeforeCompile.toString();
                    Om(this, Mm, "f").push({
                        material: e,
                        onBeforeCompile: t,
                        customProgramCacheKey: n
                    }),
                    null != Om(this, Sm, "f") && Om(this, Am, "m", Dm).call(this, e, t, n)
                }
            }
            removeMaterial(e) {
                if (Array.isArray(e))
                    for (const t of e) {
                        const e = Om(this, Mm, "f").findIndex((e => e.material == t));
                        e >= 0 && Om(this, Mm, "f").splice(e, 1)
                    }
                else {
                    const t = Om(this, Mm, "f").findIndex((t => t.material == e));
                    t >= 0 && Om(this, Mm, "f").splice(t, 1)
                }
            }
            isTrackShadowsEnabled() {
                var e, t;
                const n = null !== (t = null === (e = Om(this, vm, "f")) || void 0 === e ? void 0 : e.getSettingInteger(dm.ShadowQuality)) && void 0 !== t ? t : 0;
                return 3 == n || 4 == n || 5 == n
            }
            isShadowQualitySupported(e) {
                return !Number.isSafeInteger(e) || e <= 0 || e > 5 || Om(this, wm, "f").capabilities.maxTextureSize >= Om(this, Am, "m", Lm).call(this, e)
            }
            getMaxAnisotropy() {
                return Om(this, wm, "f").capabilities.getMaxAnisotropy()
            }
            get isUsingSoftwareRenderer() {
                return Om(this, ym, "f")
            }
            get isFullscreen() {
                return null != window.electron ? window.electron.isFullscreen() : null != document.fullscreenElement
            }
            toggleFullscreen() {
                return km(this, void 0, void 0, (function*() {
                    this.isFullscreen ? null != window.electron ? window.electron.setFullscreen(!1) : yield document.exitFullscreen() : null != window.electron ? window.electron.setFullscreen(!0) : yield document.body.requestFullscreen()
                }
                ))
            }
            addFullscreenChangeListener(e) {
                Om(this, Im, "f").push(e)
            }
            removeFullscreenChangeListener(e) {
                const t = Om(this, Im, "f").indexOf(e);
                t >= 0 && Om(this, Im, "f").splice(t, 1)
            }
            addContextRestoredEventListener(e) {
                Om(this, Rm, "f").push(e)
            }
            removeContextRestoredEventListener(e) {
                const t = Om(this, Rm, "f").indexOf(e);
                t >= 0 && Om(this, Rm, "f").splice(t, 1)
            }
            get csm() {
                return Om(this, Sm, "f")
            }
            setCamera(e) {
                Fm(this, bm, e, "f"),
                null != Om(this, Sm, "f") && (Om(this, Sm, "f").camera = e,
                Om(this, Am, "m", Nm).call(this))
            }
            get camera() {
                return Om(this, bm, "f")
            }
            get canvas() {
                return Om(this, _m, "f")
            }
            setAnimationLoop(e) {
                Om(this, wm, "f").setAnimationLoop(e)
            }
            get scene() {
                return Om(this, xm, "f")
            }
        }
        _m = new WeakMap,
        vm = new WeakMap,
        wm = new WeakMap,
        ym = new WeakMap,
        xm = new WeakMap,
        bm = new WeakMap,
        Sm = new WeakMap,
        Em = new WeakMap,
        Mm = new WeakMap,
        Tm = new WeakMap,
        Cm = new WeakMap,
        Im = new WeakMap,
        Rm = new WeakMap,
        Am = new WeakSet,
        Pm = function(e) {
            if (3 != e && 4 != e && 5 != e)
                throw new Error("Unsupported shadow quality: " + e.toString());
            const t = Om(this, Am, "m", Lm).call(this, e);
            let n, i;
            switch (e) {
            case 5:
                n = 2e3;
                break;
            case 4:
                n = 1e3;
                break;
            case 3:
                n = 500
            }
            switch (e) {
            case 5:
                i = 5;
                break;
            case 4:
            case 3:
                i = 4
            }
            const r = new cm({
                maxFar: n,
                lightFar: 15e3,
                lightNear: 10,
                lightMargin: 5e3,
                cascades: i,
                mode: "custom",
                customSplitsCallback: (t, n, i, r) => {
                    5 == e ? (r.push((15 - n) / i),
                    r.push((40 - n) / i),
                    r.push((150 - n) / i),
                    r.push((500 - n) / i),
                    r.push(1)) : 4 == e ? (r.push((15 - n) / i),
                    r.push((80 - n) / i),
                    r.push((300 - n) / i),
                    r.push(1)) : (r.push((15 - n) / i),
                    r.push((60 - n) / i),
                    r.push((150 - n) / i),
                    r.push(1))
                }
                ,
                parent: Om(this, xm, "f"),
                shadowMapSize: t,
                lightDirection: new Zt(0,0,-1),
                lightIntensity: 4.7,
                camera: Om(this, bm, "f")
            });
            r.fade = !0,
            5 == e ? (r.lights[0].shadow.normalBias = .025,
            r.lights[1].shadow.normalBias = .04,
            r.lights[2].shadow.normalBias = .11,
            r.lights[3].shadow.normalBias = .32,
            r.lights[4].shadow.normalBias = 1.25) : 4 == e ? (r.lights[0].shadow.normalBias = .041,
            r.lights[1].shadow.normalBias = .13,
            r.lights[2].shadow.normalBias = .48,
            r.lights[3].shadow.normalBias = 1.25) : (r.lights[0].shadow.normalBias = .08,
            r.lights[1].shadow.normalBias = .21,
            r.lights[2].shadow.normalBias = .6,
            r.lights[3].shadow.normalBias = 1.9);
            for (const e of r.lights)
                e.shadow.intensity = .6;
            return r
        }
        ,
        Bm = function() {
            var e, t;
            let n = null !== (t = null === (e = Om(this, vm, "f")) || void 0 === e ? void 0 : e.getSettingFloat(dm.RenderScale)) && void 0 !== t ? t : 1;
            n = Number.isFinite(n) ? Math.min(Math.max(n, .25), 2) : 1;
            const i = window.devicePixelRatio * n;
            if (Om(this, wm, "f").getPixelRatio() != i && Om(this, wm, "f").setPixelRatio(i),
            Om(this, bm, "f")instanceof cr) {
                const e = window.innerWidth / window.innerHeight
                  , t = new St;
                Om(this, wm, "f").getSize(t);
                const n = Math.max(1, .5 * e);
                t.width == window.innerWidth && t.height == window.innerHeight && Om(this, bm, "f").aspect == e && Om(this, bm, "f").zoom == n || (Om(this, wm, "f").setSize(window.innerWidth, window.innerHeight),
                Om(this, bm, "f").aspect = e,
                Om(this, bm, "f").zoom = n,
                Om(this, Am, "m", Nm).call(this),
                Om(this, bm, "f").updateProjectionMatrix())
            }
        }
        ,
        Dm = function(e, t, n) {
            var i;
            const r = Array.isArray(e) ? e : [e];
            for (const e of r) {
                null === (i = Om(this, Sm, "f")) || void 0 === i || i.setupMaterial(e);
                const r = e.onBeforeCompile.toString()
                  , a = e.onBeforeCompile.bind(e);
                e.onBeforeCompile = (e, n) => {
                    a(e, n),
                    t(e, n)
                }
                ,
                e.customProgramCacheKey = () => r + n,
                e.needsUpdate = !0
            }
        }
        ,
        Lm = function(e) {
            switch (e) {
            case 5:
                return 8192;
            case 4:
                return 4096;
            case 3:
                return 2048;
            case 2:
            case 1:
                return 1024;
            default:
                throw new Error("Unsupported shadow quality: " + e.toString())
            }
        }
        ,
        Um = function() {
            for (const e of Om(this, Im, "f"))
                e()
        }
        ,
        Nm = function() {
            if (null != Om(this, Sm, "f"))
                if (Om(this, bm, "f")instanceof cr) {
                    const e = Om(this, bm, "f").fov;
                    Om(this, bm, "f").fov = 100,
                    Om(this, Sm, "f").updateFrustums(),
                    Om(this, bm, "f").fov = e
                } else
                    Om(this, Sm, "f").updateFrustums()
        }
        ,
        zm.maxViewDistance = 1e4;
        const Hm = zm;
        var Wm, Vm, Gm, Qm, Xm, jm = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class qm {
            constructor() {
                Wm.add(this),
                Qm.set(this, new cr(jm(Vm, Vm, "f", Gm),1,.5,Hm.maxViewDistance))
            }
            reset(e, t, n) {
                this.update(e, t, 0),
                jm(this, Qm, "f").fov = jm(this, Wm, "m", Xm).call(this, null != n ? n : 0),
                jm(this, Qm, "f").updateProjectionMatrix()
            }
            update(e, t, n) {
                jm(this, Qm, "f").fov = jm(this, Wm, "m", Xm).call(this, n),
                jm(this, Qm, "f").updateProjectionMatrix();
                const i = new Zt(0,1.1 + .46 / jm(this, Qm, "f").zoom - .46,.4);
                jm(this, Qm, "f").position.addVectors(e, i.applyQuaternion(t)),
                jm(this, Qm, "f").quaternion.copy(t),
                jm(this, Qm, "f").quaternion.multiply((new Kt).setFromEuler(new Fn(0,Math.PI,0))),
                jm(this, Qm, "f").updateMatrix()
            }
            get camera() {
                return jm(this, Qm, "f")
            }
        }
        Vm = qm,
        Qm = new WeakMap,
        Wm = new WeakSet,
        Xm = function(e) {
            return jm(Vm, Vm, "f", Gm) + (80 - jm(Vm, Vm, "f", Gm)) * (1 - Math.exp(-Math.abs(e) / 200))
        }
        ,
        Gm = {
            value: 70
        };
        const Ym = qm;
        class Km {
            constructor(e, t, n, i) {
                this.primary = e,
                this.secondary = t,
                this.frame = n,
                this.rims = i
            }
            static random() {
                const e = 360 * Math.random()
                  , t = 100 * (1 - Math.pow(Math.random(), 2))
                  , n = 100 * (.05 + .25 * (1 - Math.pow(Math.random(), 2)));
                return new Km(new wi("hsl(" + e.toString() + "," + t.toString() + "%," + n.toString() + "%)"),new wi("#ffffff"),new wi("#131313"),new wi("#666666"))
            }
            serialize() {
                return this.primary.getHexString() + this.secondary.getHexString() + this.frame.getHexString() + this.rims.getHexString()
            }
            static deserialize(e) {
                const t = [];
                for (let n = 0; n < 4; n++) {
                    const i = e.substring(6 * n, 6 * (n + 1));
                    /^[0-9a-f]{6}$/i.test(i) ? t.push(new wi("#" + i)) : t.push(new wi("#555"))
                }
                return new Km(t[0],t[1],t[2],t[3])
            }
        }
        const Zm = Km;
        var Jm, $m, eg, tg, ng, ig, rg, ag = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, sg = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class og {
            constructor() {
                Jm.add(this),
                tg.set(this, new cr(sg($m, $m, "f", eg),1,.5,1e4)),
                ng.set(this, new Zt),
                ig.set(this, new Zt(0,1,0))
            }
            reset(e, t, n) {
                ag(this, ng, new Zt(1e-5,0,-1), "f"),
                sg(this, ng, "f").applyQuaternion(t),
                sg(this, ng, "f").add(e),
                ag(this, ig, new Zt(0,1,0), "f"),
                sg(this, ig, "f").applyQuaternion(t),
                this.update(0, e, t, 0),
                sg(this, tg, "f").fov = sg(this, Jm, "m", rg).call(this, null != n ? n : 0),
                sg(this, tg, "f").updateProjectionMatrix()
            }
            update(e, t, n, i) {
                sg(this, tg, "f").fov = sg(this, Jm, "m", rg).call(this, i),
                sg(this, tg, "f").updateProjectionMatrix();
                const r = new Zt(0,1,0);
                r.applyQuaternion(n);
                const a = Math.min(1, 5 * e);
                sg(this, ig, "f").set(a * r.x + (1 - a) * sg(this, ig, "f").x, a * r.y + (1 - a) * sg(this, ig, "f").y, a * r.z + (1 - a) * sg(this, ig, "f").z);
                const s = (new Zt).subVectors(t, sg(this, ng, "f"));
                s.normalize();
                const o = 5.5
                  , l = 1.8 / Math.min(sg(this, tg, "f").zoom, 2);
                sg(this, tg, "f").position.x = t.x - s.x * o + 2 * sg(this, ig, "f").x,
                sg(this, tg, "f").position.y = Math.max(.25, t.y - s.y * o + 2 * sg(this, ig, "f").y),
                sg(this, tg, "f").position.z = t.z - s.z * o + 2 * sg(this, ig, "f").z,
                sg(this, tg, "f").lookAt(t.x + sg(this, ig, "f").x * l, t.y + sg(this, ig, "f").y * l, t.z + sg(this, ig, "f").z * l),
                sg(this, tg, "f").updateMatrix(),
                sg(this, ng, "f").set(t.x - s.x * o, t.y - s.y * o, t.z - s.z * o)
            }
            get camera() {
                return sg(this, tg, "f")
            }
        }
        $m = og,
        tg = new WeakMap,
        ng = new WeakMap,
        ig = new WeakMap,
        Jm = new WeakSet,
        rg = function(e) {
            return sg($m, $m, "f", eg) + (100 - sg($m, $m, "f", eg)) * (1 - Math.exp(-Math.abs(e) / 200))
        }
        ,
        eg = {
            value: 70
        };
        const lg = og;
        var cg, hg, dg, ug, fg, pg, mg, gg, Ag = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, _g = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class vg {
            constructor(e) {
                hg.set(this, void 0),
                dg.set(this, void 0),
                ug.set(this, []),
                fg.set(this, 256),
                pg.set(this, new Zt(0,1,0)),
                Ag(this, hg, e, "f"),
                Ag(this, dg, new Qr(_g(cg, cg, "f", mg),_g(cg, cg, "f", gg),_g(this, fg, "f")), "f"),
                _g(this, dg, "f").frustumCulled = !1,
                e.scene.add(_g(this, dg, "f")),
                this.clear()
            }
            dispose() {
                _g(this, dg, "f").dispose(),
                _g(this, hg, "f").scene.remove(_g(this, dg, "f"))
            }
            clear() {
                _g(this, ug, "f").length = 0,
                _g(this, dg, "f").count = 0,
                _g(this, dg, "f").instanceMatrix.needsUpdate = !0
            }
            spawn(e, t, n) {
                _g(this, ug, "f").push({
                    x: e + .25 * (Math.random() - .5),
                    y: t + .25 * (Math.random() - .5),
                    z: n + .25 * (Math.random() - .5),
                    vx: .5 * (Math.random() - .5),
                    vy: .5 * (Math.random() - .5),
                    vz: .5 * (Math.random() - .5),
                    rotation: Math.random() * Math.PI * 2,
                    lifetime: .5
                })
            }
            update(e) {
                for (let t = _g(this, ug, "f").length - 1; t >= 0; --t) {
                    const n = _g(this, ug, "f")[t];
                    n.vy += 15 * e,
                    n.x += n.vx * e,
                    n.y += n.vy * e,
                    n.z += n.vz * e,
                    n.lifetime -= e,
                    n.lifetime <= 0 && _g(this, ug, "f").splice(t, 1)
                }
                let t = !1;
                _g(this, dg, "f").count != _g(this, ug, "f").length && (_g(this, dg, "f").count = Math.min(_g(this, ug, "f").length, _g(this, fg, "f")),
                t = !0);
                for (let e = 0; e < _g(this, dg, "f").count; ++e) {
                    const t = _g(this, ug, "f")[_g(this, ug, "f").length - 1 - e]
                      , n = new Cn;
                    n.lookAt(new Zt(t.x,t.y,t.z), _g(this, hg, "f").camera.position, _g(this, pg, "f")),
                    n.setPosition(t.x, t.y, t.z),
                    n.multiply((new Cn).makeRotationZ(t.rotation));
                    const i = .5 + 2 * (.5 - t.lifetime);
                    n.scale(new Zt(i,i,i)),
                    _g(this, dg, "f").setMatrixAt(e, n)
                }
                (t || _g(this, ug, "f").length > 0) && (_g(this, dg, "f").instanceMatrix.needsUpdate = !0)
            }
            static initResources(e) {
                e.addResource();
                const t = (new $a).load("images/smoke.png", ( () => {
                    e.loadedResource()
                }
                ));
                _g(this, cg, "f", gg).map = t
            }
        }
        cg = vg,
        hg = new WeakMap,
        dg = new WeakMap,
        ug = new WeakMap,
        fg = new WeakMap,
        pg = new WeakMap,
        mg = {
            value: ( () => {
                const e = new ya;
                return e.rotateX(Math.PI),
                e
            }
            )()
        },
        gg = {
            value: new Si({
                opacity: .3,
                depthWrite: !1,
                transparent: !0
            })
        };
        const wg = vg;
        var yg, xg, bg, Sg, Eg, Mg, Tg, Cg, Ig, Rg, Pg = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Bg = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Dg {
            constructor(e) {
                xg.set(this, void 0),
                bg.set(this, void 0),
                Sg.set(this, void 0),
                Eg.set(this, void 0),
                Mg.set(this, 1e3),
                Tg.set(this, 0),
                Cg.set(this, null),
                Ig.set(this, null),
                Pg(this, xg, e, "f");
                const t = new Oi;
                Pg(this, Sg, new Float32Array(6 * Bg(this, Mg, "f") * 3), "f"),
                Pg(this, Eg, new Ci(Bg(this, Sg, "f"),3), "f"),
                t.setAttribute("position", Bg(this, Eg, "f")),
                Pg(this, bg, new Zi(t,Bg(yg, yg, "f", Rg)), "f"),
                Bg(this, bg, "f").frustumCulled = !1,
                Bg(this, xg, "f").scene.add(Bg(this, bg, "f"))
            }
            dispose() {
                Bg(this, bg, "f").geometry.dispose(),
                Bg(this, xg, "f").scene.remove(Bg(this, bg, "f"))
            }
            clear() {
                for (let e = 0; e < Bg(this, Sg, "f").length; ++e)
                    Bg(this, Sg, "f")[e] = 0;
                Bg(this, Eg, "f").needsUpdate = !0,
                Pg(this, Tg, 0, "f"),
                this.break()
            }
            break() {
                Pg(this, Cg, null, "f"),
                Pg(this, Ig, null, "f")
            }
            spawn(e, t, n, i) {
                var r, a;
                const s = Bg(this, Cg, "f")
                  , o = Bg(this, Ig, "f")
                  , l = (new Zt).addVectors(e, new Zt(.172,-.3,0).applyQuaternion(t))
                  , c = (new Zt).addVectors(e, new Zt(-.172,-.3,0).applyQuaternion(t))
                  , h = (new Zt).copy(l)
                  , d = (new Zt).copy(c)
                  , u = (new Zt).subVectors(l, n).dot(i);
                h.addScaledVector(i, -u);
                const f = (new Zt).subVectors(c, n).dot(i);
                if (d.addScaledVector(i, -f),
                null != s && null != o) {
                    const e = (Pg(this, Tg, (a = Bg(this, Tg, "f"),
                    r = a++,
                    a), "f"),
                    r);
                    Bg(this, Sg, "f")[6 * e * 3 + 0] = h.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 1] = h.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 2] = h.z,
                    Bg(this, Sg, "f")[6 * e * 3 + 3] = s.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 4] = s.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 5] = s.z,
                    Bg(this, Sg, "f")[6 * e * 3 + 6] = d.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 7] = d.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 8] = d.z,
                    Bg(this, Sg, "f")[6 * e * 3 + 9] = d.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 10] = d.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 11] = d.z,
                    Bg(this, Sg, "f")[6 * e * 3 + 12] = s.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 13] = s.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 14] = s.z,
                    Bg(this, Sg, "f")[6 * e * 3 + 15] = o.x,
                    Bg(this, Sg, "f")[6 * e * 3 + 16] = o.y,
                    Bg(this, Sg, "f")[6 * e * 3 + 17] = o.z,
                    Bg(this, Eg, "f").needsUpdate = !0,
                    Bg(this, Tg, "f") >= Bg(this, Mg, "f") - 1 && Pg(this, Tg, 0, "f")
                }
                Pg(this, Cg, h, "f"),
                Pg(this, Ig, d, "f")
            }
        }
        yg = Dg,
        xg = new WeakMap,
        bg = new WeakMap,
        Sg = new WeakMap,
        Eg = new WeakMap,
        Mg = new WeakMap,
        Tg = new WeakMap,
        Cg = new WeakMap,
        Ig = new WeakMap,
        Rg = {
            value: new Si({
                color: 1118481,
                side: 2,
                polygonOffset: !0,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: 0
            })
        };
        const Lg = Dg;
        var Ug, Ng, kg, Fg, Og, zg, Hg, Wg, Vg, Gg, Qg, Xg, jg, qg, Yg, Kg, Zg, Jg, $g, eA, tA, nA, iA, rA, aA, sA, oA, lA, cA, hA, dA, uA, fA, pA, mA, gA, AA, _A, vA, wA, yA, xA, bA, SA, EA, MA, TA, CA, IA, RA, PA, BA, DA, LA, UA, NA, kA, FA, OA, zA, HA, WA, VA = function(e, t, n, i) {
            return new (n || (n = Promise))((function(r, a) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function o(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value,
                    t instanceof n ? t : new n((function(e) {
                        e(t)
                    }
                    ))).then(s, o)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        }, GA = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, QA = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class XA {
            constructor(e, t, n, i, r, a, s, o, l) {
                var c;
                if (Ug.add(this),
                kg.set(this, void 0),
                Fg.set(this, null),
                Og.set(this, 1),
                zg.set(this, null),
                Hg.set(this, []),
                Wg.set(this, null),
                Vg.set(this, null),
                Gg.set(this, null),
                Qg.set(this, []),
                this.notificationAudioEnabled = !1,
                Xg.set(this, void 0),
                jg.set(this, void 0),
                qg.set(this, void 0),
                Yg.set(this, !1),
                Kg.set(this, void 0),
                Zg.set(this, void 0),
                Jg.set(this, void 0),
                $g.set(this, void 0),
                iA.set(this, []),
                rA.set(this, []),
                aA.set(this, []),
                sA.set(this, [0, 0, 0, 0]),
                oA.set(this, [0, 0, 0, 0]),
                lA.set(this, [0, 0, 0, 0]),
                cA.set(this, void 0),
                hA.set(this, void 0),
                dA.set(this, null),
                uA.set(this, null),
                fA.set(this, []),
                pA.set(this, null),
                mA.set(this, void 0),
                gA.set(this, void 0),
                AA.set(this, void 0),
                _A.set(this, void 0),
                vA.set(this, void 0),
                wA.set(this, void 0),
                yA.set(this, []),
                xA.set(this, null),
                bA.set(this, [.075, .075, .075, .075]),
                SA.set(this, void 0),
                EA.set(this, null),
                MA.set(this, void 0),
                TA.set(this, !1),
                GA(this, kg, a, "f"),
                GA(this, cA, r, "f"),
                GA(this, _A, s, "f"),
                GA(this, vA, o, "f"),
                GA(this, wA, l, "f"),
                GA(this, qg, e, "f"),
                (null == l ? void 0 : l.getSettingBoolean(dm.ParticlesEnabled)) ? GA(this, SA, new wg(r), "f") : GA(this, SA, null, "f"),
                null != QA(this, _A, "f") && null != QA(this, vA, "f") && GA(this, yA, [new Lg(QA(this, cA, "f")), new Lg(QA(this, cA, "f")), new Lg(QA(this, cA, "f")), new Lg(QA(this, cA, "f"))], "f"),
                GA(this, Xg, new lg, "f"),
                QA(this, Xg, "f").reset(t.position, t.quaternion),
                r.scene.add(QA(this, Xg, "f").camera),
                GA(this, jg, new Ym, "f"),
                QA(this, jg, "f").reset(t.position, t.quaternion),
                r.scene.add(QA(this, jg, "f").camera),
                null == Ng.models)
                    throw new Error("Car model isn't loaded yet");
                if (null != QA(this, qg, "f") && null != QA(this, _A, "f") && null != QA(this, vA, "f"))
                    GA(this, Kg, QA(this, qg, "f").createCar(t, QA(this, _A, "f").getMountainVertices(), QA(this, _A, "f").getMountainOffset(), QA(this, vA, "f").getTrackData(), n, (e => {
                        this.setCarState(e)
                    }
                    )), "f");
                else {
                    const e = [new Zt(.627909,.27 - Ng.suspensionResetLengthFront,1.3478).applyQuaternion(t.quaternion).add(t.position), new Zt(-.627909,.27 - Ng.suspensionResetLengthFront,1.3478).applyQuaternion(t.quaternion).add(t.position), new Zt(.720832,.27 - Ng.suspensionResetLengthRear,-1.52686).applyQuaternion(t.quaternion).add(t.position), new Zt(-.720832,.27 - Ng.suspensionResetLengthRear,-1.52686).applyQuaternion(t.quaternion).add(t.position)]
                      , n = [(new Kt).setFromEuler((new Fn).set(0, Math.PI, 0)).multiply(t.quaternion), (new Kt).setFromEuler((new Fn).set(0, Math.PI, 0)).multiply(t.quaternion), (new Kt).setFromEuler((new Fn).set(0, Math.PI, 0)).multiply(t.quaternion), (new Kt).setFromEuler((new Fn).set(0, Math.PI, 0)).multiply(t.quaternion)];
                    GA(this, Kg, {
                        id: 0,
                        frames: 0,
                        speedKmh: 0,
                        hasStarted: !1,
                        finishFrames: null,
                        nextCheckpointIndex: 0,
                        hasCheckpointToRespawnAt: !1,
                        position: {
                            x: t.position.x,
                            y: t.position.y,
                            z: t.position.z
                        },
                        quaternion: {
                            x: t.quaternion.x,
                            y: t.quaternion.y,
                            z: t.quaternion.z,
                            w: t.quaternion.w
                        },
                        collisionImpulses: [],
                        wheelContact: [null, null, null, null],
                        wheelSuspensionLength: [Ng.suspensionResetLengthFront, Ng.suspensionResetLengthFront, Ng.suspensionResetLengthRear, Ng.suspensionResetLengthRear],
                        wheelSuspensionVelocity: [0, 0, 0, 0],
                        wheelRotation: [0, 0, 0, 0],
                        wheelDeltaRotation: [0, 0, 0, 0],
                        wheelSkidInfo: [0, 0, 0, 0],
                        wheelPosition: e,
                        wheelQuaternion: n,
                        brakeLightEnabled: !1,
                        controls: {
                            up: !1,
                            right: !1,
                            down: !1,
                            left: !1,
                            reset: !1
                        }
                    }, "f")
                }
                if (GA(this, Zg, i, "f"),
                null == n)
                    GA(this, Jg, null != QA(this, Zg, "f"), "f"),
                    GA(this, $g, new Sh, "f");
                else {
                    if (null != QA(this, Zg, "f"))
                        throw new Error("Can't control car when recording is set");
                    GA(this, Jg, !1, "f"),
                    GA(this, $g, n, "f")
                }
                GA(this, AA, Zm.random(), "f"),
                GA(this, mA, Ng.createTexture(r), "f"),
                GA(this, gA, {
                    value: new Zt(0,0,0)
                }, "f"),
                GA(this, hA, new pr, "f"),
                QA(this, hA, "f").add(Ng.models.chassis.clone()),
                QA(this, hA, "f").add(Ng.models.suspension.clone()),
                QA(this, hA, "f").add(Ng.models.wheelFL.clone()),
                QA(this, hA, "f").add(Ng.models.wheelFR.clone()),
                QA(this, hA, "f").add(Ng.models.wheelBL.clone()),
                QA(this, hA, "f").add(Ng.models.wheelBR.clone());
                for (const e of QA(this, hA, "f").children) {
                    const t = e;
                    let n;
                    Array.isArray(t.material) ? (n = t.material.map((e => e.clone())),
                    t.material = n) : (n = [t.material.clone()],
                    t.material = n[0]);
                    for (const e of n)
                        if ("Main" == e.name)
                            e.onBeforeCompile = e => {
                                e.fragmentShader = "uniform sampler2D carColorPattern;\nuniform vec3 carColorSecondary;\n" + e.fragmentShader,
                                e.fragmentShader = e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", "float colorSource = texture(carColorPattern, vUv).a;\nvec4 diffuseColor = vec4( carColorSecondary * colorSource + diffuse * (1.0 - colorSource), opacity );"),
                                e.uniforms.carColorPattern = {
                                    value: QA(this, mA, "f")
                                },
                                e.uniforms.carColorSecondary = QA(this, gA, "f"),
                                null == e.defines && (e.defines = {}),
                                e.defines.USE_UV = !0
                            }
                            ,
                            e.needsUpdate = !0;
                        else if ("Metal" == e.name)
                            e.needsUpdate = !0;
                        else if ("BrakeLight" == e.name) {
                            if (!(e instanceof xa))
                                throw new Error("Brake light material must be MeshStandardMaterial");
                            GA(this, pA, e, "f")
                        }
                    t.castShadow = !0,
                    t.receiveShadow = !0,
                    t.frustumCulled = !1,
                    r.addMaterial(t.material)
                }
                QA(this, cA, "f").scene.add(QA(this, hA, "f")),
                GA(this, dA, QA(this, hA, "f").getObjectByName("Body"), "f"),
                GA(this, uA, QA(this, hA, "f").getObjectByName("Suspension"), "f"),
                QA(this, uA, "f").geometry.morphAttributes.position = [];
                const h = QA(this, uA, "f")
                  , d = Ng.models.suspensionFL
                  , u = Ng.models.suspensionFR
                  , f = Ng.models.suspensionBL
                  , p = Ng.models.suspensionBR;
                for (const e of QA(this, hA, "f").children)
                    if (e != QA(this, dA, "f") && e != QA(this, uA, "f")) {
                        const t = e;
                        if (!(d.geometry.attributes.position instanceof Ci && u.geometry.attributes.position instanceof Ci && f.geometry.attributes.position instanceof Ci && p.geometry.attributes.position instanceof Ci))
                            throw new Error("Vertices must use BufferAttribute");
                        const n = d.geometry.attributes.position.array
                          , i = u.geometry.attributes.position.array
                          , r = f.geometry.attributes.position.array
                          , a = p.geometry.attributes.position.array
                          , s = h.geometry.morphAttributes.position;
                        if ("WheelFL" == t.name)
                            s.push(new Ci(n,3));
                        else if ("WheelFR" == t.name)
                            s.push(new Ci(i,3));
                        else if ("WheelBL" == t.name)
                            s.push(new Ci(r,3));
                        else {
                            if ("WheelBR" != t.name)
                                throw new Error("Unidentified wheel");
                            s.push(new Ci(a,3))
                        }
                        QA(this, fA, "f").push(t)
                    }
                QA(this, uA, "f").updateMorphTargets(),
                null != QA(this, Zg, "f") && (null === (c = QA(this, qg, "f")) || void 0 === c || c.controlCar(QA(this, Kg, "f").id, QA(this, Zg, "f").up, QA(this, Zg, "f").right, QA(this, Zg, "f").down, QA(this, Zg, "f").left, QA(this, Zg, "f").reset),
                QA(this, Zg, "f").addChangeCallback(GA(this, EA, (e => {
                    var t;
                    null === (t = QA(this, qg, "f")) || void 0 === t || t.controlCar(QA(this, Kg, "f").id, e.up, e.right, e.down, e.left, e.reset)
                }
                ), "f"))),
                r.addContextRestoredEventListener(GA(this, MA, ( () => {
                    QA(this, mA, "f").dispose(),
                    GA(this, mA, Ng.createTexture(r), "f")
                }
                ), "f"))
            }
            dispose() {
                var e, t, n;
                GA(this, TA, !0, "f"),
                QA(this, Ug, "m", CA).call(this),
                QA(this, cA, "f").scene.remove(QA(this, Xg, "f").camera),
                QA(this, cA, "f").scene.remove(QA(this, jg, "f").camera),
                null === (e = QA(this, SA, "f")) || void 0 === e || e.dispose();
                for (const e of QA(this, yA, "f"))
                    e.dispose();
                QA(this, yA, "f").length = 0,
                QA(this, cA, "f").scene.remove(QA(this, hA, "f")),
                QA(this, mA, "f").dispose();
                for (const e of QA(this, hA, "f").children) {
                    if (!(e instanceof Zi))
                        throw new Error("Mesh is not a THREE.Mesh");
                    QA(this, cA, "f").removeMaterial(e.material)
                }
                null === (t = QA(this, qg, "f")) || void 0 === t || t.deleteCar(QA(this, Kg, "f").id),
                null != QA(this, EA, "f") && (null === (n = QA(this, Zg, "f")) || void 0 === n || n.removeChangeCallback(QA(this, EA, "f"))),
                QA(this, cA, "f").removeContextRestoredEventListener(QA(this, MA, "f"))
            }
            addResetCallback(e) {
                QA(this, iA, "f").push(e)
            }
            addCheckpointCallback(e) {
                QA(this, rA, "f").push(e)
            }
            addFinishCallback(e) {
                QA(this, aA, "f").push(e)
            }
            getChassisMatrix() {
                return null != QA(this, dA, "f") ? QA(this, dA, "f").matrix : null
            }
            getSpeedKmh() {
                return QA(this, Kg, "f").speedKmh
            }
            start() {
                var e;
                null === (e = QA(this, qg, "f")) || void 0 === e || e.startCar(QA(this, Kg, "f").id, null)
            }
            hasStarted() {
                return QA(this, Kg, "f").hasStarted
            }
            hasFinished() {
                return null != QA(this, Kg, "f").finishFrames
            }
            getFinishTime() {
                return null == QA(this, Kg, "f").finishFrames ? null : new Xh(QA(this, Kg, "f").finishFrames)
            }
            getRecording() {
                return QA(this, $g, "f")
            }
            getTime() {
                return new Xh(QA(this, Kg, "f").frames)
            }
            getNextCheckpointIndex() {
                return QA(this, Kg, "f").nextCheckpointIndex
            }
            hasCheckpointToRespawnAt() {
                return QA(this, Kg, "f").hasCheckpointToRespawnAt
            }
            getPosition() {
                return new Zt(QA(this, Kg, "f").position.x,QA(this, Kg, "f").position.y,QA(this, Kg, "f").position.z)
            }
            getQuaternion() {
                return new Kt(QA(this, Kg, "f").quaternion.x,QA(this, Kg, "f").quaternion.y,QA(this, Kg, "f").quaternion.z,QA(this, Kg, "f").quaternion.w)
            }
            getMatrix4() {
                const e = this.getPosition()
                  , t = this.getQuaternion()
                  , n = (new Cn).makeRotationFromQuaternion(t);
                return n.setPosition(e),
                n
            }
            get isPaused() {
                return QA(this, Yg, "f")
            }
            set isPaused(e) {
                var t;
                QA(this, Yg, "f") != e && (null === (t = QA(this, qg, "f")) || void 0 === t || t.pauseCar(QA(this, Kg, "f").id, e),
                GA(this, Yg, e, "f"))
            }
            getControls() {
                return null != QA(this, Zg, "f") ? QA(this, Zg, "f").getControls() : QA(this, Kg, "f").controls
            }
            getColors() {
                return QA(this, AA, "f")
            }
            setColors(e) {
                if (QA(this, gA, "f").value = (new Zt).setFromColor(e.secondary),
                null != QA(this, dA, "f") && Array.isArray(QA(this, dA, "f").material))
                    for (const t of QA(this, dA, "f").material)
                        "Main" == t.name ? t.color.set(e.primary) : "Metal" == t.name && t.color.set(e.frame);
                if (null != QA(this, uA, "f") && !Array.isArray(QA(this, uA, "f").material)) {
                    const t = QA(this, uA, "f").material;
                    "Metal" == t.name && t.color.set(e.frame)
                }
                for (const t of QA(this, fA, "f"))
                    if (Array.isArray(t.material))
                        for (const n of t.material)
                            "Metal" == n.name ? n.color.set(e.frame) : "Rim" == n.name && n.color.set(e.rims);
                GA(this, AA, e, "f")
            }
            static createTexture(e) {
                if (null == Ng.images)
                    throw new Error("Car images are not loaded yet");
                const t = document.createElement("canvas");
                t.width = 2048,
                t.height = 2048;
                const n = t.getContext("2d");
                if (null == n)
                    throw new Error("Failed to get context for car texture");
                const i = new Gt(t);
                return i.flipY = !1,
                i.anisotropy = e.getMaxAnisotropy(),
                i.needsUpdate = !0,
                n.clearRect(0, 0, n.canvas.width, n.canvas.height),
                n.drawImage(Ng.images.stripe, 0, 0, n.canvas.width, n.canvas.height),
                i.needsUpdate = !0,
                i
            }
            setOpacity(e) {
                for (const t of QA(this, hA, "f").children) {
                    const n = t;
                    let i;
                    i = Array.isArray(n.material) ? n.material : [n.material];
                    for (const t of i) {
                        t.opacity = e;
                        const n = e < 1;
                        t.needsUpdate = n != t.transparent,
                        t.transparent = n
                    }
                }
            }
            setVisible(e) {
                QA(this, hA, "f").visible = e
            }
            getCarState() {
                return QA(this, Kg, "f")
            }
            setCarState(e) {
                var t;
                if (QA(this, TA, "f"))
                    return;
                const n = QA(this, Kg, "f");
                GA(this, Kg, e, "f");
                const i = QA(this, Kg, "f").frames != n.frames && QA(this, Kg, "f").frames != n.frames + 1
                  , r = .001;
                if (i) {
                    null === (t = QA(this, SA, "f")) || void 0 === t || t.clear();
                    for (const e of QA(this, yA, "f"))
                        e.clear()
                }
                if (this.getTime().numberOfFrames % 10 == 0 && QA(this, Ug, "m", BA).call(this, .01),
                i || !n.controls.reset && QA(this, Kg, "f").controls.reset) {
                    QA(this, Xg, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()),
                    QA(this, jg, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh());
                    for (const e of QA(this, iA, "f"))
                        e()
                }
                if (QA(this, Ug, "m", UA).call(this, r),
                QA(this, Ug, "m", kA).call(this, r),
                QA(this, Jg, "f") && QA(this, Kg, "f").hasStarted && null == n.finishFrames && QA(this, $g, "f").recordFrame(n.frames, QA(this, Kg, "f").controls),
                QA(this, Kg, "f").nextCheckpointIndex > n.nextCheckpointIndex) {
                    this.notificationAudioEnabled && QA(this, Ug, "m", RA).call(this);
                    for (const e of QA(this, rA, "f"))
                        e(n.nextCheckpointIndex)
                }
                if (null != QA(this, Kg, "f").finishFrames && null == n.finishFrames) {
                    this.notificationAudioEnabled && QA(this, Ug, "m", PA).call(this);
                    for (const e of QA(this, aA, "f"))
                        e(this)
                }
            }
            update(e) {
                var t, n;
                if (null != QA(this, dA, "f") && null != QA(this, uA, "f")) {
                    QA(this, Ug, "m", DA).call(this),
                    null === (t = QA(this, SA, "f")) || void 0 === t || t.update(e);
                    const i = this.getMatrix4()
                      , r = this.getQuaternion();
                    QA(this, dA, "f").matrixAutoUpdate = !1,
                    QA(this, dA, "f").matrix.copy(i),
                    QA(this, dA, "f").matrix.multiply((new Cn).makeTranslation(0, Ng.massOffset, 0)),
                    QA(this, uA, "f").matrixAutoUpdate = !1,
                    QA(this, uA, "f").matrix.copy(QA(this, dA, "f").matrix);
                    const a = 4;
                    for (let t = 0; t < a; t++) {
                        const i = null != QA(this, Kg, "f").wheelContact[t]
                          , a = QA(this, Kg, "f").wheelDeltaRotation[t];
                        if (this.hasStarted()) {
                            if (i)
                                QA(this, sA, "f")[t] = 1e3 * a,
                                QA(this, oA, "f")[t] = 1e3 * a;
                            else {
                                const {up: n, down: i} = this.getControls()
                                  , r = 2 == t || 3 == t;
                                i ? QA(this, Kg, "f").brakeLightEnabled ? QA(this, oA, "f")[t] > 0 ? QA(this, oA, "f")[t] = Math.max(0, QA(this, oA, "f")[t] - 50 * e) : QA(this, oA, "f")[t] < 0 && (QA(this, oA, "f")[t] = Math.min(0, QA(this, oA, "f")[t] + 50 * e)) : r && (QA(this, sA, "f")[t] -= 25 * e,
                                QA(this, oA, "f")[t] -= 25 * e) : n && r && (QA(this, sA, "f")[t] += 25 * e,
                                QA(this, oA, "f")[t] += 50 * e),
                                QA(this, sA, "f")[t] *= Math.max(0, 1 - e),
                                QA(this, oA, "f")[t] *= Math.max(0, 1 - e)
                            }
                            QA(this, lA, "f")[t] += QA(this, oA, "f")[t] * e
                        }
                        const s = QA(this, Kg, "f").wheelPosition[t]
                          , o = new Kt(QA(this, Kg, "f").wheelQuaternion[t].x,QA(this, Kg, "f").wheelQuaternion[t].y,QA(this, Kg, "f").wheelQuaternion[t].z,QA(this, Kg, "f").wheelQuaternion[t].w)
                          , l = QA(this, Kg, "f").wheelRotation[t];
                        o.multiply((new Kt).setFromAxisAngle(new Zt(-1,0,0), QA(this, lA, "f")[t] - l)),
                        QA(this, fA, "f")[t].position.set(s.x, s.y, s.z),
                        QA(this, fA, "f")[t].quaternion.set(o.x, o.y, o.z, o.w);
                        const c = QA(this, Kg, "f").wheelSuspensionLength[t]
                          , h = QA(this, Kg, "f").wheelSkidInfo[t];
                        if (QA(this, uA, "f").morphTargetInfluences || (QA(this, uA, "f").morphTargetInfluences = []),
                        QA(this, uA, "f").morphTargetInfluences[t] = 2 * c + .06,
                        e > 0 && (null === (n = QA(this, wA, "f")) || void 0 === n ? void 0 : n.getSettingBoolean(dm.SkidmarksEnabled)) && t < QA(this, yA, "f").length) {
                            const e = QA(this, Kg, "f").wheelContact[t]
                              , n = Math.min(1, Math.abs(a) / QA(Ng, Ng, "f", eA))
                              , i = Math.pow(n, QA(Ng, Ng, "f", tA)) * QA(Ng, Ng, "f", nA);
                            null != e && h < i && 0 == QA(this, bA, "f")[t] && QA(this, yA, "f")[t].spawn(new Zt(s.x,s.y,s.z), r, new Zt(e.position.x,e.position.y,e.position.z), new Zt(e.normal.x,e.normal.y,e.normal.z))
                        }
                    }
                    QA(this, Ug, "m", zA).call(this, QA(this, Kg, "f").brakeLightEnabled)
                }
            }
            updateCameras(e) {
                if (null == QA(this, Kg, "f").finishFrames) {
                    const t = this.getPosition()
                      , n = this.getQuaternion()
                      , i = this.getSpeedKmh();
                    QA(this, Xg, "f").update(e, t, n, i),
                    QA(this, jg, "f").update(t, n, i)
                }
            }
            get cameraOrbit() {
                return QA(this, Xg, "f").camera
            }
            get cameraCockpit() {
                return QA(this, jg, "f").camera
            }
            set audioVolume(e) {
                GA(this, Og, e, "f"),
                null != QA(this, Fg, "f") && QA(this, Fg, "f").gain.setTargetAtTime(QA(this, Og, "f"), 0, .01)
            }
            static initResources() {
                return VA(this, void 0, void 0, (function*() {
                    const e = yield new Promise(( (e, t) => {
                        (new gd).load("models/car.glb", (n => {
                            function i(e) {
                                const t = n.scene.getObjectByName(e);
                                if (null == t)
                                    throw new Error('Mesh "' + e + '" does not exist');
                                if (0 == t.children.length) {
                                    const e = t;
                                    return e.updateMatrixWorld(!0),
                                    e.geometry.applyMatrix4(e.matrix.clone()),
                                    e.matrix.identity(),
                                    e
                                }
                                const i = function(e, t=!1) {
                                    const n = null !== e[0].index
                                      , i = new Set(Object.keys(e[0].attributes))
                                      , r = new Set(Object.keys(e[0].morphAttributes))
                                      , a = {}
                                      , s = {}
                                      , o = e[0].morphTargetsRelative
                                      , l = new Oi;
                                    let c = 0;
                                    for (let h = 0; h < e.length; ++h) {
                                        const d = e[h];
                                        let u = 0;
                                        if (n !== (null !== d.index))
                                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
                                            null;
                                        for (const e in d.attributes) {
                                            if (!i.has(e))
                                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + e + '" attribute exists among all geometries, or in none of them.'),
                                                null;
                                            void 0 === a[e] && (a[e] = []),
                                            a[e].push(d.attributes[e]),
                                            u++
                                        }
                                        if (u !== i.size)
                                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."),
                                            null;
                                        if (o !== d.morphTargetsRelative)
                                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."),
                                            null;
                                        for (const e in d.morphAttributes) {
                                            if (!r.has(e))
                                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."),
                                                null;
                                            void 0 === s[e] && (s[e] = []),
                                            s[e].push(d.morphAttributes[e])
                                        }
                                        if (t) {
                                            let e;
                                            if (n)
                                                e = d.index.count;
                                            else {
                                                if (void 0 === d.attributes.position)
                                                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"),
                                                    null;
                                                e = d.attributes.position.count
                                            }
                                            l.addGroup(c, e, h),
                                            c += e
                                        }
                                    }
                                    if (n) {
                                        let t = 0;
                                        const n = [];
                                        for (let i = 0; i < e.length; ++i) {
                                            const r = e[i].index;
                                            for (let e = 0; e < r.count; ++e)
                                                n.push(r.getX(e) + t);
                                            t += e[i].attributes.position.count
                                        }
                                        l.setIndex(n)
                                    }
                                    for (const e in a) {
                                        const t = pd(a[e]);
                                        if (!t)
                                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " attribute."),
                                            null;
                                        l.setAttribute(e, t)
                                    }
                                    for (const e in s) {
                                        const t = s[e][0].length;
                                        if (0 === t)
                                            break;
                                        l.morphAttributes = l.morphAttributes || {},
                                        l.morphAttributes[e] = [];
                                        for (let n = 0; n < t; ++n) {
                                            const t = [];
                                            for (let i = 0; i < s[e].length; ++i)
                                                t.push(s[e][i][n]);
                                            const i = pd(t);
                                            if (!i)
                                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " morphAttribute."),
                                                null;
                                            l.morphAttributes[e].push(i)
                                        }
                                    }
                                    return l
                                }(t.children.map((e => e.geometry)), !0);
                                t.updateMatrixWorld(!0),
                                i.applyMatrix4(t.matrix.clone());
                                const r = t.children.map((e => e.material))
                                  , a = new Zi(i,r);
                                return a.name = e,
                                a
                            }
                            function r(e) {
                                let t;
                                t = Array.isArray(e.material) ? e.material : [e.material];
                                for (const e of t)
                                    e.side = 0,
                                    e.shadowSide = 0;
                                return e
                            }
                            Ng.models = {
                                chassis: r(i("Body")),
                                suspension: r(i("Suspension")),
                                suspensionFL: r(i("SuspensionFL")),
                                suspensionFR: r(i("SuspensionFR")),
                                suspensionBL: r(i("SuspensionBL")),
                                suspensionBR: r(i("SuspensionBR")),
                                wheelFL: r(i("WheelFL")),
                                wheelFR: r(i("WheelFR")),
                                wheelBL: r(i("WheelBL")),
                                wheelBR: r(i("WheelBR")),
                                collisionShapeVertices: QA(Ng, Ng, "m", HA).call(Ng, i("Collision"))
                            },
                            Ng.models.wheelFL.geometry.translate(-.627909, .218824, -1.3478),
                            Ng.models.wheelFR.geometry.translate(.627909, .218824, -1.3478),
                            Ng.models.wheelBL.geometry.translate(-.720832, .218824, 1.52686),
                            Ng.models.wheelBR.geometry.translate(.720832, .218824, 1.52686),
                            Ng.models.wheelFL.geometry.rotateZ(Math.PI),
                            Ng.models.wheelFR.geometry.rotateZ(Math.PI),
                            Ng.models.wheelBL.geometry.rotateZ(Math.PI),
                            Ng.models.wheelBR.geometry.rotateZ(Math.PI),
                            QA(Ng, Ng, "m", WA).call(Ng).then((t => {
                                e(t)
                            }
                            )).catch(t)
                        }
                        ), void 0, t)
                    }
                    ));
                    return yield new Promise(( (e, t) => {
                        const n = new Image;
                        n.addEventListener("load", ( () => {
                            e()
                        }
                        )),
                        n.addEventListener("error", ( () => {
                            t(new Error("Failed to load image"))
                        }
                        )),
                        n.src = "images/car_stripe.svg",
                        Ng.images = {
                            stripe: n
                        }
                    }
                    )),
                    e
                }
                ))
            }
        }
        Ng = XA,
        kg = new WeakMap,
        Fg = new WeakMap,
        Og = new WeakMap,
        zg = new WeakMap,
        Hg = new WeakMap,
        Wg = new WeakMap,
        Vg = new WeakMap,
        Gg = new WeakMap,
        Qg = new WeakMap,
        Xg = new WeakMap,
        jg = new WeakMap,
        qg = new WeakMap,
        Yg = new WeakMap,
        Kg = new WeakMap,
        Zg = new WeakMap,
        Jg = new WeakMap,
        $g = new WeakMap,
        iA = new WeakMap,
        rA = new WeakMap,
        aA = new WeakMap,
        sA = new WeakMap,
        oA = new WeakMap,
        lA = new WeakMap,
        cA = new WeakMap,
        hA = new WeakMap,
        dA = new WeakMap,
        uA = new WeakMap,
        fA = new WeakMap,
        pA = new WeakMap,
        mA = new WeakMap,
        gA = new WeakMap,
        AA = new WeakMap,
        _A = new WeakMap,
        vA = new WeakMap,
        wA = new WeakMap,
        yA = new WeakMap,
        xA = new WeakMap,
        bA = new WeakMap,
        SA = new WeakMap,
        EA = new WeakMap,
        MA = new WeakMap,
        TA = new WeakMap,
        Ug = new WeakSet,
        CA = function() {
            QA(this, Ug, "m", IA).call(this),
            setTimeout(( () => {
                if (null != QA(this, zg, "f") && (QA(this, zg, "f").source.stop(),
                GA(this, zg, null, "f")),
                null != QA(this, Wg, "f")) {
                    for (const {source: e} of QA(this, Wg, "f"))
                        e.stop();
                    GA(this, Wg, null, "f")
                }
            }
            ), 200)
        }
        ,
        IA = function() {
            if (null != QA(this, zg, "f") && (QA(this, zg, "f").source.playbackRate.setTargetAtTime(.7, 0, .15),
            QA(this, zg, "f").gain.gain.setTargetAtTime(0, 0, .15)),
            null != QA(this, Wg, "f"))
                for (const e of QA(this, Wg, "f"))
                    e.source.playbackRate.setTargetAtTime(.3, 0, .15),
                    e.gain.gain.setTargetAtTime(0, 0, .15);
            if (null != QA(this, xA, "f")) {
                for (const {source: e} of QA(this, xA, "f"))
                    e.stop();
                GA(this, xA, null, "f")
            }
        }
        ,
        RA = function() {
            var e, t;
            const n = null !== (t = null === (e = QA(this, wA, "f")) || void 0 === e ? void 0 : e.getSettingFloat(dm.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(QA(this, Og, "f") * n, 0), 1);
            if (Number.isNaN(i) && (i = 0),
            i > 0 && null != QA(this, kg, "f")) {
                const e = QA(this, kg, "f").getBuffer("checkpoint");
                if (null != e && null != QA(this, kg, "f").context && null != QA(this, kg, "f").destinationMaster) {
                    const t = QA(this, kg, "f").context.createBufferSource();
                    t.buffer = e,
                    t.playbackRate.value = 1.25;
                    const n = QA(this, kg, "f").context.createGain();
                    n.gain.value = .03 * i,
                    t.connect(n),
                    n.connect(QA(this, kg, "f").destinationMaster),
                    t.start(0)
                }
            }
        }
        ,
        PA = function() {
            var e, t;
            const n = null !== (t = null === (e = QA(this, wA, "f")) || void 0 === e ? void 0 : e.getSettingFloat(dm.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(QA(this, Og, "f") * n, 0), 1);
            if (Number.isNaN(i) && (i = 0),
            i > 0 && null != QA(this, kg, "f")) {
                const e = QA(this, kg, "f").getBuffer("finish");
                if (null != e && null != QA(this, kg, "f").context && null != QA(this, kg, "f").destinationMaster) {
                    const t = QA(this, kg, "f").context.createBufferSource();
                    t.buffer = e,
                    t.playbackRate.value = 1.25;
                    const n = QA(this, kg, "f").context.createGain();
                    n.gain.value = .03,
                    t.connect(n),
                    n.connect(QA(this, kg, "f").destinationMaster),
                    t.start(0)
                }
            }
        }
        ,
        BA = function(e) {
            var t;
            for (let n = 0; n < 4; n++) {
                const i = QA(this, Kg, "f").wheelPosition[n]
                  , r = null != QA(this, Kg, "f").wheelContact[n]
                  , a = QA(this, Kg, "f").wheelDeltaRotation[n]
                  , s = QA(this, Kg, "f").wheelSkidInfo[n]
                  , o = Math.min(1, Math.abs(a) / QA(Ng, Ng, "f", eA))
                  , l = Math.pow(o, QA(Ng, Ng, "f", tA)) * QA(Ng, Ng, "f", nA);
                r && s < l ? (n < QA(this, yA, "f").length && (QA(this, bA, "f")[n] = Math.max(0, QA(this, bA, "f")[n] - e)),
                0 == QA(this, bA, "f")[n] && null != QA(this, SA, "f") && QA(this, SA, "f").spawn(i.x, i.y, i.z)) : (n < QA(this, yA, "f").length && (null === (t = QA(this, wA, "f")) || void 0 === t ? void 0 : t.getSettingBoolean(dm.SkidmarksEnabled)) && QA(this, yA, "f")[n].break(),
                QA(this, bA, "f")[n] = .075)
            }
        }
        ,
        DA = function() {
            if (null != QA(this, kg, "f") && null != QA(this, kg, "f").context && null != QA(this, kg, "f").destinationSfx) {
                null == QA(this, Fg, "f") && (GA(this, Fg, QA(this, kg, "f").context.createGain(), "f"),
                QA(this, Fg, "f").gain.value = QA(this, Og, "f"),
                QA(this, Fg, "f").connect(QA(this, kg, "f").destinationSfx)),
                null == QA(this, Gg, "f") && (GA(this, Gg, QA(this, kg, "f").context.createPanner(), "f"),
                QA(this, Gg, "f").refDistance = 5,
                QA(this, Gg, "f").connect(QA(this, Fg, "f")));
                const e = this.getPosition();
                QA(this, Gg, "f").positionX.value = e.x,
                QA(this, Gg, "f").positionY.value = e.y,
                QA(this, Gg, "f").positionZ.value = e.z;
                const t = 4;
                if (QA(this, Qg, "f").length < t) {
                    QA(this, Qg, "f").length = 0;
                    for (let e = 0; e < t; ++e) {
                        const e = QA(this, kg, "f").context.createPanner();
                        e.refDistance = 5,
                        e.connect(QA(this, Fg, "f")),
                        QA(this, Qg, "f").push(e)
                    }
                }
                for (let e = 0; e < t; ++e) {
                    const t = QA(this, Qg, "f")[e]
                      , n = QA(this, Kg, "f").wheelPosition[e];
                    t.positionX.value = n.x,
                    t.positionY.value = n.y,
                    t.positionZ.value = n.z
                }
                QA(this, cA, "f").camera != QA(this, Xg, "f").camera && QA(this, cA, "f").camera != QA(this, jg, "f").camera || QA(this, kg, "f").refreshListener(QA(this, cA, "f")),
                QA(this, Ug, "m", LA).call(this),
                QA(this, Ug, "m", NA).call(this),
                QA(this, Ug, "m", OA).call(this)
            }
        }
        ,
        LA = function() {
            if (null == QA(this, zg, "f") && null != QA(this, Gg, "f") && null != QA(this, kg, "f")) {
                const e = QA(this, kg, "f").getBuffer("engine");
                if (null != e && null != QA(this, kg, "f").context) {
                    const t = QA(this, kg, "f").context.createBufferSource();
                    t.buffer = e,
                    t.loop = !0,
                    t.playbackRate.value = .7;
                    const n = QA(this, kg, "f").context.createGain();
                    n.gain.value = 0,
                    t.connect(n),
                    n.connect(QA(this, Gg, "f")),
                    t.start(0, 2 * Math.random()),
                    GA(this, zg, {
                        source: t,
                        gain: n
                    }, "f")
                }
            }
            if (null != QA(this, zg, "f")) {
                const e = (QA(this, sA, "f")[0] + QA(this, sA, "f")[1] + QA(this, sA, "f")[2] + QA(this, sA, "f")[3]) / 4
                  , t = .7 + Math.pow(Math.abs(e), 1 / 3) / 3
                  , n = null != QA(this, Kg, "f").wheelContact[0] || null != QA(this, Kg, "f").wheelContact[1] || null != QA(this, Kg, "f").wheelContact[2] || null != QA(this, Kg, "f").wheelContact[3]
                  , {up: i, down: r} = this.getControls()
                  , a = this.hasStarted() && !this.hasFinished() && (i && !(r && QA(this, Kg, "f").brakeLightEnabled) || r && !QA(this, Kg, "f").brakeLightEnabled);
                let s;
                s = n ? a ? t : Math.max(.7, t / 2) : a ? Math.max(.7, 1.15 * t) : Math.max(.7, t / 2),
                QA(this, zg, "f").source.playbackRate.setTargetAtTime(s, 0, .05),
                QA(this, zg, "f").gain.gain.setTargetAtTime(Math.min(.285, s / 14), 0, .05)
            }
        }
        ,
        UA = function(e) {
            if (QA(this, Hg, "f").length < 4) {
                QA(this, Hg, "f").length = 0;
                for (let e = 0; e < 4; ++e)
                    QA(this, Hg, "f").push(0)
            }
            for (let t = 0; t < 4 && t < QA(this, Qg, "f").length; t++)
                if (QA(this, Hg, "f")[t] -= e,
                QA(this, Hg, "f")[t] <= 0) {
                    const e = Math.abs(QA(this, Kg, "f").wheelSuspensionVelocity[t]);
                    if (e > 4 && null != QA(this, kg, "f")) {
                        const n = QA(this, kg, "f").getBuffer("suspension");
                        if (null != n && null != QA(this, kg, "f").context) {
                            const i = QA(this, kg, "f").context.createBufferSource();
                            i.buffer = n,
                            i.playbackRate.value = .7 + .1 * Math.random();
                            const r = QA(this, kg, "f").context.createGain();
                            r.gain.value = Math.min(.285, e / 140),
                            i.connect(r),
                            r.connect(QA(this, Qg, "f")[t]),
                            i.start(QA(this, kg, "f").context.currentTime + .02 * Math.random()),
                            QA(this, Hg, "f")[t] = .1
                        }
                    }
                }
        }
        ,
        NA = function() {
            if (null == QA(this, Wg, "f") && null != QA(this, kg, "f")) {
                const e = QA(this, kg, "f").getBuffer("tires");
                if (null != e && null != QA(this, kg, "f").context) {
                    GA(this, Wg, [], "f");
                    const t = 4;
                    for (let n = 0; n < t; n++) {
                        const i = QA(this, kg, "f").context.createBufferSource();
                        i.buffer = e,
                        i.loop = !0,
                        i.playbackRate.value = .3;
                        const r = QA(this, kg, "f").context.createGain();
                        r.gain.value = 0,
                        i.connect(r),
                        r.connect(QA(this, Qg, "f")[n]),
                        i.start(0, n / t * 3.5 + .25 * Math.random()),
                        QA(this, Wg, "f").push({
                            source: i,
                            gain: r
                        })
                    }
                }
            }
            if (null != QA(this, Wg, "f"))
                for (let e = 0; e < QA(this, Wg, "f").length; ++e) {
                    const t = QA(this, Wg, "f")[e];
                    if (null != QA(this, Kg, "f").wheelContact[e]) {
                        const e = Math.min(3, Math.abs(this.getSpeedKmh()) / 110);
                        t.gain.gain.setTargetAtTime(e / 10.5, 0, .15)
                    } else
                        t.gain.gain.setTargetAtTime(0, 0, .15);
                    const n = .3 + Math.min(.4, Math.abs(this.getSpeedKmh()) / 800);
                    t.source.playbackRate.setTargetAtTime(n, 0, .15)
                }
        }
        ,
        kA = function(e) {
            null != QA(this, Vg, "f") && (QA(this, Vg, "f").timeout -= e,
            QA(this, Vg, "f").timeout <= 0 && GA(this, Vg, null, "f"));
            const t = QA(this, Kg, "f").collisionImpulses;
            for (const e of t)
                QA(this, Ug, "m", FA).call(this, e)
        }
        ,
        FA = function(e) {
            if (e > 25 && null != QA(this, Gg, "f") && null != QA(this, kg, "f") && (null == QA(this, Vg, "f") || QA(this, Vg, "f").impulse + 100 < e)) {
                GA(this, Vg, {
                    timeout: .2,
                    impulse: e
                }, "f");
                const t = QA(this, kg, "f").getBuffer("collision");
                if (null != t && null != QA(this, kg, "f").context) {
                    const n = QA(this, kg, "f").context.createBufferSource();
                    n.buffer = t,
                    n.playbackRate.value = .1 + .15 * Math.min(e / 4e3, 1);
                    const i = QA(this, kg, "f").context.createGain();
                    i.gain.value = Math.max(.3, Math.min(e / 4e3, 1)) / 2.5,
                    n.connect(i),
                    i.connect(QA(this, Gg, "f")),
                    n.start(0)
                }
            }
        }
        ,
        OA = function() {
            if (null == QA(this, xA, "f") && null != QA(this, kg, "f")) {
                const e = QA(this, kg, "f").getBuffer("skidding");
                if (null != e && null != QA(this, kg, "f").context) {
                    GA(this, xA, [], "f");
                    const t = 4;
                    for (let n = 0; n < t; ++n) {
                        const i = QA(this, kg, "f").context.createBufferSource();
                        i.buffer = e,
                        i.loop = !0,
                        i.playbackRate.value = .5;
                        const r = QA(this, kg, "f").context.createGain();
                        r.gain.value = 0,
                        i.connect(r),
                        r.connect(QA(this, Qg, "f")[n]),
                        i.start(0, n / t * 3.5 + .25 * Math.random()),
                        QA(this, xA, "f").push({
                            source: i,
                            gain: r
                        })
                    }
                }
            }
            if (null != QA(this, xA, "f"))
                for (let e = 0; e < QA(this, xA, "f").length; ++e) {
                    const t = QA(this, xA, "f")[e];
                    0 == QA(this, bA, "f")[e] ? t.gain.gain.setTargetAtTime(.75 / 3.5, 0, .1) : t.gain.gain.setTargetAtTime(0, 0, .1)
                }
        }
        ,
        zA = function(e) {
            null != QA(this, pA, "f") && (e ? QA(this, pA, "f").emissive.setRGB(1, .4, .3) : QA(this, pA, "f").emissive.setRGB(0, 0, 0))
        }
        ,
        HA = function(e) {
            const t = e.geometry.toNonIndexed();
            if (!(t.attributes.position instanceof Ci))
                throw new Error("Vertices must use BufferAttribute");
            return Array.from(t.attributes.position.array)
        }
        ,
        WA = function() {
            return VA(this, void 0, void 0, (function*() {
                if (null == Ng.models)
                    throw new Error("Car models are not loaded yet");
                const e = new Float32Array(Ng.models.collisionShapeVertices)
                  , t = yield window.crypto.subtle.digest("SHA-256", e.buffer)
                  , n = Array.from(new Uint8Array(t)).map((e => e.toString(16).padStart(2, "0"))).join("")
                  , i = "dd663fb6330ed93725bf865d5eac2cd29ba19f74dbb3f67ae7f695ea1f68aed0";
                return n == i || console.error("Car collision model checksum mismatch: " + n + " != " + i),
                n == i
            }
            ))
        }
        ,
        XA.massOffset = .6,
        XA.detectorBoxCenter = new Zt(0,.48,-.15),
        XA.detectorBoxSize = new Zt(.89,.22,1.8),
        XA.suspensionResetLengthFront = .07809501004219055,
        XA.suspensionResetLengthRear = .0781289680480957,
        eA = {
            value: .08
        },
        tA = {
            value: 3
        },
        nA = {
            value: .5
        },
        XA.models = null,
        XA.images = null;
        const jA = XA;
        var qA, YA, KA, ZA, JA, $A, e_, t_, n_, i_, r_, a_, s_, o_, l_, c_, h_, d_, u_, f_, p_, m_, g_, A_, __, v_, w_, y_, x_, b_ = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, S_ = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        YA = new WeakMap,
        KA = new WeakMap,
        ZA = new WeakMap,
        JA = new WeakMap,
        $A = new WeakMap,
        e_ = new WeakMap,
        t_ = new WeakMap,
        n_ = new WeakMap,
        i_ = new WeakMap,
        r_ = new WeakMap,
        a_ = new WeakMap,
        s_ = new WeakMap,
        o_ = new WeakMap,
        l_ = new WeakMap,
        c_ = new WeakMap,
        h_ = new WeakMap,
        d_ = new WeakMap,
        u_ = new WeakMap,
        f_ = new WeakMap,
        p_ = new WeakMap,
        m_ = new WeakMap,
        g_ = new WeakMap,
        qA = new WeakSet,
        A_ = function(e) {
            if (e.length % 3 != 0)
                throw new Error("Car collision shape number of vertices is not dividable by 3");
            const t = new Ammo.btConvexHullShape;
            for (let n = 0; n < e.length; n += 3) {
                const i = e[n + 0]
                  , r = e[n + 1]
                  , a = e[n + 2]
                  , s = new Ammo.btVector3(i,r + S_(this, t_, "f"),a);
                t.addPoint(s, !0),
                Ammo.destroy(s)
            }
            return t.setMargin(.02),
            t
        }
        ,
        __ = function() {
            return new Zt(0,0,1).applyQuaternion(this.getQuaternion())
        }
        ,
        v_ = function() {
            return new Zt(0,-1,0).applyQuaternion(this.getQuaternion())
        }
        ,
        w_ = function() {
            const e = S_(this, JA, "f").getLinearVelocity();
            return new Zt(e.x(),e.y(),e.z())
        }
        ,
        y_ = function() {
            const e = Math.abs(S_(this, qA, "m", __).call(this).dot(S_(this, qA, "m", w_).call(this)))
              , t = S_(this, qA, "m", v_).call(this)
              , n = .05;
            S_(this, i_, "f").setValue(t.x * e * n, t.y * e * n, t.z * e * n),
            S_(this, JA, "f").applyCentralImpulse(S_(this, i_, "f"))
        }
        ,
        x_ = function(e, t) {
            var n;
            b_(this, m_, !1, "f");
            let i = !1
              , r = !1
              , a = !1
              , s = !1
              , o = !1;
            S_(this, h_, "f") && (this.hasFinished() || ({up: i, right: r, down: a, left: s, reset: o} = null !== (n = null == t ? void 0 : t.getControls(S_(this, d_, "f").numberOfFrames)) && void 0 !== n ? n : {
                up: !1,
                right: !1,
                down: !1,
                left: !1,
                reset: !1
            }),
            S_(this, d_, "f").increment());
            const l = this.getWheelInContact(0) || this.getWheelInContact(1) || this.getWheelInContact(2) || this.getWheelInContact(3);
            if (!l && a && !this.hasFinished() && S_(this, h_, "f") ? S_(this, JA, "f").setDamping(.1, .6) : S_(this, JA, "f").setDamping(.1, .1),
            i && !this.hasFinished() && S_(this, h_, "f")) {
                const e = 4e3;
                S_(this, ZA, "f").applyEngineForce(e, 2),
                S_(this, ZA, "f").applyEngineForce(e, 3)
            } else
                S_(this, ZA, "f").applyEngineForce(0, 2),
                S_(this, ZA, "f").applyEngineForce(0, 3);
            if (a && !this.hasFinished() && S_(this, h_, "f"))
                if (this.getSpeedKmh() > 1 || !l) {
                    const e = 10;
                    S_(this, ZA, "f").setBrake(e, 0),
                    S_(this, ZA, "f").setBrake(e, 1),
                    S_(this, ZA, "f").setBrake(e, 2),
                    S_(this, ZA, "f").setBrake(e, 3),
                    b_(this, m_, !0, "f")
                } else {
                    const e = Math.min(0, Math.max(-2e3, -2e3 * (1 + this.getSpeedKmh() / 100)));
                    S_(this, ZA, "f").applyEngineForce(e, 2),
                    S_(this, ZA, "f").applyEngineForce(e, 3),
                    S_(this, ZA, "f").setBrake(0, 0),
                    S_(this, ZA, "f").setBrake(0, 1),
                    S_(this, ZA, "f").setBrake(0, 2),
                    S_(this, ZA, "f").setBrake(0, 3)
                }
            else
                S_(this, ZA, "f").setBrake(0, 0),
                S_(this, ZA, "f").setBrake(0, 1),
                S_(this, ZA, "f").setBrake(0, 2),
                S_(this, ZA, "f").setBrake(0, 3);
            const c = S_(this, qA, "m", w_).call(this).applyQuaternion(this.getQuaternion().invert())
              , h = -new St(c.x,c.z).normalize().angle() + Math.PI / 2;
            let d = Math.max(0, Math.min(1, this.getSpeedKmh() / 30));
            this.getWheelInContact(0) || this.getWheelInContact(1) || (d = 0);
            const u = 155 / Math.pow(46, 1.55)
              , f = Math.max(-u, Math.min(u, h * d))
              , p = 155 / Math.pow(Math.max(46, Math.abs(this.getSpeedKmh())), 1.55);
            S_(this, h_, "f") && (s && !this.hasFinished() ? b_(this, l_, Math.min(S_(this, l_, "f") + 10 * e, 1), "f") : r && !this.hasFinished() ? b_(this, l_, Math.max(S_(this, l_, "f") - 10 * e, -1), "f") : S_(this, l_, "f") > 0 ? b_(this, l_, Math.max(S_(this, l_, "f") - 10 * e, 0), "f") : S_(this, l_, "f") < 0 && b_(this, l_, Math.min(S_(this, l_, "f") + 10 * e, 0), "f"));
            const m = S_(this, l_, "f") * p;
            let g;
            g = f < 0 && m < 0 ? Math.min(f, m) : f > 0 && m > 0 ? Math.max(f, m) : f + m,
            S_(this, ZA, "f").setSteeringValue(g, 0),
            S_(this, ZA, "f").setSteeringValue(g, 1);
            for (let e = 0; e < 4; e++) {
                const t = S_(this, ZA, "f").getWheelInfo(e);
                let n;
                n = t.m_raycastInfo.m_suspensionLength < -.2 ? 200 : 50,
                n != t.m_suspensionStiffness && t.set_m_suspensionStiffness(n)
            }
            if (o) {
                if (!S_(this, p_, "f") && !this.hasFinished() && S_(this, h_, "f") && null != S_(this, f_, "f")) {
                    const e = new Ammo.btTransform;
                    e.setIdentity(),
                    b_(this, a_, new Zt(S_(this, f_, "f").position.x,S_(this, f_, "f").position.y,S_(this, f_, "f").position.z), "f");
                    const t = new Ammo.btVector3(S_(this, a_, "f").x,S_(this, a_, "f").y,S_(this, a_, "f").z);
                    e.setOrigin(t),
                    Ammo.destroy(t),
                    b_(this, s_, new Kt(S_(this, f_, "f").quaternion.x,S_(this, f_, "f").quaternion.y,S_(this, f_, "f").quaternion.z,S_(this, f_, "f").quaternion.w), "f");
                    const n = new Ammo.btQuaternion(S_(this, s_, "f").x,S_(this, s_, "f").y,S_(this, s_, "f").z,S_(this, s_, "f").w);
                    e.setRotation(n),
                    Ammo.destroy(n),
                    S_(this, JA, "f").setWorldTransform(e),
                    S_(this, $A, "f").setWorldTransform(e),
                    Ammo.destroy(e);
                    const i = new Ammo.btVector3(0,0,0);
                    S_(this, JA, "f").setLinearVelocity(i),
                    S_(this, JA, "f").setAngularVelocity(i),
                    Ammo.destroy(i),
                    S_(this, ZA, "f").resetSuspension(),
                    S_(this, ZA, "f").getWheelInfo(0).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthFront),
                    S_(this, ZA, "f").getWheelInfo(1).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthFront),
                    S_(this, ZA, "f").getWheelInfo(2).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthRear),
                    S_(this, ZA, "f").getWheelInfo(3).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthRear),
                    S_(this, ZA, "f").setSteeringValue(0, 0),
                    S_(this, ZA, "f").setSteeringValue(0, 1);
                    const r = S_(this, ZA, "f").getNumWheels();
                    for (let e = 0; e < r; e++)
                        S_(this, ZA, "f").updateWheelTransform(e, !0);
                    b_(this, u_, S_(this, f_, "f").nextCheckpointIndex, "f")
                }
                b_(this, p_, !0, "f")
            } else
                b_(this, p_, !1, "f")
        }
        ;
        const E_ = class {
            constructor(e, t, n, i, r, a, s, o) {
                qA.add(this),
                YA.set(this, void 0),
                KA.set(this, void 0),
                ZA.set(this, void 0),
                JA.set(this, void 0),
                $A.set(this, void 0),
                e_.set(this, void 0),
                t_.set(this, void 0),
                n_.set(this, new Ammo.btTransform),
                i_.set(this, new Ammo.btVector3),
                r_.set(this, new Vs(new Zt,jA.detectorBoxSize.clone())),
                a_.set(this, void 0),
                s_.set(this, void 0),
                o_.set(this, void 0),
                l_.set(this, 0),
                c_.set(this, null),
                h_.set(this, !1),
                d_.set(this, new Xh),
                u_.set(this, 0),
                f_.set(this, null),
                p_.set(this, !1),
                m_.set(this, !1),
                g_.set(this, null),
                b_(this, o_, s, "f"),
                b_(this, t_, a, "f"),
                b_(this, KA, new Hh, "f"),
                S_(this, KA, "f").createGroundPlane(),
                S_(this, KA, "f").createMountains(e, t),
                b_(this, YA, new cd(S_(this, KA, "f"),n,i), "f");
                const l = new Ammo.btTransform;
                l.setIdentity();
                const c = new Ammo.btDefaultMotionState(l);
                Ammo.destroy(l);
                const h = new Ammo.btVector3(0,0,0);
                b_(this, e_, S_(this, qA, "m", A_).call(this, r), "f"),
                S_(this, e_, "f").calculateLocalInertia(400, h);
                const d = new Ammo.btRigidBodyConstructionInfo(400,c,S_(this, e_, "f"),h)
                  , u = new Ammo.btRigidBody(d);
                u.setFriction(1),
                u.setContactProcessingThreshold(0),
                Ammo.destroy(d),
                Ammo.destroy(h),
                u.setDamping(.1, .1),
                u.setActivationState(4),
                S_(this, KA, "f").world.addRigidBody(u, 1, 2),
                b_(this, JA, u, "f");
                const f = new Ammo.btVehicleTuning
                  , p = new Ammo.btDefaultVehicleRaycaster(S_(this, KA, "f").world)
                  , m = new Ammo.btRaycastVehicle(f,u,p);
                m.setCoordinateSystem(0, 1, 2),
                S_(this, KA, "f").world.addAction(m),
                b_(this, ZA, m, "f");
                const g = new Ammo.btVector3(0,-1,0)
                  , A = new Ammo.btVector3(-1,0,0);
                for (const e of ["WheelFL", "WheelFR", "WheelBL", "WheelBR"]) {
                    let t;
                    if ("WheelFL" == e)
                        t = new Ammo.btVector3(.627909,.27,1.3478);
                    else if ("WheelFR" == e)
                        t = new Ammo.btVector3(-.627909,.27,1.3478);
                    else if ("WheelBL" == e)
                        t = new Ammo.btVector3(.720832,.27,-1.52686);
                    else {
                        if ("WheelBR" != e)
                            throw new Error("Unidentified wheel");
                        t = new Ammo.btVector3(-.720832,.27,-1.52686)
                    }
                    const n = "WheelFL" == e || "WheelFR" == e
                      , i = m.addWheel(t, g, A, .12, .331, f, n);
                    Ammo.destroy(t),
                    i.set_m_maxSuspensionTravelCm(1e3),
                    i.set_m_maxSuspensionForce(1e6),
                    i.set_m_suspensionStiffness(50),
                    i.set_m_wheelsDampingRelaxation(1.35),
                    i.set_m_wheelsDampingCompression(200),
                    i.set_m_frictionSlip(3),
                    i.set_m_rollInfluence(.5)
                }
                Ammo.destroy(g),
                Ammo.destroy(A);
                const _ = new Ammo.btTransform;
                _.setIdentity(),
                b_(this, a_, new Zt(o.position.x,o.position.y,o.position.z), "f");
                const v = new Ammo.btVector3(S_(this, a_, "f").x,S_(this, a_, "f").y,S_(this, a_, "f").z);
                _.setOrigin(v),
                Ammo.destroy(v),
                b_(this, s_, new Kt(o.quaternion.x,o.quaternion.y,o.quaternion.z,o.quaternion.w), "f");
                const w = new Ammo.btQuaternion(S_(this, s_, "f").x,S_(this, s_, "f").y,S_(this, s_, "f").z,S_(this, s_, "f").w);
                _.setRotation(w),
                Ammo.destroy(w),
                b_(this, $A, S_(this, JA, "f").getMotionState(), "f"),
                S_(this, JA, "f").setWorldTransform(_),
                S_(this, $A, "f").setWorldTransform(_),
                Ammo.destroy(_),
                S_(this, ZA, "f").resetSuspension(),
                S_(this, ZA, "f").getWheelInfo(0).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthFront),
                S_(this, ZA, "f").getWheelInfo(1).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthFront),
                S_(this, ZA, "f").getWheelInfo(2).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthRear),
                S_(this, ZA, "f").getWheelInfo(3).m_raycastInfo.set_m_suspensionLength(jA.suspensionResetLengthRear),
                S_(this, ZA, "f").setSteeringValue(0, 0),
                S_(this, ZA, "f").setSteeringValue(0, 1);
                const y = S_(this, ZA, "f").getNumWheels();
                for (let e = 0; e < y; e++)
                    S_(this, ZA, "f").updateWheelTransform(e, !0)
            }
            dispose() {
                S_(this, KA, "f").world.removeRigidBody(S_(this, JA, "f")),
                Ammo.destroy(S_(this, $A, "f")),
                Ammo.destroy(S_(this, JA, "f")),
                Ammo.destroy(S_(this, n_, "f")),
                Ammo.destroy(S_(this, i_, "f")),
                Ammo.destroy(S_(this, e_, "f")),
                S_(this, KA, "f").world.removeAction(S_(this, ZA, "f")),
                Ammo.destroy(S_(this, ZA, "f")),
                S_(this, KA, "f").dispose()
            }
            get physics() {
                return S_(this, KA, "f")
            }
            get controls() {
                return S_(this, o_, "f")
            }
            getSpeedKmh() {
                return this.hasStarted() ? S_(this, ZA, "f").getCurrentSpeedKmHour() : 0
            }
            start() {
                b_(this, h_, !0, "f")
            }
            hasStarted() {
                return S_(this, h_, "f")
            }
            hasFinished() {
                return null != S_(this, c_, "f")
            }
            getFinishTime() {
                return S_(this, c_, "f")
            }
            getTime() {
                return S_(this, d_, "f").clone()
            }
            getNextCheckpointIndex() {
                return S_(this, u_, "f")
            }
            hasCheckpointToRespawnAt() {
                return null != S_(this, f_, "f")
            }
            isBrakeLightEnabled() {
                return S_(this, m_, "f")
            }
            getPosition() {
                return S_(this, a_, "f")
            }
            getQuaternion() {
                return S_(this, s_, "f")
            }
            getMatrix4() {
                return (new Cn).compose(this.getPosition(), this.getQuaternion(), new Zt(1,1,1))
            }
            getWheelPosition(e) {
                const t = S_(this, ZA, "f").getWheelTransformWS(e).getOrigin();
                return new Zt(t.x(),t.y(),t.z())
            }
            getWheelQuaternion(e) {
                const t = S_(this, ZA, "f").getWheelTransformWS(e).getRotation();
                return new Kt(t.x(),t.y(),t.z(),t.w())
            }
            getWheelInContact(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_raycastInfo.m_isInContact
            }
            getWheelSuspensionVelocity(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_suspensionRelativeVelocity
            }
            getWheelSuspensionLength(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_raycastInfo.m_suspensionLength
            }
            getWheelRotation(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_rotation
            }
            getWheelDeltaRotation(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_deltaRotation
            }
            getWheelSkidInfo(e) {
                return S_(this, ZA, "f").getWheelInfo(e).m_skidInfo
            }
            getWheelContactPosition(e) {
                const t = S_(this, ZA, "f").getWheelInfo(e).m_raycastInfo.m_contactPointWS;
                return new Zt(t.x(),t.y(),t.z())
            }
            getWheelContactNormal(e) {
                const t = S_(this, ZA, "f").getWheelInfo(e).m_raycastInfo.m_contactNormalWS;
                return new Zt(t.x(),t.y(),t.z())
            }
            getCollisionImpulses() {
                const e = []
                  , t = S_(this, KA, "f").dispatcher.getNumManifolds();
                for (let n = 0; n < t; ++n) {
                    const t = S_(this, KA, "f").dispatcher.getManifoldByIndexInternal(n)
                      , i = t.getBody0()
                      , r = t.getBody1();
                    if (i.H == S_(this, JA, "f").H || r.H == S_(this, JA, "f").H) {
                        const n = t.getNumContacts();
                        for (let i = 0; i < n; ++i) {
                            const n = t.getContactPoint(i);
                            e.push(n.getAppliedImpulse())
                        }
                    }
                }
                return e
            }
            step() {
                var e;
                if (this.hasStarted() && S_(this, d_, "f").numberOfFrames < Sh.maxFrames) {
                    const t = 1 / Hh.stepsPerSecond
                      , n = S_(this, a_, "f")
                      , i = S_(this, s_, "f");
                    (null == S_(this, g_, "f") || S_(this, g_, "f").manhattanDistanceTo(n) > 1.5) && (null == S_(this, g_, "f") ? b_(this, g_, n.clone(), "f") : S_(this, g_, "f").copy(n),
                    S_(this, KA, "f").activePhysicsAt(n)),
                    S_(this, qA, "m", y_).call(this),
                    S_(this, qA, "m", x_).call(this, t, S_(this, o_, "f")),
                    S_(this, KA, "f").step();
                    const r = S_(this, n_, "f");
                    S_(this, $A, "f").getWorldTransform(r);
                    const a = r.getOrigin()
                      , s = r.getRotation();
                    if (n.set(a.x(), a.y(), a.z()),
                    i.set(s.x(), s.y(), s.z(), s.w()),
                    !this.hasFinished()) {
                        const t = S_(this, r_, "f");
                        t.center.copy(jA.detectorBoxCenter).applyQuaternion(i).add(n),
                        t.rotation.elements = [1 - 2 * (i.y * i.y + i.z * i.z), 2 * (i.x * i.y + i.z * i.w), 2 * (i.x * i.z - i.y * i.w), 2 * (i.x * i.y - i.z * i.w), 1 - 2 * (i.x * i.x + i.z * i.z), 2 * (i.y * i.z + i.x * i.w), 2 * (i.x * i.z + i.y * i.w), 2 * (i.y * i.z - i.x * i.w), 1 - 2 * (i.x * i.x + i.y * i.y)];
                        const r = S_(this, YA, "f").getTotalNumberOfCheckpointIndices();
                        if (S_(this, u_, "f") == r)
                            null != S_(this, YA, "f").checkFinish(t) && b_(this, c_, S_(this, d_, "f").clone(), "f");
                        else {
                            const n = S_(this, YA, "f").checkCheckpoint(t, S_(this, u_, "f"));
                            if (null != n && (b_(this, u_, (e = S_(this, u_, "f"),
                            ++e), "f"),
                            n.rotationAxis == fd.YPositive)) {
                                const e = S_(this, qA, "m", w_).call(this);
                                let t = n.rotation * Math.PI / 2;
                                (0 == n.rotation && e.z < 0 || 1 == n.rotation && e.x < 0 || 2 == n.rotation && e.z > 0 || 3 == n.rotation && e.x > 0) && (t += Math.PI);
                                const i = (new Kt).setFromEuler(new Fn(0,t,0))
                                  , r = new Zt(0,.35,-1.35);
                                r.applyQuaternion(i),
                                n.type != dd.CheckpointWide && n.type != dd.PlaneCheckpointWide || r.sub(new Zt(-10,0,0).applyEuler(new Fn(0,n.rotation * Math.PI / 2,0))),
                                b_(this, f_, {
                                    position: new Zt(n.x * cd.partSize + r.x,n.y * cd.partSize + r.y,n.z * cd.partSize + r.z),
                                    quaternion: i,
                                    nextCheckpointIndex: S_(this, u_, "f")
                                }, "f")
                            }
                        }
                    }
                }
            }
        }
        ;
        var M_ = function(e, t, n, i) {
            return new (n || (n = Promise))((function(r, a) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function o(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value,
                    t instanceof n ? t : new n((function(e) {
                        e(t)
                    }
                    ))).then(s, o)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        };
        const T_ = 2.718281828459045
          , C_ = 2.302585092994046
          , I_ = .6931471805599453
          , R_ = 1.4426950408889634
          , P_ = .4342944819032518
          , B_ = 3.141592653589793
          , D_ = .7071067811865476
          , L_ = 1.4142135623730951;
        function U_(e) {
            throw new Error(e + ": Waiting for WASM to compile")
        }
        function N_(e) {
            throw new Error(e + ": No deterministic implementation")
        }
        function k_(e) {
            if (!Number.isFinite(e))
                return NaN;
            const t = (e = function(e) {
                return (e %= 2 * Math.PI) < 0 && (e += 2 * Math.PI),
                e
            }(e)) / (2 * Math.PI) * O_.length
              , n = Math.floor(t)
              , i = (n + 1) % O_.length
              , r = t - n;
            return O_[n] * (1 - r) + O_[i] * r
        }
        function F_(e) {
            return Math.sin(e + Math.PI / 2)
        }
        Math = {
            E: T_,
            LN10: C_,
            LN2: I_,
            LOG2E: R_,
            LOG10E: P_,
            PI: B_,
            SQRT1_2: D_,
            SQRT2: L_,
            abs: Math.abs,
            acos: () => U_("acos"),
            asin: () => U_("asin"),
            atan: () => U_("atan"),
            atan2: () => U_("atan2"),
            ceil: Math.ceil,
            cos: F_,
            exp: () => U_("exp"),
            floor: Math.floor,
            log: () => U_("log"),
            max: Math.max,
            min: Math.min,
            pow: () => U_("pow"),
            random: Math.random,
            round: Math.round,
            sin: k_,
            sqrt: () => U_("sqrt"),
            tan: () => U_("tan"),
            clz32: () => N_("clz32"),
            imul: () => N_("imul"),
            sign: Math.sign,
            log10: () => U_("log10"),
            log2: () => U_("log2"),
            log1p: () => N_("log1p"),
            expm1: () => N_("expm1"),
            cosh: () => N_("cosh"),
            sinh: () => N_("sinh"),
            tanh: () => N_("tanh"),
            acosh: () => N_("acosh"),
            asinh: () => N_("asinh"),
            atanh: () => N_("atanh"),
            hypot: () => N_("hypot"),
            trunc: Math.trunc,
            cbrt: () => N_("cbrt"),
            fround: Math.fround,
            [Symbol.toStringTag]: "Math"
        };
        const O_ = [0, .01745240643728351, .03489949670250097, .05233595624294383, .0697564737441253, .08715574274765817, .10452846326765346, .12186934340514748, .13917310096006544, .15643446504023087, .17364817766693033, .1908089953765448, .20791169081775931, .22495105434386498, .24192189559966773, .25881904510252074, .27563735581699916, .2923717047227367, .3090169943749474, .3255681544571567, .3420201433256687, .35836794954530027, .374606593415912, .3907311284892737, .40673664307580015, .42261826174069944, .4383711467890774, .45399049973954675, .4694715627858908, .48480962024633706, .49999999999999994, .5150380749100542, .5299192642332049, .544639035015027, .5591929034707468, .573576436351046, .5877852522924731, .6018150231520483, .6156614753256583, .6293203910498375, .6427876096865393, .6560590289905073, .6691306063588582, .6819983600624985, .6946583704589973, .7071067811865475, .7193398003386511, .7313537016191705, .7431448254773942, .7547095802227719, .766044443118978, .7771459614569708, .7880107536067219, .7986355100472928, .8090169943749475, .8191520442889918, .8290375725550417, .8386705679454239, .848048096156426, .8571673007021122, .8660254037844386, .8746197071393957, .8829475928589269, .8910065241883678, .898794046299167, .9063077870366499, .9135454576426009, .9205048534524404, .9271838545667873, .9335804264972017, .9396926207859083, .9455185755993167, .9510565162951535, .9563047559630354, .9612616959383189, .9659258262890683, .9702957262759965, .9743700647852352, .9781476007338057, .981627183447664, .984807753012208, .9876883405951378, .9902680687415704, .992546151641322, .9945218953682733, .9961946980917455, .9975640502598242, .9986295347545738, .9993908270190958, .9998476951563913, 1, .9998476951563913, .9993908270190958, .9986295347545738, .9975640502598242, .9961946980917455, .9945218953682734, .9925461516413221, .9902680687415704, .9876883405951377, .984807753012208, .981627183447664, .9781476007338057, .9743700647852352, .9702957262759965, .9659258262890683, .9612616959383189, .9563047559630355, .9510565162951536, .9455185755993168, .9396926207859084, .9335804264972017, .9271838545667874, .9205048534524404, .913545457642601, .90630778703665, .8987940462991669, .8910065241883679, .8829475928589271, .8746197071393959, .8660254037844387, .8571673007021123, .8480480961564261, .8386705679454239, .8290375725550417, .819152044288992, .8090169943749475, .7986355100472927, .788010753606722, .777145961456971, .766044443118978, .7547095802227721, .7431448254773945, .7313537016191706, .7193398003386511, .7071067811865476, .6946583704589975, .6819983600624986, .669130606358858, .6560590289905073, .6427876096865395, .6293203910498374, .6156614753256584, .6018150231520486, .5877852522924732, .5735764363510459, .5591929034707469, .5446390350150273, .5299192642332049, .5150380749100544, .49999999999999994, .48480962024633717, .4694715627858907, .45399049973954686, .4383711467890777, .4226182617406995, .40673664307580004, .39073112848927377, .37460659341591224, .35836794954530066, .3420201433256689, .3255681544571566, .3090169943749475, .29237170472273705, .2756373558169992, .258819045102521, .24192189559966773, .2249510543438652, .20791169081775931, .19080899537654497, .1736481776669307, .15643446504023098, .13917310096006533, .12186934340514755, .10452846326765373, .0871557427476582, .06975647374412552, .05233595624294425, .03489949670250114, .01745240643728344, 12246467991473532e-32, -.017452406437283192, -.0348994967025009, -.052335956242943564, -.06975647374412483, -.08715574274765794, -.1045284632676535, -.12186934340514774, -.13917310096006552, -.15643446504023073, -.17364817766693047, -.19080899537654472, -.20791169081775907, -.22495105434386498, -.2419218955996675, -.25881904510252035, -.2756373558169986, -.29237170472273677, -.30901699437494773, -.32556815445715676, -.34202014332566866, -.35836794954530043, -.374606593415912, -.39073112848927355, -.4067366430757998, -.4226182617406993, -.43837114678907707, -.45399049973954625, -.4694715627858905, -.48480962024633734, -.5000000000000001, -.5150380749100542, -.5299192642332048, -.5446390350150271, -.5591929034707467, -.5735764363510458, -.587785252292473, -.601815023152048, -.6156614753256578, -.6293203910498372, -.6427876096865393, -.6560590289905074, -.6691306063588582, -.6819983600624984, -.6946583704589974, -.7071067811865475, -.7193398003386509, -.7313537016191705, -.743144825477394, -.7547095802227717, -.7660444431189779, -.7771459614569711, -.7880107536067221, -.7986355100472928, -.8090169943749473, -.8191520442889916, -.8290375725550414, -.838670567945424, -.848048096156426, -.8571673007021121, -.8660254037844384, -.8746197071393955, -.882947592858927, -.8910065241883678, -.8987940462991668, -.90630778703665, -.913545457642601, -.9205048534524403, -.9271838545667873, -.9335804264972016, -.9396926207859082, -.9455185755993168, -.9510565162951535, -.9563047559630353, -.961261695938319, -.9659258262890683, -.9702957262759965, -.9743700647852351, -.9781476007338056, -.981627183447664, -.984807753012208, -.9876883405951377, -.9902680687415703, -.992546151641322, -.9945218953682733, -.9961946980917455, -.9975640502598242, -.9986295347545739, -.9993908270190958, -.9998476951563913, -1, -.9998476951563913, -.9993908270190958, -.9986295347545739, -.9975640502598243, -.9961946980917455, -.9945218953682733, -.992546151641322, -.9902680687415704, -.9876883405951378, -.9848077530122081, -.9816271834476641, -.9781476007338056, -.9743700647852352, -.9702957262759966, -.9659258262890684, -.961261695938319, -.9563047559630354, -.9510565162951536, -.945518575599317, -.9396926207859083, -.9335804264972017, -.9271838545667874, -.9205048534524405, -.9135454576426011, -.9063077870366503, -.898794046299167, -.8910065241883679, -.8829475928589271, -.8746197071393956, -.8660254037844386, -.8571673007021123, -.8480480961564262, -.8386705679454243, -.8290375725550416, -.8191520442889918, -.8090169943749476, -.798635510047293, -.7880107536067223, -.7771459614569713, -.7660444431189781, -.7547095802227722, -.743144825477394, -.7313537016191703, -.7193398003386512, -.7071067811865477, -.6946583704589976, -.6819983600624989, -.6691306063588588, -.6560590289905074, -.6427876096865396, -.6293203910498372, -.6156614753256582, -.6018150231520483, -.5877852522924734, -.5735764363510465, -.5591929034707473, -.544639035015027, -.529919264233205, -.5150380749100545, -.5000000000000004, -.48480962024633767, -.4694715627858908, -.45399049973954697, -.4383711467890778, -.4226182617406992, -.40673664307580015, -.3907311284892739, -.37460659341591235, -.35836794954530077, -.34202014332566943, -.3255681544571567, -.3090169943749477, -.29237170472273716, -.27563735581699894, -.2588190451025207, -.24192189559966787, -.22495105434386534, -.20791169081775987, -.19080899537654467, -.1736481776669304, -.15643446504023112, -.13917310096006588, -.12186934340514811, -.1045284632676543, -.08715574274765832, -.06975647374412564, -.05233595624294348, -.034899496702500823, -.01745240643728356];
        var z_, H_, W_, V_ = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        H_ = new WeakMap,
        z_ = new WeakSet,
        W_ = function(e) {
            if (e.length % 9 != 0)
                throw new Error("Physics shape vertices length is not dividable by 9");
            const t = new en
              , n = new Ammo.btTriangleMesh;
            for (let i = 0; i < e.length; i += 9) {
                const r = e[i + 0]
                  , a = e[i + 1]
                  , s = e[i + 2]
                  , o = e[i + 3]
                  , l = e[i + 4]
                  , c = e[i + 5]
                  , h = e[i + 6]
                  , d = e[i + 7]
                  , u = e[i + 8]
                  , f = new Ammo.btVector3(r,a,s)
                  , p = new Ammo.btVector3(o,l,c)
                  , m = new Ammo.btVector3(h,d,u);
                n.addTriangle(f, p, m),
                Ammo.destroy(f),
                Ammo.destroy(p),
                Ammo.destroy(m),
                t.expandByPoint(new Zt(r,a,s)),
                t.expandByPoint(new Zt(o,l,c)),
                t.expandByPoint(new Zt(h,d,u))
            }
            const i = new Ammo.btBvhTriangleMeshShape(n);
            return i.setMargin(.01),
            {
                boundingBox: t,
                shape: i,
                triangleMesh: n
            }
        }
        ;
        const G_ = class {
            constructor(e) {
                z_.add(this),
                H_.set(this, new Map);
                for (const {id: t, vertices: n, detector: i, startOffset: r} of e) {
                    const {boundingBox: e, shape: a, triangleMesh: s} = V_(this, z_, "m", W_).call(this, n);
                    V_(this, H_, "f").set(t, {
                        boundingBox: e,
                        shape: a,
                        triangleMesh: s,
                        detector: null != i ? {
                            type: i.type,
                            center: new Zt(i.center[0],i.center[1],i.center[2]),
                            size: new Zt(i.size[0],i.size[1],i.size[2])
                        } : null,
                        startOffset: null != r ? new Zt(r[0],r[1],r[2]) : null
                    })
                }
            }
            dispose() {
                for (const {shape: e, triangleMesh: t} of V_(this, H_, "f").values())
                    Ammo.destroy(e),
                    Ammo.destroy(t);
                V_(this, H_, "f").clear()
            }
            getPhysicsShape(e) {
                const t = V_(this, H_, "f").get(e);
                if (null == t)
                    throw new Error('Track part with the id "' + e.toString() + '" has no physics model');
                return {
                    boundingBox: t.boundingBox.clone(),
                    shape: t.shape
                }
            }
            getPartTypesWithDetector(e) {
                const t = [];
                for (const [n,i] of V_(this, H_, "f").entries())
                    null != i.detector && i.detector.type == e && t.push(n);
                return t
            }
            getStartPartTypes() {
                const e = [];
                for (const [t,n] of V_(this, H_, "f").entries())
                    null != n.startOffset && e.push(t);
                return e
            }
            getPartStartOffset(e) {
                var t, n;
                const i = V_(this, H_, "f").get(e);
                if (null == i)
                    throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                return null !== (n = null === (t = i.startOffset) || void 0 === t ? void 0 : t.clone()) && void 0 !== n ? n : null
            }
            getDetector(e) {
                const t = V_(this, H_, "f").get(e);
                if (null == t)
                    throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                return t.detector
            }
        }
        ;
        var Q_;
        !function(e) {
            e[e.Init = 0] = "Init",
            e[e.Verify = 1] = "Verify",
            e[e.TestDeterminism = 2] = "TestDeterminism",
            e[e.CreateCar = 3] = "CreateCar",
            e[e.DeleteCar = 4] = "DeleteCar",
            e[e.StartCar = 5] = "StartCar",
            e[e.ControlCar = 6] = "ControlCar",
            e[e.PauseCar = 7] = "PauseCar",
            e[e.VerifyResult = 8] = "VerifyResult",
            e[e.DeterminismResult = 9] = "DeterminismResult",
            e[e.UpdateResult = 10] = "UpdateResult"
        }(Q_ || (Q_ = {}));
        const X_ = Q_;
        var j_, q_ = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Y_ = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        j_ = new WeakMap;
        const K_ = class {
            constructor(e) {
                j_.set(this, void 0),
                q_(this, j_, e, "f")
            }
            dispose() {}
            getControls(e) {
                return Y_(this, j_, "f").getFrame(e)
            }
        }
        ;
        var Z_ = n(1312);
        const J_ = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
          , $_ = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
        function ev(e) {
            let t = 0
              , n = "";
            for (; t < 8 * e.length; ) {
                const i = nv(e, t);
                let r;
                30 & ~i ? (r = i,
                t += 6) : (r = 31 & i,
                t += 5),
                n += J_[r]
            }
            return n
        }
        function tv(e) {
            let t = 0;
            const n = []
              , i = e.length;
            for (let r = 0; r < i; r++) {
                const a = e.charCodeAt(r);
                if (a >= $_.length)
                    return null;
                const s = $_[a];
                if (-1 == s)
                    return null;
                30 & ~s ? (iv(n, t, 6, s, r == i - 1),
                t += 6) : (iv(n, t, 5, s, r == i - 1),
                t += 5)
            }
            return new Uint8Array(n)
        }
        function nv(e, t) {
            if (t >= 8 * e.length)
                throw new Error("Out of range");
            const n = Math.floor(t / 8)
              , i = e[n]
              , r = t - 8 * n;
            if (r <= 2 || n >= e.length - 1)
                return (i & 63 << r) >>> r;
            return (i & 63 << r) >>> r | (e[n + 1] & 63 >>> 8 - r) << 8 - r
        }
        function iv(e, t, n, i, r) {
            const a = Math.floor(t / 8);
            for (; a >= e.length; )
                e.push(0);
            const s = t - 8 * a;
            if (e[a] |= i << s & 255,
            s > 8 - n && !r) {
                const t = a + 1;
                t >= e.length && e.push(0),
                e[t] |= i >> 8 - s
            }
        }
        var rv, av = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, sv = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class ov {
            constructor(e=28) {
                if (rv.set(this, void 0),
                !(Number.isSafeInteger(e) && e >= 0 && e < 180))
                    throw new Error("Representation is not a safe integer or is out of range");
                av(this, rv, e, "f")
            }
            clone() {
                return new ov(sv(this, rv, "f"))
            }
            toDegrees() {
                return 2 * sv(this, rv, "f")
            }
            static fromDegrees(e) {
                const t = Math.round(e / 2 % 180);
                return new ov(t)
            }
            getSunPosition() {
                const e = 2 * sv(this, rv, "f") * (Math.PI / 180)
                  , t = Math.cos(e)
                  , n = Math.sin(e);
                return new Zt(t,.78,n).normalize()
            }
            get representation() {
                return sv(this, rv, "f")
            }
        }
        rv = new WeakMap;
        const lv = ov;
        var cv;
        !function(e) {
            e[e.Summer = 0] = "Summer",
            e[e.Winter = 1] = "Winter",
            e[e.Desert = 2] = "Desert"
        }(cv || (cv = {}));
        const hv = cv;
        var dv;
        !function(e) {
            e[e.Default = 0] = "Default",
            e[e.Summer = 1] = "Summer",
            e[e.Winter = 2] = "Winter",
            e[e.Desert = 3] = "Desert",
            e[e.Custom0 = 32] = "Custom0",
            e[e.Custom1 = 33] = "Custom1",
            e[e.Custom2 = 34] = "Custom2",
            e[e.Custom3 = 35] = "Custom3",
            e[e.Custom4 = 36] = "Custom4",
            e[e.Custom5 = 37] = "Custom5",
            e[e.Custom6 = 38] = "Custom6",
            e[e.Custom7 = 39] = "Custom7",
            e[e.Custom8 = 40] = "Custom8"
        }(dv || (dv = {}));
        const uv = dv;
        var fv;
        !function(e) {
            e[e.Special = 0] = "Special",
            e[e.Road = 1] = "Road",
            e[e.RoadTurns = 2] = "RoadTurns",
            e[e.RoadWide = 3] = "RoadWide",
            e[e.Plane = 4] = "Plane",
            e[e.Block = 5] = "Block",
            e[e.WallTrack = 6] = "WallTrack",
            e[e.Pillar = 7] = "Pillar",
            e[e.Sign = 8] = "Sign"
        }(fv || (fv = {}));
        const pv = fv;
        var mv, gv = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Av = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class _v {
            constructor(e) {
                mv.set(this, void 0);
                const t = [];
                for (const [n,i,r] of e)
                    t.push([n, i, r]);
                gv(this, mv, t, "f")
            }
            rotated(e, t) {
                const n = t == fd.YNegative || t == fd.XNegative || t == fd.ZNegative;
                return new _v(Av(this, mv, "f").map(( ([i,r,a]) => {
                    if (n)
                        switch (e) {
                        case 0:
                            break;
                        case 1:
                            [i,a] = [-a - 1, i];
                            break;
                        case 2:
                            [i,a] = [-i - 1, -a - 1];
                            break;
                        case 3:
                            [i,a] = [a, -i - 1];
                            break;
                        default:
                            throw new Error("Invalid rotation")
                        }
                    else
                        switch (e) {
                        case 0:
                            break;
                        case 1:
                            [i,a] = [a, -i - 1];
                            break;
                        case 2:
                            [i,a] = [-i - 1, -a - 1];
                            break;
                        case 3:
                            [i,a] = [-a - 1, i];
                            break;
                        default:
                            throw new Error("Invalid rotation")
                        }
                    return t == fd.YPositive || (t == fd.YNegative ? [i,r] = [-i - 1, -r - 1] : t == fd.XPositive ? [i,r] = [r, -i - 1] : t == fd.XNegative ? [i,r] = [-r - 1, i] : t == fd.ZPositive ? [r,a] = [-a - 1, r] : [r,a] = [a, -r - 1]),
                    [i, r, a]
                }
                )))
            }
            forEach(e) {
                for (let t = 0; t < Av(this, mv, "f").length; t++) {
                    const [n,i,r] = Av(this, mv, "f")[t];
                    e(n, i, r, t)
                }
            }
            get length() {
                return Av(this, mv, "f").length
            }
        }
        mv = new WeakMap;
        const vv = _v
          , wv = [{
            id: uv.Summer,
            colors: {}
        }, {
            id: uv.Winter,
            colors: {
                Road: "#5077b2",
                RoadBarrier: "#898989",
                RoadEdgeWhite: "#ffffff",
                RoadEdgeRed: "#1f3d6b",
                BlockSurface: "#878787",
                Pillar: "#2b4d7f",
                PillarEdge: "#071428",
                WallTrack: "#5077b2",
                WallTrackBottom: "#878787",
                WallTrackSides: "#ffffff",
                PlaneWall: "#1f3d6b",
                PlaneWallDetail: "#878787",
                SignYellow: "#1b2a89",
                SignRed: "#841901",
                SignBlack: "#5077b2"
            }
        }, {
            id: uv.Desert,
            colors: {
                Road: "#997240",
                RoadBarrier: "#211001",
                RoadEdgeRed: "#5b2424",
                RoadEdgeWhite: "#510808",
                BlockSurface: "#b78f5b",
                Pillar: "#99713d",
                PillarEdge: "#1c1105",
                WallTrack: "#260b0b",
                WallTrackBottom: "#160606",
                WallTrackSides: "#75562e",
                PlaneWall: "#633030",
                PlaneWallDetail: "#aa8a53",
                SignYellow: "#997240",
                SignRed: "#d80202",
                SignBlack: "#601d1d"
            }
        }]
          , yv = wv.concat([{
            id: uv.Custom0,
            colors: {
                BlockSurface: "#131313"
            }
        }, {
            id: uv.Custom1,
            colors: {
                BlockSurface: "#501b1b"
            }
        }, {
            id: uv.Custom2,
            colors: {
                BlockSurface: "#7f4d2b"
            }
        }, {
            id: uv.Custom3,
            colors: {
                BlockSurface: "#93862d"
            }
        }, {
            id: uv.Custom4,
            colors: {
                BlockSurface: "#2a5e30"
            }
        }, {
            id: uv.Custom5,
            colors: {
                BlockSurface: "#236363"
            }
        }, {
            id: uv.Custom6,
            colors: {
                BlockSurface: "#20244b"
            }
        }, {
            id: uv.Custom7,
            colors: {
                BlockSurface: "#592759"
            }
        }, {
            id: uv.Custom8,
            colors: {
                BlockSurface: "#302318"
            }
        }]);
        class xv {
            constructor(e, t, n, i, r, a, s=null, o=null) {
                const l = [];
                for (const [e,t] of a)
                    for (let n = e[0]; n <= t[0]; n++)
                        for (let i = e[1]; i <= t[1]; i++)
                            for (let r = e[2]; r <= t[2]; r++) {
                                if (null != l.find(( ([e,t,a]) => e == n && t == i && a == r)))
                                    throw new Error("Duplicate tile in track part");
                                l.push([n, i, r])
                            }
                this.checksum = e,
                this.category = t,
                this.id = n,
                this.models = i,
                this.colors = r,
                this.tiles = new vv(l),
                this.detector = s,
                this.startOffset = o,
                Object.freeze(this)
            }
        }
        const bv = [new xv("6d94d798abd14dc3bce4e99c180309d993ad43adb5f2c90eef8e350eedafe7cf",pv.Special,dd.Start,[["Road", "Start"]],wv,[[[-2, 0, -2], [1, 0, 1]]],null,new Zt(0,.35,1.35)), new xv("f29e34b2e05e0a4751109ae564b03fe8878a79cc6b26288f1117ed296d09c5bb",pv.Special,dd.StartWide,[["RoadWide", "StartWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],null,new Zt(-10,.35,1.35)), new xv("3c304054f415fbede4f73a43517db04302f38b16fa2cd4e587082b37b75e20e5",pv.Special,dd.PlaneStart,[["Planes", "PlaneStart"]],wv,[[[-2, 0, -2], [1, 0, 1]]],null,new Zt(0,.35,1.35)), new xv("f08710416bdaa3d91d0d43f014e45d421fdb4587a334993bad0056f3dbbcb6bb",pv.Special,dd.PlaneStartWide,[["Planes", "PlaneStartWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],null,new Zt(-10,.35,1.35)), new xv("223fc87c72bb64b58677062ffa08ab7eafd78071bced7c53233606763cd5316b",pv.Special,dd.Checkpoint,[["Road", "Checkpoint"]],wv,[[[-2, 0, -2], [1, 0, 1]]],{
            type: qh.Checkpoint,
            center: [0, 2.2, 0],
            size: [10.5, 3.8, 1]
        }), new xv("82d9a9879cee92c04c8d4ba2e16fc31bb1917a31f5802a3bb5177ca9a5cfee01",pv.Special,dd.CheckpointWide,[["RoadWide", "CheckpointWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],{
            type: qh.Checkpoint,
            center: [10, 2.2, 0],
            size: [30.6, 3.8, 1]
        }), new xv("fe8946d7f09724b5e11f493eb5c2a5b5e3d502b15beaad003f8134ac63558948",pv.Special,dd.PlaneCheckpoint,[["Planes", "PlaneCheckpoint"]],wv,[[[-2, 0, -2], [1, 0, 1]]],{
            type: qh.Checkpoint,
            center: [0, 2.2, 0],
            size: [18.25, 3.8, 1]
        }), new xv("d486d9b851db35dd44c15f9e0bb3bf582118daf7be514598a19307f61cf46678",pv.Special,dd.PlaneCheckpointWide,[["Planes", "PlaneCheckpointWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],{
            type: qh.Checkpoint,
            center: [10, 2.2, 0],
            size: [38.25, 3.8, 1]
        }), new xv("c01200d573a3594a6a4cb73ebb600964d653e4a89267d3297f3969220742aa79",pv.Special,dd.Finish,[["Road", "Finish"]],wv,[[[-2, 0, -2], [1, 0, 1]]],{
            type: qh.Finish,
            center: [0, 2.2, 0],
            size: [10.5, 3.8, 2]
        }), new xv("a9cefdff816e94a643210c58582c2809de0e3e0e0478b8d5baabd7fe81f13e73",pv.Special,dd.FinishWide,[["RoadWide", "FinishWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],{
            type: qh.Finish,
            center: [10, 2.2, 0],
            size: [30.6, 3.8, 2]
        }), new xv("75e5f09fe8a18ecafaf1fb80929173ef0a7dc0b785596bbe0ccd85a934d79578",pv.Special,dd.PlaneFinish,[["Planes", "PlaneFinish"]],wv,[[[-2, 0, -2], [1, 0, 1]]],{
            type: qh.Finish,
            center: [0, 2.2, 0],
            size: [18.25, 3.8, 2]
        }), new xv("5801b3268c75809728c63450d06000c5f6fcfd5d72691902f99d7d19d25e1d78",pv.Special,dd.PlaneFinishWide,[["Planes", "PlaneFinishWide"]],wv,[[[-2, 0, -2], [5, 0, 1]]],{
            type: qh.Finish,
            center: [10, 2.2, 0],
            size: [38.25, 3.8, 2]
        }), new xv("3421096c1986d008da88b5fac64cd4c475603138c9bf8a98ab6d581dda6befa7",pv.Road,dd.Straight,[["Road", "Straight"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("bdc3bcdafec9bc26835dc76159f7223da7da5babb3a5770129fa11046c748b69",pv.Road,dd.StraightPillarBottom,[["Road", "Straight"], ["Pillar", "SurfacePillarBottom"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("2758e984d87b3170f6618c9c689554ef169fd5f80ea7f0df292ffd69792d414e",pv.Road,dd.StraightPillarShort,[["Road", "Straight"], ["Pillar", "SurfacePillarShort"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("fb5a81784022cfc2d3d0007a032976c8dfd066e72a3bc92f671c98c5cca36aaa",pv.Road,dd.TurnSharp,[["Road", "TurnSharp"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("3da2e9a93da06b1376c33486f30a5f02d8c2f125f5b7d8b41166049ecd95f269",pv.Road,dd.TurnSharpPillarBottom,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarBottom"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("c642122276547382e37dcb857b130088f4dc0d208dc7fdb6055b2a93080a3ffe",pv.Road,dd.TurnSharpPillarShort,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarShort"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("110efb0facc096e1c875e545b075b0effaa1b78d50b97f906aec44796501544b",pv.RoadTurns,dd.TurnShort,[["Road", "TurnShort"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-1, 0, -2], [3, 0, -2]], [[-1, 0, -3], [5, 0, -3]], [[0, 0, -4], [5, 0, -4]], [[1, 0, -5], [5, 0, -5]], [[3, 0, -6], [5, 0, -6]]]), new xv("20a164840b0e83f3eac96ba9e3650a30e3b3dec4bb635946e3e9e9a1b74820d2",pv.RoadTurns,dd.TurnLong,[["Road", "TurnLong"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [2, 0, -2]], [[-1, 0, -3], [2, 0, -3]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -6], [6, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new xv("c36dddde35a740c6f01227522bf35e1a450cddbfdd8bde1617873bef0d47c95c",pv.RoadTurns,dd.TurnLong2,[["Road", "TurnLong2"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [3, 0, -5]], [[0, 0, -6], [4, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [6, 0, -8]], [[2, 0, -9], [7, 0, -9]], [[3, 0, -10], [9, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new xv("0ed20c04a941708c23fe6ced4af3f357c0e435f09278e06f3de2806786d44059",pv.RoadTurns,dd.TurnLong3,[["Road", "TurnLong3"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [2, 0, -5]], [[0, 0, -6], [3, 0, -6]], [[0, 0, -7], [3, 0, -7]], [[0, 0, -8], [4, 0, -8]], [[1, 0, -9], [5, 0, -9]], [[2, 0, -10], [6, 0, -10]], [[2, 0, -11], [7, 0, -11]], [[3, 0, -12], [8, 0, -12]], [[4, 0, -13], [10, 0, -13]], [[5, 0, -14], [13, 0, -14]], [[7, 0, -15], [17, 0, -15]], [[8, 0, -16], [17, 0, -16]], [[11, 0, -17], [17, 0, -17]], [[14, 0, -18], [17, 0, -18]]]), new xv("034ef287319877f2fcc32fbd6f32415539a4c287dfcd620360386a781adad22a",pv.RoadTurns,dd.TurnSLeft,[["Road", "TurnS", {
            flipX: !0
        }]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-3, 0, -3], [0, 0, -2]], [[-4, 0, -4], [0, 0, -4]], [[-5, 0, -5], [-1, 0, -5]], [[-5, 0, -7], [-2, 0, -6]], [[-6, 0, -10], [-3, 0, -8]]]), new xv("0d49e9feb603d0899927c7e5184f4f4fdd4363d2e1fd296f0b7b3cf4dbbf0e8d",pv.RoadTurns,dd.TurnSRight,[["Road", "TurnS"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -3], [2, 0, -2]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -7], [4, 0, -6]], [[2, 0, -10], [5, 0, -8]]]), new xv("26bca19e63867bc0b755ff6fcca65de296c9d1f109f87540103565eb88a0e03d",pv.RoadTurns,dd.TurnShortLeftWide,[["RoadWide", "TurnShortLeftWide"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-1, 0, -4], [5, 0, -3]], [[0, 0, -5], [5, 0, -5]], [[1, 0, -6], [5, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new xv("e3845854f85dafd8cec193bcbecdac6cb79f625066de29524d5c10c5580611c5",pv.RoadTurns,dd.TurnShortRightWide,[["RoadWide", "TurnShortRightWide"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-2, 0, -2], [3, 0, -2]], [[2, 0, -6], [5, 0, -3]]]), new xv("dc6088960a65a55c74353a1e7c8a1ca8ec99e683f6273bf666d6909b288bb84b",pv.RoadTurns,dd.TurnLongLeftWide,[["RoadWide", "TurnLongLeftWide"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -5], [1, 0, -3]], [[0, 0, -6], [1, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [5, 0, -8]], [[2, 0, -9], [5, 0, -9]], [[3, 0, -10], [5, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new xv("0bbb8d6c1e4a325e10643cf45546da725c1ea18e92a3a95f753339629a06ef6c",pv.RoadTurns,dd.TurnLongRightWide,[["RoadWide", "TurnLongRightWide"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 0, -3], [2, 0, -2]], [[-2, 0, -4], [3, 0, -4]], [[-2, 0, -5], [4, 0, -5]], [[-2, 0, -6], [6, 0, -6]], [[2, 0, -10], [9, 0, -7]]]), new xv("7d8d1eed719515ba7e48b5ef4a53b6b4bb2bef42496b6b40d2551230435ecb66",pv.Road,dd.SlopeUp,[["Road", "SlopeUp"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new xv("d6d54dbf283f7209032541fc6b924dc879d914f253e391cf8b34dde8354661be",pv.Road,dd.SlopeUpLong,[["Road", "SlopeUpLong"]],wv,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new xv("435e8cf33d28e52f75890cba1cb6529991148afd701f9b40e9ab876c11b2c448",pv.Road,dd.SlopeDown,[["Road", "SlopeDown"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new xv("01990158f65e5d499030d8c6d0ce80d34c136189ae1a9430d4260ea7a85e91a9",pv.Road,dd.SlopeDownLong,[["Road", "SlopeDownLong"]],wv,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new xv("4afecc8b9bd7a3b074112008831fef6b11f9a55ab8c1e570e3e73c1e92b43c6d",pv.Road,dd.Slope,[["Road", "Slope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new xv("27f9b25126b1006514941bd148c8f19dc2d82022b0c1aa2358f36cb711d4b59c",pv.Road,dd.SlopePillar,[["Road", "Slope"], ["Pillar", "PillarTopSlope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new xv("eb236f0ac4bd895c170db53cb518c8df5167a9db5af4bb4f33f73c02deec5265",pv.Road,dd.SlopePillarShort,[["Road", "Slope"], ["Pillar", "PillarShortSlope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new xv("99cb9068cb3f97e7cbfdbb3f1edc1085ea37514f3d5dd8936bc32089cc066a5c",pv.Road,dd.SlopeUpVertical,[["Road", "SlopeUpVertical"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new xv("63628b23e104a3eb3c2ba8189cd408a10fbb6ebcd6fa4359d981e3c3804c13d8",pv.Road,dd.IntersectionT,[["Road", "IntersectionT"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("400dc4643653001d283bb13f740593fc2300c547bb4d2a962054ba6aabf3721c",pv.Road,dd.IntersectionTPillarBottom,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarBottom"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("60355388650d35fcbddaaac29e0d03bc2ae46db1a05cd23ddd3f2722ec2d409e",pv.Road,dd.IntersectionTPillarShort,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarShort"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("74197b3731c2befd03498bf5172859f0b3652f1972c19e43a99bb938769573df",pv.Road,dd.IntersectionCross,[["Road", "IntersectionCross"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("464e69b5c4f2667c246ade9ed33fd3e50b49438ed0ab787a086dfe74c217ff6c",pv.Road,dd.IntersectionCrossPillarBottom,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarBottom"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("90004caf354627289265314966f11b5656e6879ca7de10507e6c50cd95254b75",pv.Road,dd.IntersectionCrossPillarShort,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarShort"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("2af8aa6050028dd6ee69b7150e83a6d8819e1848a7b1c782848d3f6448c5091a",pv.RoadWide,dd.ToWideMiddle,[["RoadWide", "ToWideMiddle"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("26341cfe6bec34f46b10ffcd9a7706a8156b9ac41ed2cdfd166f9f8d3e9bc8f3",pv.RoadWide,dd.ToWideLeft,[["RoadWide", "ToWideSide", {
            flipX: !0
        }]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("3f82ebd6c72110b532a20673f8b54c7b25ae5988a51d3793bf383fea8ffcffc3",pv.RoadWide,dd.ToWideRight,[["RoadWide", "ToWideSide"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("f5cecce9870f41f8cba7a9fbe631c315370a7a82824d04977ec857dbb1dfed29",pv.RoadWide,dd.ToWideDouble,[["RoadWide", "ToWideDouble"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("99dc726611397f81b47459d32c7bfb8232322d1ca976ba9a3e71cc15451d8cfb",pv.RoadWide,dd.ToWideDiagonal,[["RoadWide", "ToWideDiagonal"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("47d7e3fb334681911e122babef127881a36a763fb22176854114495802d5ce84",pv.RoadWide,dd.StraightWide,[["RoadWide", "StraightWide"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("521adc95ed5a4809eeff7eec872c3d6449e4d6a7e4941d672f1e06a50a6615de",pv.RoadWide,dd.InnerCornerWide,[["RoadWide", "InnerCornerWide"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("d82274b362794e3c1772510002d5015dde345f1e72dd675c8bac41cf2331398b",pv.RoadWide,dd.OuterCornerWide,[["RoadWide", "OuterCornerWide"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("9b1df4dd4687404adb5789f3b90af39ea6fa65ef741a07b116dc436dc14a2aa1",pv.RoadWide,dd.SlopeUpLeftWide,[["RoadWide", "SlopeUpWide", {
            flipX: !0
        }]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new xv("651d4e988913b84359ad10e0c4745965b6a388eaa8c9bfbba4b6a50ae6d4f592",pv.RoadWide,dd.SlopeUpRightWide,[["RoadWide", "SlopeUpWide"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new xv("848d9930c58e66152090d7853af87c8bb7971e1771d3c337ac1a50aaa4975a78",pv.RoadWide,dd.SlopeUpLongLeftWide,[["RoadWide", "SlopeUpLongWide", {
            flipX: !0
        }]],wv,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new xv("e4d54c6c3b6011a1acfb6766b6b3e7ea0de6f9c6569a5ec88c47968ad4105b2a",pv.RoadWide,dd.SlopeUpLongRightWide,[["RoadWide", "SlopeUpLongWide"]],wv,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new xv("106ad1d4c5aded30cc3ef4cd1bdc40babab84464ce7dbce3b81cc20d55fd615f",pv.RoadWide,dd.SlopeDownLeftWide,[["RoadWide", "SlopeDownWide", {
            flipX: !0
        }]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new xv("23a693633b8453c7a531de9723e6ca14d0676b1d7a4df7f78278914467b90a27",pv.RoadWide,dd.SlopeDownRightWide,[["RoadWide", "SlopeDownWide"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new xv("0f2e33a8b68667e30e80ceaefdb890a77643799d63c7f20672ca3185bbc04270",pv.RoadWide,dd.SlopeDownLongLeftWide,[["RoadWide", "SlopeDownLongWide", {
            flipX: !0
        }]],wv,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new xv("164903518c7efa4890a792017ea2b8125a2c3dae76bba4c6f1f56fb0f7e40ebc",pv.RoadWide,dd.SlopeDownLongRightWide,[["RoadWide", "SlopeDownLongWide"]],wv,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new xv("c20560fd35288c5cc74af61834b9a56efaeacdde55eb793d400b7c5b97904993",pv.RoadWide,dd.SlopeLeftWide,[["RoadWide", "SlopeWide", {
            flipX: !0
        }]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new xv("b6a26eb3cefee53d4deef24544e5b5c1ecd25e8e8bd7c3070c7947ada55c57c2",pv.RoadWide,dd.SlopeRightWide,[["RoadWide", "SlopeWide"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new xv("b598ff14bda99600434b24a619132fec4bffcc535483b9b57b0c8c09c1be1f1b",pv.RoadWide,dd.SlopeUpVerticalLeftWide,[["RoadWide", "SlopeUpVerticalWide"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new xv("4e0275d3a01eaca6ec5118b8b816ed292cb7172710cf9b7801068424ab684b22",pv.RoadWide,dd.SlopeUpVerticalRightWide,[["RoadWide", "SlopeUpVerticalWide", {
            flipX: !0
        }]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new xv("896b47675cc2ff58494979168f6fd36c27c43da29aed6a52fdf80f054630166a",pv.Plane,dd.Plane,[["Planes", "Plane"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("dc9afb98a8bb998d3b76c3563385e58c1749e56ff43fbc7577b1f57ba8360702",pv.Plane,dd.PlanePillarBottom,[["Planes", "Plane"], ["Pillar", "SurfacePillarBottom"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("f59ad95edd26814236ab30b73f6f4f68003885ef150201a4ace14b832abcf438",pv.Plane,dd.PlanePillarShort,[["Planes", "Plane"], ["Pillar", "SurfacePillarShort"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("48247a66b232461083fa2aa36644e7e8779f5b426d474efd375ee7d21d009c9a",pv.Plane,dd.HalfPlane,[["Planes", "HalfPlane"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new xv("eac8530d1a025291674bf34b206f75700dc8626012d8d33ed398f7aed746dac8",pv.Plane,dd.QuarterPlane,[["Planes", "QuarterPlane"]],wv,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new xv("1da4dcad366aa90a5977e1b20c5d79297106ed3b4f664be04b6b3f6370c105b4",pv.Plane,dd.PlaneSlopeUp,[["Planes", "PlaneSlopeUp"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new xv("3e203219ec0ea114da510b37a4c392b90417af796e2b089da6d996e628c0a323",pv.Plane,dd.PlaneSlopeUpLong,[["Planes", "PlaneSlopeUpLong"]],wv,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new xv("053dbf6c03eea5102b67168ccb479d8364233b36c4210aff093928bbb83d859d",pv.Plane,dd.PlaneSlopeDown,[["Planes", "PlaneSlopeDown"]],wv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new xv("d68121a3cb0ee19cab45adb136e0df6145f43ca9ecbde8a417c02a6d4a75a757",pv.Plane,dd.PlaneSlopeDownLong,[["Planes", "PlaneSlopeDownLong"]],wv,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new xv("67ec222e8fe770a8d728bb76ff571377c261d2f232134d4cb328c9ab772cf3ca",pv.Plane,dd.PlaneSlope,[["Planes", "PlaneSlope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new xv("a52c09d87d37088b68420db07626f274c74f792cb223764624d887a5ed145a2e",pv.Plane,dd.PlaneSlopePillar,[["Planes", "PlaneSlope"], ["Pillar", "PillarTopSlope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new xv("57df805433e706ec946d767d7ff0881f163c2e36bb1db00b0e3259954a787dec",pv.Plane,dd.PlaneSlopePillarShort,[["Planes", "PlaneSlope"], ["Pillar", "PillarShortSlope"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new xv("ba0d6ec33647740bf4c60e542d1758095afa3ef451bdaec76c783dd32116e4cb",pv.Plane,dd.PlaneSlopeVerticalBottom,[["Planes", "PlaneSlopeVertical"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new xv("78a372de15f3151f901cf7fa7a3983ee6513cf19fa8568f10946e195c5a62515",pv.Plane,dd.PlaneSlopeToVertical,[["Planes", "PlaneSlopeToVertical"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new xv("5f6d1ece085d450643f1399af53673dcc6bbbf413094d8dd5ee6816d80e1c8ae",pv.Plane,dd.PlaneBridge,[["Planes", "PlaneBridge"]],wv,[[[-1, 0, -2], [0, 0, 1]]]), new xv("32b91fc4cdf95f5b7a490d81058522bae14741601dd44c73cc110121aa1dd6e6",pv.Plane,dd.PlaneBridgeCorner,[["Planes", "PlaneBridgeCorner"]],wv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new xv("2db870b1821fb655437bd0527569d5a6843718fa0775682701437432265a1a88",pv.Plane,dd.PlaneBridgeIntersectionT,[["Planes", "PlaneBridgeIntersectionT"]],wv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("33aa0e7524b74dcdae4aed89856c09d25248c4cab8f70dcc31b347f0a00fcb52",pv.Plane,dd.PlaneBridgeIntersectionCross,[["Planes", "PlaneBridgeIntersectionCross"]],wv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new xv("bd7cc4ab180fc0a6936fef828ae3a91566b3dd621b888fbcc57c9ac11dcb713b",pv.Plane,dd.PlaneWall,[["Planes", "PlaneWall"]],wv,[[[-2, 0, 1], [1, 0, 1]]]), new xv("d92568164028bb2e65799abd9dc6ba66cfe8a28515c09fbe5ac175f5966af66a",pv.Plane,dd.PlaneWallCorner,[["Planes", "PlaneWallCorner"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[1, 0, -2], [1, 0, 0]]]), new xv("792ab5a6f0e2bf8e556575ef12731ec30755855d4394f98eb4ca7ec8b713933c",pv.Plane,dd.PlaneWallInnerCorner,[["Planes", "PlaneWallInnerCorner"]],wv,[[[1, 0, 1], [1, 0, 1]]]), new xv("de0d588c4b2fe6b32d72a7e0e2984285955f805ccb86d3c269f7155401cd6b20",pv.Block,dd.Block,[["Blocks", "Block"]],yv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("1ce6b585c0e99d71877fefe015ff16336ae62eb0caebeca62dd09d836092d7b6",pv.Block,dd.HalfBlock,[["Blocks", "HalfBlock"]],yv,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new xv("0d5f0609c3c98f687d55d3a73313225c1642f6285ddaca3ed536db742c85958d",pv.Block,dd.QuarterBlock,[["Blocks", "QuarterBlock"]],yv,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new xv("18fc1c569c6fc04f95f10174143d19e7a9ea4e387302363f4ae60883c1acd3f0",pv.Block,dd.BlockSlopedDown,[["Blocks", "BlockSlopedDown"]],yv,[[[-2, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new xv("22dd5b2804c88994a4d283cb822f47de3c72f82376e4c9332d39feae85206c0f",pv.Block,dd.BlockSlopedDownInnerCorner,[["Blocks", "BlockSlopedDownInnerCorner"]],yv,[[[-2, 0, -2], [-1, 0, 1]], [[0, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new xv("81a71b4cc6ef8520f20fd738457abc31b04258c97f9862f70190fd2a0ba91382",pv.Block,dd.BlockSlopedDownOuterCorner,[["Blocks", "BlockSlopedDownOuterCorner"]],yv,[[[-2, 0, -2], [-1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new xv("f4e19d3bc49994a85fecd187b76c21d258e7f30f0506d90bc6f173336e11627d",pv.Block,dd.BlockSlopedUp,[["Blocks", "BlockSlopedUp"]],yv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]]]), new xv("fd9309468e97131bbbd1404fac34a7137cb176327789b955c1aea30267e1cded",pv.Block,dd.BlockSlopedUpInnerCorner,[["Blocks", "BlockSlopedUpInnerCorner"]],yv,[[[-2, 1, -2], [-1, 1, 1]], [[0, 1, -2], [1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new xv("1321fb07ece1b80b99dc4671b52673ac028fbf43322e9e652ad633ff6afac21b",pv.Block,dd.BlockSlopedUpOuterCorner,[["Blocks", "BlockSlopedUpOuterCorner"]],yv,[[[-2, 1, -2], [-1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new xv("b97c17388fc38139f2f5a98a36d94831095f79db709dd97748ad2904bc54d689",pv.Block,dd.BlockSlopeDown,[["Blocks", "BlockSlopeDown"]],yv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("50276826bbfb9fcb11a8519b8dae8a2b1cf82817d5431418d9a376664261be82",pv.Block,dd.BlockSlopeUp,[["Blocks", "BlockSlopeUp"]],yv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("63fd3032796397f8e25669c1c1d3fc97b8ec0e5fc88bfcb5c00a2a2c2b517888",pv.Block,dd.BlockSlopeDownLong,[["Blocks", "BlockSlopeDownLong"]],yv,[[[-2, 0, -2], [1, 0, 5]], [[-2, 1, 0], [1, 1, 5]]]), new xv("2d29131222a8d891b4350e6a2f335b114e001cf22e4e2f170dc9b86c4b2fd325",pv.Block,dd.BlockSlopeUpLong,[["Blocks", "BlockSlopeUpLong"]],yv,[[[-2, 0, -6], [1, 0, 1]], [[-2, 1, -6], [1, 1, -4]]]), new xv("0bbcd96c91b69e6e8005bfae5b64455b0d6510cb1595f3fca7f77c86ddda4560",pv.Block,dd.BlockSlopeVerticalTop,[["Blocks", "BlockSlopeVertical", {
            flipY: !0
        }]],yv,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [1, 2, -1]], [[-2, 0, -2], [1, 1, -2]]]), new xv("e81a123c0be3f8f168fb584d53e8aa038785569bbf2cd1c1cead2272889591e0",pv.Block,dd.BlockSlopeVerticalBottom,[["Blocks", "BlockSlopeVertical"]],yv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new xv("94e14468f31af7f39b9d7ba188a364089ae81da2bd6a9db2b8f5b1b8cedce741",pv.Block,dd.BlockSlopeToVertical,[["Blocks", "BlockSlopeToVertical"]],yv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new xv("3a2f05b1c2c2fd976997fa473f1adb3ba14495701dc5a998f8697798384c6946",pv.Block,dd.BlockSlopeVerticalCornerTop,[["Blocks", "BlockSlopeVerticalCornerBottom", {
            flipY: !0
        }]],yv,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [0, 2, 0]], [[1, 2, -2], [1, 2, -1]], [[-2, 2, 1], [-1, 2, 1]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 1, 0], [-1, 1, 0]], [[0, 1, -2], [0, 1, -1]], [[1, 1, -2], [1, 1, -2]], [[-2, 1, 1], [-2, 1, 1]], [[-2, 0, -2], [-1, 0, -1]], [[-2, 0, 0], [-2, 0, 1]], [[0, 0, -2], [1, 0, -2]]]), new xv("3e4fa43e69aa1dbee584e16451a95a16229bba8d638df2bf6f6c9ffb3a9629c9",pv.Block,dd.BlockInnerCorner,[["Blocks", "BlockInnerCorner"]],yv,[[[-2, 0, 0], [-2, 0, 1]], [[-2, 0, -2], [-1, 0, -1]], [[0, 0, -2], [1, 0, -2]]]), new xv("cc9c95eef56def4cf013e4ac85b8013a2b4f4b4346f1f5dd41fa017de763ef17",pv.Block,dd.BlockSlopeVerticalCornerBottom,[["Blocks", "BlockSlopeVerticalCornerBottom"]],yv,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [0, 1, 0]], [[1, 1, -2], [1, 1, -1]], [[-2, 1, 1], [-1, 1, 1]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 2, 0], [-1, 2, 0]], [[0, 2, -2], [0, 2, -1]], [[1, 2, -2], [1, 2, -2]], [[-2, 2, 1], [-2, 2, 1]], [[-2, 3, -2], [-1, 3, -1]], [[-2, 3, 0], [-2, 3, 1]], [[0, 3, -2], [1, 3, -2]]]), new xv("e4c82c8e512d52269cb6588fa34b06c179340ea40e71f74cbadadc7e8353f5a2",pv.Block,dd.BlockSlopeVerticalInnerCornerTop,[["Blocks", "BlockSlopeVerticalInnerCorner", {
            flipY: !0
        }]],yv,[[[-2, 3, -2], [0, 3, 1]], [[1, 3, -2], [1, 3, 0]], [[-2, 2, -2], [-2, 2, -1]], [[-1, 2, -2], [-1, 2, -2]], [[-2, 0, -2], [-2, 1, -2]]]), new xv("926fdc6e82ecd709cc535faea6bb8778c6e2e91edb39eb6ae6308076dca2ed18",pv.Block,dd.BlockSlopeVerticalInnerCornerBottom,[["Blocks", "BlockSlopeVerticalInnerCorner"]],yv,[[[-2, 0, -2], [0, 0, 1]], [[1, 0, -2], [1, 0, 0]], [[-2, 1, -2], [-2, 1, -1]], [[-1, 1, -2], [-1, 1, -2]], [[-2, 2, -2], [-2, 3, -2]]]), new xv("1086515ba3c1d8e5ec76b378f0bdbc77fc5a57fc8eba8972f0d5e611be945235",pv.Block,dd.BlockBridge,[["Blocks", "BlockBridge"]],yv,[[[-1, 0, -2], [0, 0, 1]]]), new xv("5426ad4ff64af3f1a0f0794ad30cfc20434dfffdf44d93010f5f98671c246ff3",pv.Block,dd.BlockBridgeCorner,[["Blocks", "BlockBridgeCorner"]],yv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new xv("784b9b4459e838e5b8f74f6250769ffa52ec5cc3608abc24c380a2e792c3d338",pv.Block,dd.BlockBridgeIntersectionT,[["Blocks", "BlockBridgeIntersectionT"]],yv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("dfbcbc107a3c12217bfa3b224a5757d08e995705d1c122bb2c2665bbb8447b1c",pv.Block,dd.BlockBridgeIntersectionCross,[["Blocks", "BlockBridgeIntersectionCross"]],yv,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new xv("5fe53442e559418b7cc9483315b0ac45b8797f9630d5ecc4c7604dab4be25584",pv.WallTrack,dd.WallTrackTop,[["WallTrack", "WallTrackBottom", {
            flipY: !0
        }]],wv,[[[-2, 3, -1], [1, 3, 1]], [[-2, 2, -1], [1, 2, -1]], [[-2, 0, -2], [1, 2, -2]]]), new xv("010d187fbfbd399bfe880bbea1b548678c239eba0be2913e5cb8a69fbd17adf7",pv.WallTrack,dd.WallTrackMiddle,[["WallTrack", "WallTrackMiddle"]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("33216a4dcb734511a80c5bf70ca6f66de555800426686eae5a2519d4c837090e",pv.WallTrack,dd.WallTrackBottom,[["WallTrack", "WallTrackBottom"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new xv("1e306d2a6347b68d6e275bf4ccc9c8942e0a633bf625a3bba95fa9f98ecd50ff",pv.WallTrack,dd.WallTrackSlopeToVertical,[["WallTrack", "WallTrackSlopeToVertical"]],wv,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new xv("3ed21ddbc756a6644e05f5e1ca78ff8df6d51affc472c2d86e7f23d85911e273",pv.WallTrack,dd.WallTrackTopCorner,[["WallTrack", "WallTrackBottomCorner", {
            flipY: !0
        }]],wv,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -1], [-2, 1, 1]], [[-1, 1, -1], [-1, 1, 0]], [[0, 1, -1], [0, 1, -1]], [[-1, 1, -2], [1, 1, -2]], [[-2, 2, 0], [-2, 2, 1]], [[-1, 2, 1], [-1, 2, 1]], [[-1, 2, -1], [0, 2, 0]], [[1, 2, -1], [1, 2, -1]], [[0, 2, -2], [1, 2, -2]], [[0, 3, -1], [1, 3, 1]], [[-1, 3, 0], [-1, 3, 1]]]), new xv("4027a2439cc3e42ceda50ff3d427a31e127b25a6457b55edc2d498b474a296a7",pv.WallTrack,dd.WallTrackMiddleCorner,[["WallTrack", "WallTrackMiddleCorner"]],wv,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]]]), new xv("498286e062056a537a482ed3385fe0ac0343b399f29d470641df8f74c0532672",pv.WallTrack,dd.WallTrackBottomCorner,[["WallTrack", "WallTrackBottomCorner"]],wv,[[[-2, 3, -1], [-2, 3, 1]], [[-1, 3, -1], [-1, 3, -1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -1], [-2, 2, 1]], [[-1, 2, -1], [-1, 2, 0]], [[0, 2, -1], [0, 2, -1]], [[-1, 2, -2], [1, 2, -2]], [[-2, 1, 0], [-2, 1, 1]], [[-1, 1, 1], [-1, 1, 1]], [[-1, 1, -1], [0, 1, 0]], [[1, 1, -1], [1, 1, -1]], [[0, 1, -2], [1, 1, -2]], [[0, 0, -1], [1, 0, 1]], [[-1, 0, 0], [-1, 0, 1]]]), new xv("ac09cd62c83af376f23d37dd88273614a2a11cc04a04bff6075fd749bb1ff421",pv.WallTrack,dd.WallTrackTopInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner", {
            flipY: !0
        }]],wv,[[[-2, 3, -1], [1, 3, 1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 0, -2], [-2, 1, -2]]]), new xv("16c9c8ece47c097f60cfc7f8a2daa2f0e7ad0befb0ebfd185402013fd1ec8e0f",pv.WallTrack,dd.WallTrackInnerCorner,[["WallTrack", "WallTrackInnerCorner"]],wv,[[[-2, 0, -2], [-2, 0, -2]]]), new xv("404e7506c2f7e9302acac39c31a659e7e09e7852786e5f0244f9827727a0bf1e",pv.WallTrack,dd.WallTrackBottomInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner"]],wv,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 2, -2], [-2, 3, -2]]]), new xv("8b7023471502607ef19109760bee3b954ea3b3883c32f3960f75c6651c912ffd",pv.WallTrack,dd.WallTrackFloor,[["WallTrack", "WallTrackFloor"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("59e7f31827236c71db8b16f3f1f259c4c82c87a37e4d57a5a097c0d527d128f3",pv.WallTrack,dd.WallTrackFloorCorner,[["WallTrack", "WallTrackFloorCorner"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new xv("d58e3805b550b70940c845a807086865b21a4c36da74ffddedcfe5ce2d08e093",pv.WallTrack,dd.WallTrackFloorPlaneCorner,[["WallTrack", "WallTrackFloorPlaneCorner"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new xv("a56b0c1cf964b213a38167cbbac6f33acd403978ad75746eb51bcfd8c6a36148",pv.WallTrack,dd.WallTrackCeiling,[["WallTrack", "WallTrackCeiling"]],wv,[[[-2, 0, -2], [1, 0, 1]]]), new xv("f87b592d02120312e8e93d8a27c02dcda1095ac2f09879c6efafb2ca2b49d127",pv.WallTrack,dd.WallTrackCeilingCorner,[["WallTrack", "WallTrackCeilingCorner"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new xv("cfce1fe50f8cd26393eadd475783830e02f0b39bad4c0e00f7aa69614b22decc",pv.WallTrack,dd.WallTrackCeilingPlaneCorner,[["WallTrack", "WallTrackCeilingPlaneCorner"]],wv,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new xv("19656d02145f1a4ba07dbf2f236f865d34c86f823741b247b5d444a36d61c316",pv.Pillar,dd.PillarTop,[["Pillar", "PillarTop"]],wv,[[[-1, 0, -1], [0, 0, 0]]]), new xv("dde596d55ffc00f0f00d361667239d9f71c414f03304fecb6a7d11f6f5e702f1",pv.Pillar,dd.PillarMiddle,[["Pillar", "PillarMiddle"]],wv,[[[-1, 0, -1], [0, 0, 0]]]), new xv("dced5202d9373f9dd81a39530a87a1a7036c93ae71604a4e26c3a191abf3c197",pv.Pillar,dd.PillarBottom,[["Pillar", "PillarBottom"]],wv,[[[-1, 0, -1], [0, 0, 0]]]), new xv("af83eebf50c302880377e4f8c1fb3b2ef96ae193e8d03c17e1fd77c73a847e63",pv.Pillar,dd.PillarShort,[["Pillar", "PillarShort"]],wv,[[[-1, 0, -1], [0, 0, 0]]]), new xv("25b41116fb04b1f3cdd3119f57e0000a6ea8cb12d435718ffd6bb765866c272f",pv.Pillar,dd.PillarBranch1,[["Pillar", "PillarBranch1"]],wv,[[[-1, 0, -2], [0, 0, 0]]]), new xv("05ae39aea4f1ddd818fa57860e688c9cb875544f9b82eafe58a2eb9c19d8d91d",pv.Pillar,dd.PillarBranch1Top,[["Pillar", "PillarBranch1Top"]],wv,[[[-1, 0, -2], [0, 0, 0]]]), new xv("06c29d92e42e0c32050af98d69eecc94ce15adf8ac81dbe53dfb577a83265f4e",pv.Pillar,dd.PillarBranch1Middle,[["Pillar", "PillarBranch1Middle"]],wv,[[[-1, 0, -2], [0, 0, 0]]]), new xv("4a989027e0bd6db264f092bac729d9d450e012a710ea28d199f7ff52efd70fbd",pv.Pillar,dd.PillarBranch1Bottom,[["Pillar", "PillarBranch1Bottom"]],wv,[[[-1, 0, -2], [0, 0, 0]]]), new xv("78b2ff83ad71e7f3d692abc35923fa20c2ae14c01e37d44ec430746ca1bac992",pv.Pillar,dd.PillarBranch2,[["Pillar", "PillarBranch2"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new xv("b22c93bc73ec2da9dbff218da1676d7436527ed284e264f37294e48ef1307301",pv.Pillar,dd.PillarBranch2Top,[["Pillar", "PillarBranch2Top"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new xv("79a456a8fa3da24bec6c033f6c736fa1c728745f9624ae78ca20b6a4a76afae8",pv.Pillar,dd.PillarBranch2Middle,[["Pillar", "PillarBranch2Middle"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new xv("3b81b3f965cbc9fda4fe09e830ba25f1b96ce512d87b0146a1192a6cd0d07335",pv.Pillar,dd.PillarBranch2Bottom,[["Pillar", "PillarBranch2Bottom"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new xv("27727678bbcac9d3b0172b165ca5c92b10f4b4584a3a18fef4c542f3e791f26f",pv.Pillar,dd.PillarBranch3,[["Pillar", "PillarBranch3"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("50c7ac511d30ab9e065c928b776652f038be7683d948082bbefc419ee049e505",pv.Pillar,dd.PillarBranch3Top,[["Pillar", "PillarBranch3Top"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("98b3bfe99e7132825f5aa93122e4e5fdec46eb2877c8eb91fa2648f709527b60",pv.Pillar,dd.PillarBranch3Middle,[["Pillar", "PillarBranch3Middle"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("7326bbb558f8bcc28d5875c43b1b8e3646caadb873a14fde3ab517f779aea345",pv.Pillar,dd.PillarBranch3Bottom,[["Pillar", "PillarBranch3Bottom"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new xv("0e23c2615cfdb350bb3a700b6169589265a1d1079f61294fb497b8f80191d523",pv.Pillar,dd.PillarBranch4,[["Pillar", "PillarBranch4"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new xv("e62b55e111dbcb3faefed0a203eac5b55051a2b11911946660310e3df3588da3",pv.Pillar,dd.PillarBranch4Top,[["Pillar", "PillarBranch4Top"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new xv("4e2cfb89c1c591803a1440532a74c3ace37ec7fe78a526c1b57f6679c620df2e",pv.Pillar,dd.PillarBranch4Middle,[["Pillar", "PillarBranch4Middle"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new xv("e7807350788e4570c8bb74d4a635639ef731d83e52922fac5bc10f415f73f794",pv.Pillar,dd.PillarBranch4Bottom,[["Pillar", "PillarBranch4Bottom"]],wv,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new xv("836bfd12791bfebd99aba70531da4c9bd6e332d16c1e120a8888ea54f59456f9",pv.Pillar,dd.PillarBranch5,[["Pillar", "PillarBranch5"]],wv,[[[-2, 0, -1], [1, 0, 0]]]), new xv("ab85228116faf9ae7b1e6cb4a03530cbec808df3d3c1d7883eb41eb7cfe231d7",pv.Pillar,dd.PillarBranch5Top,[["Pillar", "PillarBranch5Top"]],wv,[[[-2, 0, -1], [1, 0, 0]]]), new xv("db93d5cea4e523fd67a56f8d928084ab6355331a8e5d1899115c1841866006bb",pv.Pillar,dd.PillarBranch5Middle,[["Pillar", "PillarBranch5Middle"]],wv,[[[-2, 0, -1], [1, 0, 0]]]), new xv("dd793efa234159e3a0ff28b064ecb715e6c8bb76e06acfe4bd0d9a2f2b9bba88",pv.Pillar,dd.PillarBranch5Bottom,[["Pillar", "PillarBranch5Bottom"]],wv,[[[-2, 0, -1], [1, 0, 0]]]), new xv("350f7d3591ffd0b2cfb8204d1c6cd0022fd3bda81ea7e950fce3abea7ec89e1a",pv.Sign,dd.SignArrowLeft,[["Signs", "SignArrowRight", {
            flipX: !0
        }]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("22e104e58bba0a609d379578e391ce50ca523c9eee1c3fddebb6d1bb2246a0b9",pv.Sign,dd.SignArrowRight,[["Signs", "SignArrowRight"]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("acba0cfe380e625285b973e09344e61740e77d6f8cac8691ef3e0a0b0878040e",pv.Sign,dd.SignArrowUp,[["Signs", "SignArrowUp"]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("8d0dbea0a26bdf3addd372f5d9a2fdecfd776a48f31218acdeb036129b248ca5",pv.Sign,dd.SignArrowDown,[["Signs", "SignArrowUp", {
            flipY: !0
        }]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("e5e1b1ca69d7b230331171be07876c4b1bdebba557c19b18ab17d91eee2771d5",pv.Sign,dd.SignWarning,[["Signs", "SignWarning"]],wv,[[[-2, 0, -2], [1, 0, -2]]]), new xv("64ed1fba4990a25bc774575ff8835117638d2c3e7c8f41bf0032d219e1083e4c",pv.Sign,dd.SignWrongWay,[["Signs", "SignWrongWay"]],wv,[[[-2, 0, -2], [1, 0, -2]]])]
          , Sv = new Map;
        for (const e of bv) {
            if (Sv.has(e.id))
                throw new Error("Duplicate track part id " + e.id.toString());
            Sv.set(e.id, e)
        }
        function Ev(e) {
            const t = Sv.get(e);
            if (null == t)
                throw new Error("Unknown track part id " + e.toString());
            return t
        }
        const Mv = bv.filter((e => {
            var t;
            return (null === (t = e.detector) || void 0 === t ? void 0 : t.type) == qh.Checkpoint
        }
        )).map((e => e.id))
          , Tv = bv.filter((e => null != e.startOffset)).map((e => e.id));
        function Cv(e) {
            const t = e.parts;
            if ("object" != typeof t && null !== t && !Array.isArray(t))
                return null;
            const n = new sw(hv.Summer,new lv)
              , i = Object.keys(t);
            for (const e of i) {
                const i = parseInt(e, 10);
                if (!(i in dd))
                    return null;
                {
                    const e = t[i];
                    if (!Array.isArray(e))
                        return null;
                    if (e.length % 4 != 0)
                        return null;
                    for (let t = 0; t < e.length; t += 4) {
                        const r = parseInt(e[t + 0], 10)
                          , a = parseInt(e[t + 1], 10)
                          , s = parseInt(e[t + 2], 10)
                          , o = parseInt(e[t + 3], 10);
                        if (isNaN(r) || isNaN(a) || isNaN(s) || isNaN(o))
                            return null;
                        if (!(o >= 0 && o <= 3 && Math.abs(r) <= 1e9 && a >= 0 && a <= 1e9 && Math.abs(s) <= 1e9))
                            return null;
                        {
                            if (Mv.includes(i))
                                return null;
                            let e = null;
                            Tv.includes(i) && (e = 0),
                            n.addPart(4 * r, a, 4 * s, i, o, fd.YPositive, uv.Default, null, e)
                        }
                    }
                }
            }
            return n
        }
        function Iv(e) {
            const t = ch(e);
            if (null == t)
                return null;
            const n = new sw(hv.Summer,new lv);
            let i = 0;
            for (; i < t.length; ) {
                if (t.length - i < 2)
                    return null;
                const e = t[i + 0] | t[i + 1] << 8;
                if (i += 2,
                !(e in dd))
                    return null;
                if (t.length - i < 4)
                    return null;
                const r = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16 | t[i + 3] << 24;
                i += 4;
                for (let a = 0; a < r; ++a) {
                    if (t.length - i < 3)
                        return null;
                    const r = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                    if (i += 3,
                    t.length - i < 3)
                        return null;
                    const a = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16;
                    if (i += 3,
                    t.length - i < 3)
                        return null;
                    const s = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                    if (i += 3,
                    t.length - i < 1)
                        return null;
                    const o = 3 & t[i + 0];
                    if (i += 1,
                    o < 0 || o > 3)
                        return null;
                    if (Mv.includes(e))
                        return null;
                    let l = null;
                    Tv.includes(e) && (l = 0),
                    n.addPart(4 * r, a, 4 * s, e, o, fd.YPositive, uv.Default, null, l)
                }
            }
            return n
        }
        function Rv(e) {
            const t = tv(e);
            if (null == t)
                return null;
            const n = new lh.Inflate;
            if (n.push(t, !0),
            n.err)
                return null;
            const i = n.result;
            if (!(i instanceof Uint8Array))
                return null;
            const r = new sw(hv.Summer,new lv);
            let a = 0;
            for (; a < i.length; ) {
                if (i.length - a < 2)
                    return null;
                const e = i[a + 0] | i[a + 1] << 8;
                if (a += 2,
                !(e in dd))
                    return null;
                if (i.length - a < 4)
                    return null;
                const t = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16 | i[a + 3] << 24;
                a += 4;
                for (let n = 0; n < t; ++n) {
                    if (i.length - a < 3)
                        return null;
                    const t = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    i.length - a < 3)
                        return null;
                    const n = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16;
                    if (a += 3,
                    i.length - a < 3)
                        return null;
                    const s = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    i.length - a < 1)
                        return null;
                    const o = i[a + 0];
                    if (a += 1,
                    o < 0 || o > 3)
                        return null;
                    let l = null;
                    if (Mv.includes(e)) {
                        if (i.length - a < 2)
                            return null;
                        l = i[a + 0] | i[a + 1] << 8,
                        a += 2
                    }
                    let c = null;
                    Tv.includes(e) && (c = 0),
                    r.addPart(4 * t, n, 4 * s, e, o, fd.YPositive, uv.Default, l, c)
                }
            }
            return r
        }
        function Pv(e) {
            const t = tv(e);
            if (null == t)
                return null;
            const n = new lh.Inflate;
            if (n.push(t, !0),
            n.err)
                return null;
            const i = n.result;
            if (!(i instanceof Uint8Array))
                return null;
            const r = new sw(hv.Summer,new lv);
            let a = 0;
            for (; a < i.length; ) {
                if (i.length - a < 2)
                    return null;
                let e = i[a + 0] | i[a + 1] << 8;
                a += 2;
                let t = uv.Default;
                if (e >= 134 && e <= 178)
                    switch (e) {
                    case 134:
                        e = dd.Block,
                        t = uv.Custom1;
                        break;
                    case 135:
                        e = dd.HalfBlock,
                        t = uv.Custom1;
                        break;
                    case 136:
                        e = dd.QuarterBlock,
                        t = uv.Custom1;
                        break;
                    case 137:
                        e = dd.BlockSlopedDown,
                        t = uv.Custom1;
                        break;
                    case 138:
                        e = dd.BlockSlopedDownInnerCorner,
                        t = uv.Custom1;
                        break;
                    case 139:
                        e = dd.BlockSlopedDownOuterCorner,
                        t = uv.Custom1;
                        break;
                    case 140:
                        e = dd.BlockSlopedUp,
                        t = uv.Custom1;
                        break;
                    case 141:
                        e = dd.BlockSlopedUpInnerCorner,
                        t = uv.Custom1;
                        break;
                    case 142:
                        e = dd.BlockSlopedUpOuterCorner,
                        t = uv.Custom1;
                        break;
                    case 143:
                        e = dd.BlockSlopeDown,
                        t = uv.Custom1;
                        break;
                    case 144:
                        e = dd.BlockSlopeUp,
                        t = uv.Custom1;
                        break;
                    case 145:
                        e = dd.BlockBridge,
                        t = uv.Custom1;
                        break;
                    case 146:
                        e = dd.BlockBridgeCorner,
                        t = uv.Custom1;
                        break;
                    case 147:
                        e = dd.BlockBridgeIntersectionT,
                        t = uv.Custom1;
                        break;
                    case 148:
                        e = dd.BlockBridgeIntersectionCross,
                        t = uv.Custom1;
                        break;
                    case 149:
                        e = dd.Block,
                        t = uv.Custom6;
                        break;
                    case 150:
                        e = dd.HalfBlock,
                        t = uv.Custom6;
                        break;
                    case 151:
                        e = dd.QuarterBlock,
                        t = uv.Custom6;
                        break;
                    case 152:
                        e = dd.BlockSlopedDown,
                        t = uv.Custom6;
                        break;
                    case 153:
                        e = dd.BlockSlopedDownInnerCorner,
                        t = uv.Custom6;
                        break;
                    case 154:
                        e = dd.BlockSlopedDownOuterCorner,
                        t = uv.Custom6;
                        break;
                    case 155:
                        e = dd.BlockSlopedUp,
                        t = uv.Custom6;
                        break;
                    case 156:
                        e = dd.BlockSlopedUpInnerCorner,
                        t = uv.Custom6;
                        break;
                    case 157:
                        e = dd.BlockSlopedUpOuterCorner,
                        t = uv.Custom6;
                        break;
                    case 158:
                        e = dd.BlockSlopeDown,
                        t = uv.Custom6;
                        break;
                    case 159:
                        e = dd.BlockSlopeUp,
                        t = uv.Custom6;
                        break;
                    case 160:
                        e = dd.BlockBridge,
                        t = uv.Custom6;
                        break;
                    case 161:
                        e = dd.BlockBridgeCorner,
                        t = uv.Custom6;
                        break;
                    case 162:
                        e = dd.BlockBridgeIntersectionT,
                        t = uv.Custom6;
                        break;
                    case 163:
                        e = dd.BlockBridgeIntersectionCross,
                        t = uv.Custom6;
                        break;
                    case 164:
                        e = dd.Block,
                        t = uv.Custom0;
                        break;
                    case 165:
                        e = dd.HalfBlock,
                        t = uv.Custom0;
                        break;
                    case 166:
                        e = dd.QuarterBlock,
                        t = uv.Custom0;
                        break;
                    case 167:
                        e = dd.BlockSlopedDown,
                        t = uv.Custom0;
                        break;
                    case 168:
                        e = dd.BlockSlopedDownInnerCorner,
                        t = uv.Custom0;
                        break;
                    case 169:
                        e = dd.BlockSlopedDownOuterCorner,
                        t = uv.Custom0;
                        break;
                    case 170:
                        e = dd.BlockSlopedUp,
                        t = uv.Custom0;
                        break;
                    case 171:
                        e = dd.BlockSlopedUpInnerCorner,
                        t = uv.Custom0;
                        break;
                    case 172:
                        e = dd.BlockSlopedUpOuterCorner,
                        t = uv.Custom0;
                        break;
                    case 173:
                        e = dd.BlockSlopeDown,
                        t = uv.Custom0;
                        break;
                    case 174:
                        e = dd.BlockSlopeUp,
                        t = uv.Custom0;
                        break;
                    case 175:
                        e = dd.BlockBridge,
                        t = uv.Custom0;
                        break;
                    case 176:
                        e = dd.BlockBridgeCorner,
                        t = uv.Custom0;
                        break;
                    case 177:
                        e = dd.BlockBridgeIntersectionT,
                        t = uv.Custom0;
                        break;
                    case 178:
                        e = dd.BlockBridgeIntersectionCross,
                        t = uv.Custom0
                    }
                let n = null
                  , s = {
                    x: 0,
                    y: 0,
                    z: 0
                };
                if (79 == e)
                    n = dd.WallTrackFloorPlaneCorner;
                else if (81 == e)
                    n = dd.WallTrackCeilingPlaneCorner,
                    s = {
                        x: 0,
                        y: 3,
                        z: 0
                    };
                else if (e >= 87 && e <= 98)
                    switch (e) {
                    case 87:
                        e = dd.Slope,
                        n = dd.BlockSlopedUp;
                        break;
                    case 88:
                        e = dd.SlopeUp,
                        n = dd.BlockSlopeUp;
                        break;
                    case 89:
                        e = dd.SlopeDown,
                        n = dd.BlockSlopeDown;
                        break;
                    case 90:
                        e = dd.SlopeUpLeftWide,
                        n = dd.BlockSlopeUp;
                        break;
                    case 91:
                        e = dd.SlopeUpRightWide,
                        n = dd.BlockSlopeUp;
                        break;
                    case 92:
                        e = dd.SlopeDownLeftWide,
                        n = dd.BlockSlopeDown;
                        break;
                    case 93:
                        e = dd.SlopeDownRightWide,
                        n = dd.BlockSlopeDown;
                        break;
                    case 94:
                        e = dd.SlopeLeftWide,
                        n = dd.BlockSlopedUp;
                        break;
                    case 95:
                        e = dd.SlopeRightWide,
                        n = dd.BlockSlopedUp;
                        break;
                    case 96:
                        e = dd.PlaneSlopeUp,
                        n = dd.BlockSlopeUp;
                        break;
                    case 97:
                        e = dd.PlaneSlopeDown,
                        n = dd.BlockSlopeDown;
                        break;
                    case 98:
                        e = dd.PlaneSlope,
                        n = dd.BlockSlopedUp;
                        break;
                    default:
                        throw new Error("Invalid track part id")
                    }
                if (!(e in dd))
                    return null;
                if (i.length - a < 4)
                    return null;
                const o = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16 | i[a + 3] << 24;
                a += 4;
                for (let l = 0; l < o; ++l) {
                    if (i.length - a < 3)
                        return null;
                    const o = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    i.length - a < 3)
                        return null;
                    const l = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16;
                    if (a += 3,
                    i.length - a < 3)
                        return null;
                    const c = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    i.length - a < 1)
                        return null;
                    const h = i[a + 0];
                    if (a += 1,
                    h < 0 || h > 3)
                        return null;
                    let d = null;
                    if (Mv.includes(e)) {
                        if (i.length - a < 2)
                            return null;
                        d = i[a + 0] | i[a + 1] << 8,
                        a += 2
                    }
                    let u = null;
                    Tv.includes(e) && (u = 0),
                    null != n && r.addPart(4 * o + s.x, l + s.y, 4 * c + s.z, n, h, fd.YPositive, uv.Default, null, u),
                    r.addPart(4 * o, l, 4 * c, e, h, fd.YPositive, t, d, u)
                }
            }
            return r
        }
        function Bv(e, t) {
            let n = e;
            if (t.length - n < 1)
                return null;
            const i = t[n];
            if (n += 1,
            !(i in hv))
                return null;
            if (t.length - n < 1)
                return null;
            const r = t[n];
            if (n += 1,
            !Number.isSafeInteger(r) || r < 0 || r >= 180)
                return null;
            const a = new sw(i,new lv(r));
            if (t.length - n < 9)
                return null;
            const s = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const o = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const l = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const c = 3 & t[n]
              , h = t[n] >> 2 & 3
              , d = t[n] >> 4 & 3;
            if (n += 1,
            c < 1 || c > 4 || h < 1 || h > 4 || d < 1 || d > 4)
                return null;
            for (; n < t.length; ) {
                if (t.length - n < 1)
                    return null;
                const e = t[n + 0];
                if (n += 1,
                !(e in dd))
                    return null;
                if (t.length - n < 4)
                    return null;
                const i = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                for (let r = 0; r < i; ++r) {
                    if (t.length - n < c)
                        return null;
                    let i = 0;
                    for (let e = 0; e < c; ++e)
                        i |= t[n + e] << 8 * e;
                    if (i += s,
                    n += c,
                    t.length - n < h)
                        return null;
                    let r = 0;
                    for (let e = 0; e < h; ++e)
                        r |= t[n + e] << 8 * e;
                    if (r += o,
                    n += h,
                    t.length - n < d)
                        return null;
                    let u = 0;
                    for (let e = 0; e < d; ++e)
                        u |= t[n + e] << 8 * e;
                    if (u += l,
                    n += d,
                    t.length - n < 1)
                        return null;
                    const f = t[n + 0];
                    if (n += 1,
                    f < 0 || f > 3)
                        return null;
                    if (t.length - n < 1)
                        return null;
                    const p = t[n + 0];
                    if (n += 1,
                    !(p in fd))
                        return null;
                    if (t.length - n < 1)
                        return null;
                    const m = t[n + 0];
                    if (n += 1,
                    !(m in uv))
                        return null;
                    let g = null;
                    if (Mv.includes(e)) {
                        if (t.length - n < 2)
                            return null;
                        g = t[n + 0] | t[n + 1] << 8,
                        n += 2
                    }
                    let A = null;
                    if (Tv.includes(e)) {
                        if (t.length - n < 4)
                            return null;
                        A = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24,
                        n += 4
                    }
                    a.addPart(i, r, u, e, f, p, m, g, A)
                }
            }
            return a
        }
        class Dv extends Qr {
            constructor(e, t) {
                const n = new Si({
                    color: t,
                    depthWrite: !1
                });
                super(e.geometry, n, e.count);
                for (let t = 0; t < e.count; ++t) {
                    const n = new Cn;
                    e.getMatrixAt(t, n),
                    this.setMatrixAt(t, n)
                }
                this.meshMatrix = e.matrixWorld,
                this.frustumCulled = !1,
                this.matrixAutoUpdate = !1,
                this.renderOrder = -1
            }
            update(e, t) {
                var n = new Cn
                  , i = e.normal.x * t.x + e.normal.y * t.y + e.normal.z * t.z + -e.constant * t.w
                  , r = n.elements;
                r[0] = i - t.x * e.normal.x,
                r[4] = -t.x * e.normal.y,
                r[8] = -t.x * e.normal.z,
                r[12] = -t.x * -e.constant,
                r[1] = -t.y * e.normal.x,
                r[5] = i - t.y * e.normal.y,
                r[9] = -t.y * e.normal.z,
                r[13] = -t.y * -e.constant,
                r[2] = -t.z * e.normal.x,
                r[6] = -t.z * e.normal.y,
                r[10] = i - t.z * e.normal.z,
                r[14] = -t.z * -e.constant,
                r[3] = -t.w * e.normal.x,
                r[7] = -t.w * e.normal.y,
                r[11] = -t.w * e.normal.z,
                r[15] = i - t.w * -e.constant,
                this.matrix.multiplyMatrices(n, this.meshMatrix)
            }
        }
        var Lv, Uv, Nv, kv, Fv, Ov, zv, Hv, Wv, Vv, Gv, Qv, Xv, jv, qv = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Yv = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Kv {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                if (this.checkpointOrder = null,
                this.startOrder = null,
                this.x = e,
                this.y = t,
                this.z = n,
                this.rotation = i,
                this.rotationAxis = r,
                this.color = a,
                this.type = s,
                this.matrix = o,
                this.checkpointOrder = l,
                this.startOrder = c,
                null != s.configuration.detector && s.configuration.detector.type == qh.Checkpoint) {
                    if (null == l)
                        throw new Error("Checkpoint has no checkpoint order")
                } else if (null != l)
                    throw new Error("Non-checkpoint has checkpoint order");
                if (null != s.configuration.startOffset && null == c)
                    throw new Error("Start part has no start order");
                if (null == s.configuration.startOffset && null != c)
                    throw new Error("Non-start part has start order")
            }
        }
        class Zv {
            constructor(e, t, n) {
                Lv.add(this),
                Uv.set(this, void 0),
                Nv.set(this, void 0),
                kv.set(this, void 0),
                this.environment = hv.Summer,
                Fv.set(this, new lv),
                Ov.set(this, []),
                zv.set(this, new Map),
                Hv.set(this, new Map),
                Wv.set(this, {
                    min: new St(0,0),
                    max: new St(0,0)
                }),
                Vv.set(this, null),
                Gv.set(this, []),
                qv(this, Uv, e, "f"),
                qv(this, Nv, t, "f"),
                qv(this, kv, n, "f")
            }
            get sunDirection() {
                return Yv(this, Fv, "f")
            }
            set sunDirection(e) {
                qv(this, Fv, e.clone(), "f")
            }
            getID() {
                return Yv(this, Vv, "f")
            }
            clear() {
                qv(this, Vv, null, "f"),
                Yv(this, Ov, "f").length = 0,
                Yv(this, zv, "f").clear(),
                Yv(this, Hv, "f").clear(),
                Yv(this, Lv, "m", Qv).call(this)
            }
            getPartsAt(e, t, n) {
                const i = Yv(this, zv, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString());
                return null == i ? [] : i.map((e => ({
                    id: e.type.configuration.id,
                    x: e.x,
                    y: e.y,
                    z: e.z,
                    rotation: e.rotation,
                    rotationAxis: e.rotationAxis,
                    color: e.color,
                    checkpointOrder: e.checkpointOrder,
                    startOrder: e.startOrder
                })))
            }
            setPart(e, t, n, i, r, a, s, o, l) {
                const c = Yv(this, kv, "f").getPart(i);
                if (s != uv.Default && !c.colors.has(s))
                    throw new Error("Track part color does not exist");
                const h = Kh(r, a)
                  , d = new Zt(e * Zv.partSize,t * Zv.partSize,n * Zv.partSize)
                  , u = (new Cn).compose(d, h, new Zt(1,1,1))
                  , f = new Kv(e,t,n,r,a,s,c,u,o,l);
                Yv(this, Ov, "f").push(f);
                c.configuration.tiles.rotated(r, a).forEach(( (i, r, a) => {
                    const s = (e + i).toString() + "|" + (t + r).toString() + "|" + (n + a).toString();
                    if (t + r < 0)
                        throw new Error("Track part below ground");
                    {
                        const e = Yv(this, zv, "f").get(s);
                        null == e ? Yv(this, zv, "f").set(s, [f]) : e.push(f)
                    }
                }
                ));
                const p = Yv(this, Hv, "f").get(i);
                null == p ? Yv(this, Hv, "f").set(i, [f]) : p.push(f)
            }
            deleteSpecificPart(e, t, n, i, r, a) {
                for (const s of Yv(this, Ov, "f"))
                    if (s.type.configuration.id == e && s.x == t && s.y == n && s.z == i && s.rotation == r && s.rotationAxis == a)
                        return Yv(this, Lv, "m", Xv).call(this, s),
                        !0;
                return !1
            }
            getBounds() {
                return Yv(this, Wv, "f")
            }
            generateMeshes() {
                Yv(this, Lv, "m", Qv).call(this);
                const e = Yv(this, Fv, "f").getSunPosition()
                  , t = new Qt(e.x,e.y,e.z,0);
                let n, i = null;
                if (2 == Yv(this, Nv, "f").getSettingInteger(dm.ShadowQuality))
                    switch (this.environment) {
                    case hv.Summer:
                        i = new wi(2511171);
                        break;
                    case hv.Winter:
                        i = new wi(7904713);
                        break;
                    case hv.Desert:
                        i = new wi(7958351)
                    }
                switch (this.environment) {
                case hv.Summer:
                    n = uv.Summer;
                    break;
                case hv.Winter:
                    n = uv.Winter;
                    break;
                case hv.Desert:
                    n = uv.Desert
                }
                const r = Yv(this, Uv, "f").isTrackShadowsEnabled();
                for (const e of Yv(this, kv, "f").getAllParts())
                    for (const [a,s] of e.colors) {
                        const o = [];
                        for (const t of Yv(this, Ov, "f")) {
                            let i = t.color;
                            i == uv.Default && (i = n),
                            t.type == e && i == a && o.push(t)
                        }
                        if (o.length > 0) {
                            if (null == s)
                                throw new Error("Mesh is not loaded");
                            const e = new Qr(s.geometry,s.material,o.length);
                            e.frustumCulled = !1,
                            e.castShadow = r,
                            e.receiveShadow = !0;
                            for (let t = 0; t < o.length; ++t)
                                e.setMatrixAt(t, o[t].matrix);
                            if (Yv(this, Uv, "f").scene.add(e),
                            Yv(this, Gv, "f").push(e),
                            null != i) {
                                const n = new Dv(e,i);
                                n.update(new Yr(new Zt(0,1,0),0), t),
                                Yv(this, Uv, "f").scene.add(n),
                                Yv(this, Gv, "f").push(n)
                            }
                        }
                    }
                Yv(this, Lv, "m", jv).call(this)
            }
            getCheckpoints() {
                let e = [];
                const t = Yv(this, kv, "f").getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = Yv(this, Hv, "f").get(n);
                    null != t && (e = e.concat(t))
                }
                return e.map((e => {
                    if (null == e.checkpointOrder)
                        throw new Error("Checkpoint has no checkpoint order");
                    if (null == e.type.configuration.detector)
                        throw new Error("Checkpoint has no detector");
                    return {
                        x: e.x,
                        y: e.y,
                        z: e.z,
                        rotation: e.rotation,
                        rotationAxis: e.rotationAxis,
                        type: e.type.configuration.id,
                        checkpointOrder: e.checkpointOrder,
                        detector: e.type.configuration.detector
                    }
                }
                ))
            }
            getCheckpointOrders() {
                let e = [];
                const t = Yv(this, kv, "f").getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = Yv(this, Hv, "f").get(n);
                    null != t && (e = e.concat(t))
                }
                return e.map((e => {
                    if (null == e.checkpointOrder)
                        throw new Error("Checkpoint has no checkpoint order");
                    if (null == e.type.configuration.detector)
                        throw new Error("Checkpoint has no detector");
                    return e.checkpointOrder
                }
                ))
            }
            getTotalNumberOfCheckpointIndices() {
                let e = [];
                const t = Yv(this, kv, "f").getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = Yv(this, Hv, "f").get(n);
                    null != t && (e = e.concat(t))
                }
                return e.map((e => e.checkpointOrder)).filter(( (e, t, n) => n.indexOf(e) == t)).length
            }
            getStart() {
                let e = -1 / 0
                  , t = null;
                for (const [n,i] of Yv(this, Hv, "f")) {
                    const r = Yv(this, kv, "f").getPartStartOffset(n);
                    if (i.length > 0 && null != r)
                        for (const n of i) {
                            if (null == n.startOrder)
                                throw new Error("Start part has no start order");
                            n.startOrder >= e && (e = n.startOrder,
                            t = {
                                part: n,
                                startOffset: r
                            })
                        }
                }
                return null != t ? {
                    x: t.part.x,
                    y: t.part.y,
                    z: t.part.z,
                    rotation: t.part.rotation,
                    rotationAxis: t.part.rotationAxis,
                    startOffset: t.startOffset
                } : null
            }
            getStartTransform() {
                const e = this.getStart();
                if (null != e) {
                    const t = Kh(e.rotation, e.rotationAxis).multiply((new Kt).setFromEuler(new Fn(0,Math.PI,0)))
                      , n = e.startOffset;
                    return n.applyQuaternion(t),
                    {
                        position: new Zt(e.x * Zv.partSize + n.x,e.y * Zv.partSize + n.y,e.z * Zv.partSize + n.z),
                        quaternion: t
                    }
                }
                return null
            }
            getNextStartOrder() {
                let e = 0;
                for (const [t,n] of Yv(this, Hv, "f")) {
                    const i = Yv(this, kv, "f").getPartStartOffset(t);
                    if (n.length > 0 && null != i)
                        for (const t of n) {
                            if (null == t.startOrder)
                                throw new Error("Start part has no start order");
                            e = Math.max(e, t.startOrder + 1)
                        }
                }
                return e
            }
            getTrackData() {
                const e = new sw(this.environment,Yv(this, Fv, "f"));
                for (const t of Yv(this, Ov, "f"))
                    e.addPart(t.x, t.y, t.z, t.type.configuration.id, t.rotation, t.rotationAxis, t.color, t.checkpointOrder, t.startOrder);
                return e
            }
            loadTrackData(e, t=!0) {
                return this.clear(),
                qv(this, Vv, t ? e.getId() : null, "f"),
                this.environment = e.environment,
                this.sunDirection = e.sunDirection.clone(),
                e.forEachPart(( (e, t, n, i, r, a, s, o, l) => {
                    this.setPart(e, t, n, i, r, a, s, o, l)
                }
                )),
                !0
            }
        }
        Uv = new WeakMap,
        Nv = new WeakMap,
        kv = new WeakMap,
        Fv = new WeakMap,
        Ov = new WeakMap,
        zv = new WeakMap,
        Hv = new WeakMap,
        Wv = new WeakMap,
        Vv = new WeakMap,
        Gv = new WeakMap,
        Lv = new WeakSet,
        Qv = function() {
            for (const e of Yv(this, Gv, "f"))
                Yv(this, Uv, "f").scene.remove(e);
            Yv(this, Gv, "f").length = 0
        }
        ,
        Xv = function(e) {
            const t = Yv(this, Ov, "f").indexOf(e);
            if (!(t >= 0))
                throw new Error("Track part missing from parts list");
            Yv(this, Ov, "f").splice(t, 1);
            e.type.configuration.tiles.rotated(e.rotation, e.rotationAxis).forEach(( (t, n, i) => {
                const r = (e.x + t).toString() + "|" + (e.y + n).toString() + "|" + (e.z + i).toString()
                  , a = Yv(this, zv, "f").get(r);
                if (null == a)
                    throw new Error("Track part section missing");
                {
                    const t = a.indexOf(e);
                    if (!(t >= 0))
                        throw new Error("Track part missing from parts by position map");
                    a.splice(t, 1),
                    0 == a.length && Yv(this, zv, "f").delete(r)
                }
            }
            ));
            const n = Yv(this, Hv, "f").get(e.type.configuration.id);
            if (null == n)
                throw new Error("Track part type is missing from parts by type map");
            for (let t = 0; t < n.length; ++t) {
                if (n[t] == e) {
                    n.splice(t, 1);
                    break
                }
                if (t == n.length - 1)
                    throw new Error("Track part is missing from parts by type map")
            }
        }
        ,
        jv = function() {
            let e = 1 / 0
              , t = 1 / 0
              , n = -1 / 0
              , i = -1 / 0;
            for (const r of Yv(this, Ov, "f"))
                e = Math.min(r.x, e),
                t = Math.min(r.z, t),
                n = Math.max(r.x, n),
                i = Math.max(r.z, i);
            Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? qv(this, Wv, {
                min: new St(e,t),
                max: new St(n,i)
            }, "f") : qv(this, Wv, {
                min: new St,
                max: new St
            }, "f")
        }
        ,
        Zv.partSize = 5;
        const Jv = Zv;
        var $v, ew, tw, nw, iw, rw = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, aw = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        ew = new WeakMap,
        tw = new WeakMap,
        $v = new WeakSet,
        nw = function() {
            let e = -1 / 0
              , t = null;
            for (const [n,i] of aw(this, tw, "f")) {
                const r = Ev(n).startOffset;
                if (i.length > 0 && null != r)
                    for (const n of i) {
                        if (null == n.startOrder)
                            throw new Error("Start part has no start order");
                        n.startOrder >= e && (e = n.startOrder,
                        t = {
                            part: n,
                            startOffset: r
                        })
                    }
            }
            return null != t ? {
                x: t.part.x,
                y: t.part.y,
                z: t.part.z,
                rotation: t.part.rotation,
                rotationAxis: t.part.rotationAxis,
                startOffset: t.startOffset.clone()
            } : null
        }
        ,
        iw = function() {
            const e = [];
            e.push(this.environment),
            e.push(aw(this, ew, "f").representation);
            let t = 1 / 0
              , n = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , a = -1 / 0
              , s = -1 / 0;
            for (const [,e] of aw(this, tw, "f"))
                for (const o of e)
                    t = Math.min(o.x, t),
                    n = Math.min(o.y, n),
                    i = Math.min(o.z, i),
                    r = Math.max(o.x, r),
                    a = Math.max(o.y, a),
                    s = Math.max(o.z, s);
            Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r) && Number.isFinite(a) && Number.isFinite(s) || (t = 0,
            n = 0,
            i = 0,
            r = 0,
            a = 0,
            s = 0);
            const o = r - t + 1
              , l = a - n + 1
              , c = s - i + 1
              , h = Math.max(1, Math.min(4, Math.ceil(Math.log2(o + 1) / 8)))
              , d = Math.max(1, Math.min(4, Math.ceil(Math.log2(l + 1) / 8)))
              , u = Math.max(1, Math.min(4, Math.ceil(Math.log2(c + 1) / 8)));
            e.push(255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, 255 & n, n >>> 8 & 255, n >>> 16 & 255, n >>> 24 & 255, 255 & i, i >>> 8 & 255, i >>> 16 & 255, i >>> 24 & 255, 255 & (h | d << 2 | u << 4));
            for (const [r,a] of aw(this, tw, "f")) {
                if (r < 0 || r > 255)
                    throw new Error("Type id is out of range");
                const s = a.length;
                e.push(255 & r, 255 & s, s >>> 8 & 255, s >>> 16 & 255, s >>> 24 & 255);
                for (const s of a) {
                    const a = s.x - t
                      , o = s.y - n
                      , l = s.z - i;
                    if (1 == h ? e.push(255 & a) : 2 == h ? e.push(255 & a, a >>> 8 & 255) : 3 == h ? e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255) : 4 == h && e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255),
                    1 == d ? e.push(255 & o) : 2 == d ? e.push(255 & o, o >>> 8 & 255) : 3 == d ? e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255) : 4 == d && e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255, o >>> 24 & 255),
                    1 == u ? e.push(255 & l) : 2 == u ? e.push(255 & l, l >>> 8 & 255) : 3 == u ? e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255) : 4 == u && e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255, l >>> 24 & 255),
                    e.push(3 & s.rotation, 7 & s.rotationAxis, 255 & s.color),
                    Mv.includes(r)) {
                        if (null == s.checkpointOrder)
                            throw new Error("Checkpoint has no checkpoint order");
                        e.push(255 & s.checkpointOrder, s.checkpointOrder >>> 8 & 255)
                    }
                    if (Tv.includes(r)) {
                        if (null == s.startOrder)
                            throw new Error("Start has no start order");
                        e.push(255 & s.startOrder, s.startOrder >>> 8 & 255, s.startOrder >>> 16 & 255, s.startOrder >>> 24 & 255)
                    }
                }
            }
            return new Uint8Array(e)
        }
        ;
        const sw = class {
            constructor(e, t) {
                $v.add(this),
                ew.set(this, void 0),
                tw.set(this, new Map),
                this.environment = e,
                rw(this, ew, t.clone(), "f")
            }
            get sunDirection() {
                return aw(this, ew, "f").clone()
            }
            set sunDirection(e) {
                rw(this, ew, e.clone(), "f")
            }
            addPart(e, t, n, i, r, a, s, o, l) {
                const c = {
                    x: e,
                    y: t,
                    z: n,
                    rotation: r,
                    rotationAxis: a,
                    color: s,
                    checkpointOrder: o,
                    startOrder: l
                }
                  , h = aw(this, tw, "f").get(i);
                null != h ? h.push(c) : aw(this, tw, "f").set(i, [c])
            }
            forEachPart(e) {
                for (const [t,n] of aw(this, tw, "f"))
                    for (const i of n)
                        e(i.x, i.y, i.z, t, i.rotation, i.rotationAxis, i.color, i.checkpointOrder, i.startOrder)
            }
            getId() {
                return (0,
                Z_.sha256)(aw(this, $v, "m", iw).call(this))
            }
            getBounds() {
                let e = 1 / 0
                  , t = 1 / 0
                  , n = -1 / 0
                  , i = -1 / 0;
                return this.forEachPart(( (r, a, s) => {
                    e = Math.min(r, e),
                    t = Math.min(s, t),
                    n = Math.max(r, n),
                    i = Math.max(s, i)
                }
                )),
                Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? {
                    min: new St(e,t),
                    max: new St(n,i)
                } : {
                    min: new St,
                    max: new St
                }
            }
            hasStartingPoint() {
                return null != aw(this, $v, "m", nw).call(this)
            }
            getStartTransform() {
                const e = aw(this, $v, "m", nw).call(this);
                if (null != e) {
                    const t = Kh(e.rotation, e.rotationAxis).multiply((new Kt).setFromEuler(new Fn(0,Math.PI,0)))
                      , n = e.startOffset;
                    return n.applyQuaternion(t),
                    {
                        position: new Zt(e.x * Jv.partSize + n.x,e.y * Jv.partSize + n.y,e.z * Jv.partSize + n.z),
                        quaternion: t
                    }
                }
                return null
            }
            toSaveString() {
                const e = aw(this, $v, "m", iw).call(this)
                  , t = new lh.Deflate({
                    level: 9,
                    windowBits: 9,
                    memLevel: 9
                });
                t.push(e, !0);
                const n = ev(t.result)
                  , i = new lh.Deflate({
                    level: 9,
                    windowBits: 15,
                    memLevel: 9
                });
                return i.push(n, !0),
                ev(i.result)
            }
            toExportString(e) {
                const t = (new TextEncoder).encode(e.name);
                let n, i;
                null != e.author ? (i = (new TextEncoder).encode(e.author),
                n = i.length) : (i = null,
                n = 0);
                const r = new Uint8Array(1 + t.length + 1 + n);
                r[0] = t.length,
                r.set(t, 1),
                r[1 + t.length] = n,
                null != i && r.set(i, 1 + t.length + 1);
                const a = aw(this, $v, "m", iw).call(this)
                  , s = new lh.Deflate({
                    level: 9,
                    windowBits: 9,
                    memLevel: 9
                });
                s.push(r, !1),
                s.push(a, !0);
                const o = ev(s.result)
                  , l = new lh.Deflate({
                    level: 9,
                    windowBits: 15,
                    memLevel: 9
                });
                return l.push(o, !0),
                "PolyTrack1" + ev(l.result)
            }
            static fromSaveString(e) {
                const t = function(e) {
                    const t = tv(e);
                    if (null == t)
                        return null;
                    const n = new lh.Inflate({
                        to: "string"
                    });
                    if (n.push(t, !0),
                    n.err)
                        return null;
                    const i = n.result;
                    if ("string" != typeof i)
                        return null;
                    const r = tv(i);
                    if (null == r)
                        return null;
                    const a = new lh.Inflate;
                    if (a.push(r, !0),
                    a.err)
                        return null;
                    const s = a.result;
                    return s instanceof Uint8Array ? Bv(0, s) : null
                }(e);
                if (null != t)
                    return t;
                const n = Pv(e);
                if (null != n)
                    return n;
                const i = Rv(e);
                if (null != i)
                    return i;
                const r = Iv(e);
                if (null != r)
                    return r;
                const a = Cv(e);
                return null != a ? a : null
            }
            static fromExportString(e) {
                const t = e.replace(/\s+/g, "")
                  , n = function(e) {
                    const t = "PolyTrack1";
                    if (!e.startsWith(t))
                        return null;
                    const n = tv(e.substring(10));
                    if (null == n)
                        return null;
                    const i = new lh.Inflate({
                        to: "string"
                    });
                    if (i.push(n, !0),
                    i.err)
                        return null;
                    const r = i.result;
                    if ("string" != typeof r)
                        return null;
                    const a = tv(r);
                    if (null == a)
                        return null;
                    const s = new lh.Inflate;
                    if (s.push(a, !0),
                    s.err)
                        return null;
                    const o = s.result;
                    if (!(o instanceof Uint8Array))
                        return null;
                    const l = o[0];
                    if (o.length < 1 + l)
                        return null;
                    const c = new TextDecoder("utf-8").decode(o.subarray(1, 1 + l))
                      , h = o[1 + l];
                    if (o.length < 1 + l + 1 + h)
                        return null;
                    let d;
                    d = h > 0 ? new TextDecoder("utf-8").decode(o.subarray(1 + l + 1, 1 + l + 1 + h)) : null;
                    const u = Bv(1 + l + 1 + h, o);
                    return null == u ? null : {
                        trackMetadata: {
                            name: c,
                            author: d
                        },
                        trackData: u
                    }
                }(t);
                if (null != n)
                    return n;
                const i = function(e) {
                    if (!e.startsWith("v3"))
                        return null;
                    const t = tv(e.substring(2, 4));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0]
                      , i = tv(e.substring(4, 4 + n));
                    if (null == i)
                        return null;
                    let r;
                    try {
                        r = new TextDecoder("utf-8").decode(i)
                    } catch (e) {
                        return null
                    }
                    const a = Pv(e.substring(4 + n));
                    return null == a ? null : {
                        trackMetadata: {
                            name: r,
                            author: null
                        },
                        trackData: a
                    }
                }(t);
                if (null != i)
                    return i;
                const r = function(e) {
                    if (!e.startsWith("v2"))
                        return null;
                    const t = tv(e.substring(2, 4));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0]
                      , i = Math.ceil(n / 3 * 4)
                      , r = tv(e.substring(4, 4 + i));
                    if (null == r)
                        return null;
                    let a;
                    try {
                        a = new TextDecoder("utf-8").decode(r)
                    } catch (e) {
                        return null
                    }
                    const s = Rv(e.substring(4 + i));
                    return null == s ? null : {
                        trackMetadata: {
                            name: a,
                            author: null
                        },
                        trackData: s
                    }
                }(t);
                if (null != r)
                    return r;
                const a = function(e) {
                    if (!e.startsWith("v1n"))
                        return null;
                    const t = ch(e.substring(3, 5));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0]
                      , i = e.substring(5, 5 + n);
                    let r;
                    try {
                        r = decodeURIComponent(i)
                    } catch (e) {
                        return console.warn(e),
                        null
                    }
                    const a = Iv(e.substring(5 + n));
                    return null == a ? null : {
                        trackMetadata: {
                            name: r,
                            author: null
                        },
                        trackData: a
                    }
                }(t);
                if (null != a)
                    return a;
                const s = function(e) {
                    let t, n;
                    try {
                        t = JSON.parse(e)
                    } catch (e) {
                        return console.warn(e),
                        null
                    }
                    if ("string" != typeof t.name)
                        return null;
                    if ("string" != typeof t.track)
                        return null;
                    try {
                        n = JSON.parse(t.track)
                    } catch (e) {
                        return console.warn(e),
                        null
                    }
                    const i = Cv(n);
                    return null == i ? null : {
                        trackMetadata: {
                            name: t.name,
                            author: null
                        },
                        trackData: i
                    }
                }(e);
                return null != s ? s : null
            }
            createThumbnail() {
                let e = 1 / 0
                  , t = 1 / 0
                  , n = -1 / 0
                  , i = -1 / 0;
                this.forEachPart(( (r, a, s, o, l, c) => {
                    Ev(o).tiles.rotated(l, c).forEach(( (a, o, l) => {
                        e = Math.min(e, Math.floor((r + a - 2) / 4)),
                        t = Math.min(t, Math.floor((s + l - 2) / 4)),
                        n = Math.max(n, Math.floor((r + a - 2) / 4)),
                        i = Math.max(i, Math.floor((s + l - 2) / 4))
                    }
                    ))
                }
                )),
                Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) || (e = 0,
                t = 0,
                n = 0,
                i = 0);
                const r = 10
                  , a = n - e + 1;
                a <= r && (n += Math.ceil((r - a) / 2),
                e -= Math.ceil((r - a) / 2));
                const s = i - t + 1;
                s <= r && (i += Math.ceil((r - s) / 2),
                t -= Math.ceil((r - s) / 2));
                const o = document.createElement("canvas");
                o.width = Math.min(1024, n - e + 1),
                o.height = Math.min(1024, i - t + 1);
                const l = o.getContext("2d");
                if (null == l)
                    throw new Error("Failed to get canvas context");
                const c = l.createImageData(o.width, o.height)
                  , h = []
                  , d = []
                  , u = [];
                let f, p, m;
                switch (this.environment) {
                case hv.Summer:
                    f = 255,
                    p = 255,
                    m = 255;
                    break;
                case hv.Winter:
                    f = 190,
                    p = 216,
                    m = 247;
                    break;
                case hv.Desert:
                    f = 237,
                    p = 226,
                    m = 175
                }
                this.forEachPart(( (n, i, r, a, s, l) => {
                    const g = Ev(a);
                    g.tiles.rotated(s, l).forEach(( (i, a, s) => {
                        const l = Math.floor((n + i - 2) / 4) - e
                          , A = Math.floor((r + s - 2) / 4) - t
                          , _ = 4 * (l + A * o.width);
                        c.data[_ + 0] = f,
                        c.data[_ + 1] = p,
                        c.data[_ + 2] = m,
                        c.data[_ + 3] = 255,
                        null != g.startOffset ? d.push([l, A]) : null != g.detector && g.detector.type == qh.Checkpoint ? h.push([l, A]) : null != g.detector && g.detector.type == qh.Finish && u.push([l, A])
                    }
                    ))
                }
                ));
                for (const [e,t] of h)
                    c.data[4 * (e + t * o.width) + 0] = 226,
                    c.data[4 * (e + t * o.width) + 1] = 192,
                    c.data[4 * (e + t * o.width) + 2] = 38,
                    c.data[4 * (e + t * o.width) + 3] = 255;
                for (const [e,t] of d)
                    c.data[4 * (e + t * o.width) + 0] = 51,
                    c.data[4 * (e + t * o.width) + 1] = 140,
                    c.data[4 * (e + t * o.width) + 2] = 224,
                    c.data[4 * (e + t * o.width) + 3] = 255;
                for (const [e,t] of u)
                    c.data[4 * (e + t * o.width) + 0] = 209,
                    c.data[4 * (e + t * o.width) + 1] = 41,
                    c.data[4 * (e + t * o.width) + 2] = 41,
                    c.data[4 * (e + t * o.width) + 3] = 255;
                return l.putImageData(c, 0, 0),
                o
            }
        }
        ;
        const ow = class {
            constructor() {
                this.up = !1,
                this.right = !1,
                this.down = !1,
                this.left = !1,
                this.reset = !1
            }
            dispose() {}
            getControls() {
                return {
                    up: this.up,
                    right: this.right,
                    down: this.down,
                    left: this.left,
                    reset: this.reset
                }
            }
        }
        ;
        var lw = function(e, t, n, i) {
            return new (n || (n = Promise))((function(r, a) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function o(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value,
                    t instanceof n ? t : new n((function(e) {
                        e(t)
                    }
                    ))).then(s, o)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        };
        importScripts("lib/ammo.wasm.js");
        const cw = [];
        onmessage = e => {
            cw.push(e)
        }
        ,
        Ammo().then((function(e) {
            return lw(this, void 0, void 0, (function*() {
                yield function() {
                    return M_(this, void 0, void 0, (function*() {
                        const e = Uint8Array.from(atob("AGFzbQEAAAABJAZgAXwBfGACfHwBfGACf38AYAJ/fABgBH9/f38Bf2ACfH8BfAMcGwQDAQAAAAAAAAAAAQACBQIBAQAAAAAAAAAAAAUDAQARBgkBfwFBgIDAAAsHVQwGbWVtb3J5AgAEYWNvcwASBGFzaW4AEwRhdGFuABQFYXRhbjIAEANleHAAFQNsb2cAFgNwb3cAEQRzcXJ0ABcDdGFuABgEbG9nMgAZBWxvZzEwABoKsG4bqxsDHH8BfgR8IwBBwARrIgckACAHQQhqQaABEA8gB0GoAWpBoAEQDyAHQcgCakGgARAPIAdB6ANqQdAAEA9BhIDAACgCACIKIAFBf2oiC2ohBSADQX1qQRhtIgRBACAEQQBKGyIPIAtrIQQgD0ECdCABQQJ0a0GUgMAAaiEJQQAhAQNAIAdBCGogAUEDdGogBEEASAR8RAAAAAAAAAAABSAJKAIAtws5AwAgASAFSQRAIAlBBGohCSAEQQFqIQQgASABIAVJaiIBIAVNDQELCyADQWhqIQVBACEEA0AgBCALaiENIAQgCkkhBkQAAAAAAAAAACEhQQAhAQNAAkAgISAAIAFBA3RqKwMAIAdBCGogDSABa0EDdGorAwCioCEhIAEgC08NACABIAEgC0lqIgEgC00NAQsLIAdByAJqIARBA3RqICE5AwAgBCAKSQRAIAQgBmoiBCAKTQ0BCwtEAAAAAAAA8H9EAAAAAAAA4H8gBSAPQWhsIhdqIgZB/g9LIhIbRAAAAAAAAAAARAAAAAAAAGADIAZBuXBJIhMbRAAAAAAAAPA/IAZBgnhIIhQbIAZB/wdKIhUbIAZB/RcgBkH9F0gbQYJwaiAGQYF4aiASGyIYIAZB8GggBkHwaEobQZIPaiAGQckHaiATGyIZIAYgFBsgFRtB/wdqrUI0hr+iISMgB0HkA2oiECAKQQJ0aiENQRcgBmtBH3EhGkEYIAZrQR9xIRYgB0HAAmohGyAGQX9qIRwgCiEEAkADQCAHQcgCaiAEIgVBA3RqKwMAISECQCAFRQ0AIAdB6ANqIQggBSEBA0AgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhBCAhQQBB/////wcgIplEAAAAAAAA4EFjBH8gIqoFQYCAgIB4C0GAgICAeCAEGyAiRAAAwP///99BZBsgIiAiYhu3IiJEAAAAAAAAcMGioCIhRAAAAAAAAODBZiEEIAhBAEH/////BwJ/ICGZRAAAAAAAAOBBYwRAICGqDAELQYCAgIB4C0GAgICAeCAEGyAhRAAAwP///99BZBsgISAhYhs2AgAgGyABQQN0aisDACAioCEhIAFBAkkiBA0BIAhBBGohCEEBIAFBf2ogBBsiAQ0ACwsCfwJAIBVFBEAgFA0BIAYMAgsgIUQAAAAAAADgf6IiIUQAAAAAAADgf6IgISASGyEhIBgMAQsgIUQAAAAAAABgA6IiIUQAAAAAAABgA6IgISATGyEhIBkLIQECQCAhIAFB/wdqrUI0hr+iIiREAAAAAAAAwD+iIiFEAAAAAAAAAABhDQAgIb0iIEI0iKdB/w9xIgFBsghLDQACQAJAICBCAFkEQCAHICFEAAAAAAAAMEOgRAAAAAAAADDDoCAhoSIiOQO4BCABQf8HTw0BIAcrA7gEGkQAAAAAAAAAACEhDAMLIAcgIUQAAAAAAAAww6BEAAAAAAAAMEOgICGhIiI5A7gEIAFB/wdJDQELICEgIqAiIUQAAAAAAADwv6AgISAiRAAAAAAAAAAAZBshIQwBCyAHKwO4BBpEAAAAAAAA8L8hIQsgJCAhRAAAAAAAACDAoqAiIUQAAAAAAADgwWYhASAhQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggARsgIUQAAMD////fQWQbICEgIWIbIg63oSEhAn8CQAJAAkACQAJ/IAZBAEoiHUUEQCAGRQRAIBAgBUECdGooAgBBF3UMAgtBAiEMQQAgIUQAAAAAAADgP2ZFDQYaDAILIBAgBUECdGoiASABKAIAIgEgASAWdSIBIBZ0ayIENgIAIAEgDmohDiAEIBp1CyIMQQFIDQELIAUNAUEAIQgMAgsgDAwCC0EAIRFBACEIIAVBAUcEQCAFQR5xIR4gB0HoA2ohAQNAIAEoAgAhBEH///8HIQkCfwJAIAgNAEGAgIAIIQkgBA0AQQEMAQsgASAJIARrNgIAQQALIQkgAUEEaiIfKAIAIQhB////ByEEAn8CQCAJRQ0AQYCAgAghBCAIDQBBAAwBCyAfIAQgCGs2AgBBAQshCCABQQhqIQEgHiARQQJqIhFHDQALCyAFQQFxRQ0AIAdB6ANqIBFBAnRqIgkoAgAhAUH///8HIQQCQCAIDQBBgICACCEEIAENAEEAIQgMAQsgCSAEIAFrNgIAQQEhCAsCQCAdRQ0AQf///wMhAQJAAkAgHA4CAQACC0H///8BIQELIBAgBUECdGoiBCAEKAIAIAFxNgIACyAOQQFqIQ4gDCAMQQJHDQAaRAAAAAAAAPA/ICGhICNEAAAAAAAAAAAgCBuhISFBAgshDCAhRAAAAAAAAAAAYQRAIA0hASAFIQQCQCAKIAVBf2oiCEsNAEEAIQkDQAJAIAdB6ANqIAhBAnRqKAIAIAlyIQkgCiAITw0AIAogCCAKIAhJayIITQ0BCwsgBSEEIAlFDQAgBUECdCAHakHkA2ohAQNAIAVBf2ohBSAGQWhqIQYgASgCACABQXxqIQFFDQALDAMLA0AgBEEBaiEEIAEoAgAgAUF8aiEBRQ0ACyAFIARPDQEgBUEBaiEJA0AgB0EIaiAJIAtqIgVBA3RqIAkgD2pBAnRBkIDAAGooAgC3OQMAQQAhAUQAAAAAAAAAACEhA0ACQCAhIAAgAUEDdGorAwAgB0EIaiAFIAFrQQN0aisDAKKgISEgASALTw0AIAEgASALSWoiASALTQ0BCwsgB0HIAmogCUEDdGogITkDACAJIARPDQIgCSAESSAJaiIBIQkgASAETQ0ACwwBCwsCQAJAAkBBACAGayIBQf8HTARAIAFBgnhODQMgIUQAAAAAAABgA6IhISABQbhwTQ0BQckHIAZrIQEMAwsgIUQAAAAAAADgf6IhISABQf4PSw0BQYF4IAZrIQEMAgsgIUQAAAAAAABgA6IhISABQfBoIAFB8GhKG0GSD2ohAQwBCyAhRAAAAAAAAOB/oiEhIAFB/RcgAUH9F0gbQYJwaiEBCyAhIAFB/wdqrUI0hr+iIiFEAAAAAAAAcEFmBEAgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhACAhQQBB/////wcCfyAimUQAAAAAAADgQWMEQCAiqgwBC0GAgICAeAtBgICAgHggABsgIkQAAMD////fQWQbICIgImIbtyIhRAAAAAAAAHDBoqAiIkQAAAAAAADgwWYhACAHQegDaiAFQQJ0akEAQf////8HAn8gIplEAAAAAAAA4EFjBEAgIqoMAQtBgICAgHgLQYCAgIB4IAAbICJEAADA////30FkGyAiICJiGzYCACADIBdqIQYgBUEBaiEFCyAhRAAAAAAAAODBZiEAIAdB6ANqIAVBAnRqQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggABsgIUQAAMD////fQWQbICEgIWIbNgIACwJ8AkACQCAGQf8HTARARAAAAAAAAPA/IAZBgnhODQMaIAZBuHBNDQEgBkHJB2ohBkQAAAAAAABgAwwDCyAGQf4PSw0BIAZBgXhqIQZEAAAAAAAA4H8MAgsgBkHwaCAGQfBoShtBkg9qIQZEAAAAAAAAAAAMAQsgBkH9FyAGQf0XSBtBgnBqIQZEAAAAAAAA8H8LIAZB/wdqrUI0hr+iISEgBUEBcQR/IAUFIAdByAJqIAVBA3RqICEgB0HoA2ogBUECdGooAgC3ojkDACAhRAAAAAAAAHA+oiEhIAVBf2oLIQAgBQRAIABBA3QgB2pBwAJqIQEgAEECdCAHakHkA2ohBANAIAEgIUQAAAAAAABwPqIiIiAEKAIAt6I5AwAgAUEIaiAhIARBBGooAgC3ojkDACABQXBqIQEgBEF4aiEEICJEAAAAAAAAcD6iISEgAEEBRyAAQX5qIQANAAsLIAVBAWohBiAHQcgCaiAFQQN0aiEIIAUhAQNAAkAgCiAFIAEiAGsiAyAKIANJGyINRQRAQQAhBEQAAAAAAAAAACEhDAELIA1BAWpBfnEhCUQAAAAAAAAAACEhQQAhAUEAIQQDQCAhIAFBmILAAGorAwAgASAIaiILKwMAoqAgAUGggsAAaisDACALQQhqKwMAoqAhISABQRBqIQEgCSAEQQJqIgRHDQALCyAHQagBaiADQQN0aiANQQFxBHwgIQUgISAEQQN0QZiCwABqKwMAIAdByAJqIAAgBGpBA3RqKwMAoqALOQMAIAhBeGohCCAAQX9qIQEgAA0ACwJAIAZBA3EiAEUEQEQAAAAAAAAAACEhIAUhBAwBCyAHQagBaiAFQQN0aiEBRAAAAAAAAAAAISEgBSEEA0AgBEF/aiEEICEgASsDAKAhISABQXhqIQEgAEF/aiIADQALCyAFQQNPBEAgBEEDdCAHakGQAWohAQNAICEgAUEYaisDAKAgAUEQaisDAKAgAUEIaisDAKAgASsDAKAhISABQWBqIQEgBEEDRyAEQXxqIQQNAAsLIAIgIZogISAMGzkDACAHKwOoASAhoSEhAkAgBUUNAEEBIQEDQCAhIAdBqAFqIAFBA3RqKwMAoCEhIAEgBU8NASABIAEgBUlqIgEgBU0NAAsLIAIgIZogISAMGzkDCCAHQcAEaiQAIA5BB3ELtxIDA38BfgR8IwBBMGsiBCQAAkACQAJAAkACQCABvSIFQiCIpyIDQf////8HcSICQfvUvYAETwRAIAJBvIzxgARPBEAgBEEAQf////8HAn8CQCACQfvD5IkETwRAIAJB//+//wdLDQUgBUL/////////B4NCgICAgICAgLDBAIS/IgFEAAAAAAAA4MFmIQMgAZlEAAAAAAAA4EFjRQ0BIAGqDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwIC0GAgICAeAtBgICAgHggAxsgAUQAAMD////fQWQbIAEgAWIbtyIHOQMAIAEgB6FEAAAAAAAAcEGiIgFEAAAAAAAA4MFmIQMgBEEAQf////8HAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLQYCAgIB4IAMbIAFEAADA////30FkGyABIAFiGyIDtyIHOQMIIAQgASAHoUQAAAAAAABwQaIiATkDECAEQShqQgA3AwAgBEEgakIANwMAIARCADcDGCAEQQJBASADG0EDIAFEAAAAAAAAAABhGyAEQRhqIAJBFHZB6ndqEAAhAiAFQn9VBEAgACACNgIIIAAgBCsDIDkDECAAIAQrAxg5AwAMBwsgAEEAIAJrNgIIIAAgBCsDIJo5AxAgACAEKwMYmjkDAAwGCyACQb3714AETwRAIAJB+8PkgARGBEACQCABIAFEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiBkQAAEBU+yH5v6KgIgEgBkQxY2IaYbTQPaIiCaEiCL1CgICAgICAgPj/AINC/////////4c/Vg0AIAEgBkQAAGAaYbTQPaIiCKEiByAGRHNwAy6KGaM7oiABIAehIAihoSIJoSIIvUKAgICAgICAgP8Ag0L//////////zxWBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwHCyAFQgBZBEAgAEEENgIIIAAgAUQAAEBU+yEZwKAiAUQxY2IaYbTwvaAiBzkDACAAIAEgB6FEMWNiGmG08L2gOQMQDAcLIABBfDYCCCAAIAFEAABAVPshGUCgIgFEMWNiGmG08D2gIgc5AwAgACABIAehRDFjYhphtPA9oDkDEAwGCyACQfyyy4AERg0EIAVCAFkEQCAAQQM2AgggACABRAAAMH982RLAoCIBRMqUk6eRDum9oCIHOQMAIAAgASAHoUTKlJOnkQ7pvaA5AxAMBgsgAEF9NgIIIAAgAUQAADB/fNkSQKAiAUTKlJOnkQ7pPaAiBzkDACAAIAEgB6FEypSTp5EO6T2gOQMQDAULIANB//8/cUH7wyRGDQIgAkH9souABE8EQCAFQn9VBEAgAEECNgIIIAAgAUQAAEBU+yEJwKAiAUQxY2IaYbTgvaAiBzkDACAAIAEgB6FEMWNiGmG04L2gOQMQDAYLIABBfjYCCCAAIAFEAABAVPshCUCgIgFEMWNiGmG04D2gIgc5AwAgACABIAehRDFjYhphtOA9oDkDEAwFCyAFQn9VDQEgAEF/NgIIIAAgAUQAAEBU+yH5P6AiAUQxY2IaYbTQPaAiBzkDACAAIAEgB6FEMWNiGmG00D2gOQMQDAQLIABBADYCCCAAIAEgAaEiATkDECAAIAE5AwAMAwsgAEEBNgIIIAAgAUQAAEBU+yH5v6AiAUQxY2IaYbTQvaAiBzkDACAAIAEgB6FEMWNiGmG00L2gOQMQDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwBCwJAIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUKAgICAgICA+P8Ag0L/////////hz9WDQAgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QoCAgICAgICA/wCDQv//////////PFYEQCAHIQEMAQsgByAGRAAAAC6KGaM7oiIIoSIBIAZEwUkgJZqDezmiIAcgAaEgCKGhIgmhIQgLIAAgCDkDACAAIAEgCKEgCaE5AxAgBkQAAAAAAADgwWYhAyAAQQBB/////wcCfyAGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAtBgICAgHggAxsgBkQAAMD////fQWQbIAYgBmIbNgIICyAEQTBqJAALzA8DCX8CfgV8RAAAAAAAAPA/IQ0CQAJAAkACQCABvSILQiCIpyIIQf////8HcSICIAunIgZyRQ0AIAC9IgxCIIinIQQgDKciCUVBACAEQYCAwP8DRhsNAAJAAkACQAJAAkACQCAEQf////8HcSIFQYCAwP8HSw0AAkAgBUGAgMD/B0YEQCAJIAJBgIDA/wdLcg0CDAELIAJBgYDA/wdPDQELIAJBgIDA/wdHDQEgBg0AIAVBgIDAgHxqIAlyRQ0GIAVB//+//wNLDQJEAAAAAAAAAAAgAZogC0J/VRsPCyAAIAGgDwsgDEIAUw0BIAYNAyACQYCAwP8DRw0CDAULIAFEAAAAAAAAAAAgC0J/VRsPC0ECIQMCQAJAIAJB////mQRLDQBBACEDIAJBgIDA/wNJDQAgAkEUdiEHIAJB////iQRNBEAgBg0EIAJBEyAHayIGdiIHIAZ0IAJHDQJBAiAHQQFxayEDDAILIAZBEyAHayIHdiIKIAd0IAZHDQBBAiAKQQFxayEDIAYNAwwBCyAGDQILIAJBgIDA/wNGDQMLIAhBgICA/wNHBEAgCEGAgICABEcNASAAIACiDwsgDEIAUw0AIAAQBA8LIACZIQ0CQAJAIAkNACAEQX9MBEAgBEGAgICAeEYgBEGAgMD/e0ZyDQIgBEGAgEBHDQEMAgsgBEUgBEGAgMD/A0ZyIARBgIDA/wdGcg0BC0QAAAAAAADwPyEPAkAgDEIAWQ0AAkACQCADDgIAAQILIAAgAKEiACAAow8LRAAAAAAAAPC/IQ8LAkAgAkGAgICPBE0EQCANRAAAAAAAAEBDoiIAIA0gBUGAgMAASSICGyENIAC9QiCIpyAFIAIbIgVB//8/cSIDQYCAwP8DciEEIAVBFHVBzHdBgXggAhtqIQVBACECAkAgA0GPsQ5JDQAgA0H67C5JBEBBASECDAELIANBgICA/wNyIQQgBUEBaiEFCyACQQN0IgNBqIPAAGorAwBEAAAAAAAA8D8gA0GYg8AAaisDACIAIA29Qv////8PgyAErUIghoS/IhCgoyINIBAgAKEiDiACQRJ0IARBAXZqQYCAoIACaq1CIIa/IhEgDiANoiIOvUKAgICAcIO/Ig2ioSAQIBEgAKGhIA2ioaIiACANIA2iIhBEAAAAAAAACECgIAAgDiANoKIgDiAOoiIAIACiIAAgACAAIAAgAETvTkVKKH7KP6JEZdvJk0qGzT+gokQBQR2pYHTRP6CiRE0mj1FVVdU/oKJE/6tv27Zt2z+gokQDMzMzMzPjP6CioCIRoL1CgICAgHCDvyIAoiAOIBEgAEQAAAAAAAAIwKAgEKGhoqAiDiAOIA0gAKIiDaC9QoCAgIBwg78iACANoaFE/QM63AnH7j+iIABE9QFbFOAvPr6ioKAiDSADQbiDwABqKwMAIg4gDSAARAAAAOAJx+4/oiINoKAgBbciEKC9QoCAgIBwg78iACAQoSAOoSANoaEhDgwBCwJAAkAgAkGAgMCfBE0EQCAFQf//v/8DSQ0CIAVBgIDA/wNLDQEgDUQAAAAAAADwv6AiAERE3134C65UPqIgACAAokQAAAAAAADgPyAAIABEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIg0gDSAARAAAAGBHFfc/oiINoL1CgICAgHCDvyIAIA2hoSEODAMLIAVB//+//wNNBEBEAAAAAAAA8H9EAAAAAAAAAAAgC0IAUxsPC0QAAAAAAADwf0QAAAAAAAAAACAIQQBKGw8LIAhBAEwNBQwGCyALQgBZDQQMBQsgACALQoCAgIBwg78iEKIiDSAOIAGiIAEgEKEgAKKgIgCgIgG9IgunIQICQCALQiCIpyIDQf//v4QETARAIANBgPj//wdxQf+Xw4QETQ0BIANBgOi8+wNqIAJyDQUgACABIA2hZUUNAQwFCyADQYCAwPt7aiACcg0FIABE/oIrZUcVlzygIAEgDaFkRQ0ADAULQQAhAiAPAnwgA0H/////B3FBgICA/wNLBH5BAEGAgMAAIANBFHZBAmp2IANqIgNB//8/cUGAgMAAckETIANBFHYiBGt2IgJrIAIgC0IAUxshAiAAIA1BgIBAIARBAWp1IANxrUIghr+hIg2gvQUgCwtCgICAgHCDvyIBRAAAAABDLuY/oiIOIAAgASANoaFE7zn6/kIu5j+iIAFEOWyoDGFcIL6ioCINoCIAIAAgACAAIACiIgEgASABIAEgAUTQpL5yaTdmPqJE8WvSxUG9u76gokQs3iWvalYRP6CiRJO9vhZswWa/oKJEPlVVVVVVxT+goqEiAaIgAUQAAAAAAAAAwKCjIA0gACAOoaEiASAAIAGioKGhRAAAAAAAAPA/oCIAvSILQiCIpyACQRR0aiIDQYCAwABOBEAgC0L/////D4MgA61CIIaEvwwBCyAAIAIQDguiIQ0MAQtEAAAAAAAA8D8gDaMgDSALQgBTGyENIAxCf1UNACADIAVBgIDAgHxqckUEQCANIA2hIgAgAKMPCyANmiANIANBAUYbDwsgDQ8LIAtCf1UEQCAADwtEAAAAAAAA8D8gAKMPCyAPRFnz+MIfbqUBokRZ8/jCH26lAaIPCyAPRJx1AIg85Dd+okScdQCIPOQ3fqILswcDBH8BfgN8IwBBIGsiAiQAAkACQAJ8AkACQCAAvSIFQiCIp0H/////B3EiAUH8w6T/A08EQCABQf//v/8HTQRAIAJBCGogABABIAIoAhAhAyACKwMYIQggAisDCCIHvSIFQoCAgICA/////wCDQoCAgIDwhOXyP1YiBA0CDAULIAAgAKEhAAwFCyABQYCAgPIDTwRAIAVCgICAgID/////AINCgICAgPCE5fI/ViIBDQIgAAwDCyACIABEAAAAAAAAcDiiIABEAAAAAAAAcEegIAFBgIDAAEkbOQMIIAIrAwgaDAQLRBgtRFT7Iek/IAcgB5ogBUJ/VSIBG6FEB1wUMyamgTwgCCAImiABG6GgIQdEAAAAAAAAAAAhCAwCC0QYLURU+yHpPyAAmiAAIAVCAFMboUQHXBQzJqaBPKALIgcgByAHIAeiIgaiIgBEY1VVVVVV1T+iIAYgACAGIAaiIgAgACAAIAAgAERzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgBiAAIAAgACAAIABE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCiRAAAAAAAAAAAoKJEAAAAAAAAAACgoCIGoCEAIAFFDQFEAAAAAAAA8D8gByAGIAAgAKIgAEQAAAAAAADwP6CjoaAiACAAoKEiAJogACAFQgBTGyEADAELIANBAXEhASAHIAcgByAHoiIGoiIARGNVVVVVVdU/oiAIIAYgCCAAIAYgBqIiACAAIAAgACAARHNTYNvLdfO+okSmkjegiH4UP6CiRAFl8vLYREM/oKJEKANWySJtbT+gokQ31gaE9GSWP6CiRHr+EBEREcE/oCAGIAAgACAAIAAgAETUer90cCr7PqJE6afwMg+4Ej+gokRoEI0a9yYwP6CiRBWD4P7I21c/oKJEk4Ru6eMmgj+gokT+QbMbuqGrP6CioKKgoqCgIgigIQAgBEUEQCABRQ0BRAAAAAAAAPC/IACjIgYgAL1CgICAgHCDvyIAIAa9QoCAgIBwg78iBqJEAAAAAAAA8D+gIAggACAHoaEgBqKgoiAGoCEADAELRAAAAAAAAPA/IAG3IgYgBqChIgYgByAIIAAgAKIgBiAAoKOhoCIAIACgoSIAmiAAIAVCAFMbIQALIAJBIGokACAAC9UEAgl/AX4gAL0iCkIgiKciAUGAgMD/B3FBgIDA/wdGBEAgACAAoiAAoA8LIAqnIQICfwJ/AkACQAJAAkAgAUEATARAIAFB/////wdxIAJyRQ0CIApCf1cNAQsgAUEUdSABQf//P0sNBRpBASEEIAEEQCACIQMMBAsgAiEDA0AgBEFraiEEIAMiAkEVdCEDIAJBgBBJDQALDAILIAAgAKEiACAAoyEACyAADwsgAkELdiIBIAJBAEgNARoLIAFBFCABZ0Efc2siBXQLIQEgAyAFdCECIANBACAFa3YgAXIhASAEIAVrCyABQf//P3FBgIDAAHIhA0GBeGoiCUEBcQRAIANBAXQgAkEfdnIhAyACQQF0IQILIANBAXQgAkEfdnIhBCACQQF0IQNBgICAASEBQQAhAgNAIAIgASACaiIFIAFqIAUgBEoiBhshAiAEQQAgBSAGG2tBAXQgA0EfdnIhBCADQQF0IQNBACABIAYbIAdqIQcgAUEBSyABQQF2IQENAAtBgICAgHghBUEAIQYDQCAEIAJMQQAgAiAERyADIAggBSIBaiIFSXIbRQRAIAQgAmsgAyAFSWshBCACIAVBAEggASAFaiIIQX9KcWohAiABIAZqIQYgAyAFayEDCyAEQQF0IANBH3ZyIQQgAUEBdiEFIANBAXQhAyABQQJPDQALAkAgAyAEckUNACAGQX9GBEAgB0EBaiEHQQAhBgwBCyAGQQFxIAZqIQYLIAdBH3QgBkEBdnKtIAlBE3RBgIBAcSAHQQF1akGAgID/A2qtQiCGhL8LrQUDA38BfgJ8IwBBEGshASAAvSIEQj+IpyECAkACfCAAAn8CQAJAAkACQCAEQiCIp0H/////B3EiA0GrxpiEBE8EQCAAIABiBEAgAA8LIABE7zn6/kIuhkBkDQIgAETSvHrdKyOGwGNFDQEgAUQAAAAAAACgtiAAo7Y4AgQgASoCBBogAERRMC3VEEmHwGNFDQEMBwsgA0HC3Nj+A00EQCADQYCAwPEDTQ0DQQAhASAADAYLIANBscXC/wNNDQMLIABE/oIrZUcV9z+iIAJBA3RBiIPAAGorAwCgIgVEAAAAAAAA4MFmIQJBAEH/////BwJ/IAWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C0GAgICAeCACGyAFRAAAwP///99BZBsgBSAFYhsMAwsgAEQAAAAAAADgf6IPCyABIABEAAAAAAAA4H+gOQMIIAErAwgaIABEAAAAAAAA8D+gDwsgAkEBcyACawsiAbciBUQAAOD+Qi7mv6KgIgAgBUR2PHk17znqPaIiBqELIQUgACAFIAUgBSAFoiIAIAAgACAAIABE0KS+cmk3Zj6iRPFr0sVBvbu+oKJELN4lr2pWET+gokSTvb4WbMFmv6CiRD5VVVVVVcU/oKKhIgCiRAAAAAAAAABAIAChoyAGoaBEAAAAAAAA8D+gIQUgAUUNAAJAAkACQCABQf8HTARAIAFBgnhODQMgBUQAAAAAAABgA6IhBSABQbhwTQ0BIAFByQdqIQEMAwsgBUQAAAAAAADgf6IhBSABQf4PSw0BIAFBgXhqIQEMAgsgBUQAAAAAAABgA6IhBSABQfBoIAFB8GhKG0GSD2ohAQwBCyAFRAAAAAAAAOB/oiEFIAFB/RcgAUH9F0gbQYJwaiEBCyAFIAFB/wdqrUI0hr+iIQULIAULygUDAX8BfgF8AkAgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEAgAUGAgID/A08EQCACQn9VBEBEAAAAAAAA8D8gAKFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyAAEAQiA6IgACADvUKAgICAcIO/IgAgAKKhIAMgAKCjoCAAoCIAIACgDwtEGC1EVPsh+T8gAEQAAAAAAADwP6BEAAAAAAAA4D+iIgAQBCIDIAMgACAAIAAgACAAIABECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiAAIAAgACAARIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjokQHXBQzJqaRvKCgoSIAIACgIQMMAgtEGC1EVPsh+T8hAyABQYGAgOMDSQ0BRAdcFDMmppE8IAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACioSAAoUQYLURU+yH5P6APCyACpyABQYCAwIB8anIEQEQAAAAAAAAAACAAIAChow8LRAAAAAAAAAAARBgtRFT7IQlAIAJCf1UbDwsgAwvJBAMBfwF+A3wgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEACQAJ8AkAgAUGAgID/A08EQEQAAAAAAADwPyAAmaFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyEFIAAQBCEDIAFBsua8/wNLDQFEGC1EVPsh6T8gA71CgICAgHCDvyIEIASgoUQHXBQzJqaRPCAAIAQgBKKhIAMgBKCjIgAgAKChIAUgAyADoKKhoEQYLURU+yHpP6AMAgsgAUGAgEBqQYCAgPIDSQ0CIAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACiIACgDwtEGC1EVPsh+T8gAyAFIAOioCIAIACgRAdcFDMmppG8oKELIgCaIAAgAkIAUxshAAsgAA8LIAKnIAFBgIDAgHxqcgRARAAAAAAAAAAAIAAgAKGjDwsgAEQYLURU+yH5P6JEAAAAAAAAcDigC48EAwJ/AX4DfCMAQRBrIQICQAJ/AkACQAJAIAC9IgNCIIinQf////8HcSIBQf//v6AETQRAIAFBgIDw/gNJDQEgAJkhACABQYCAzP8DSQ0DIAFBgICOgARJDQJEAAAAAAAA8L8gAKMhAEEDDAQLIAAgAGINBEQYLURU+yH5PyAApg8LQX8gAUGAgIDyA08NAhogAUGAgMAATw0DIAIgALY4AgwgAioCDBogAA8LIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELIAFBgICY/wNPBEAgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyAAIACgRAAAAAAAAPC/oCAARAAAAAAAAABAoKMhAEEACyECIAAgAKIiBSAFoiIEIAQgBCAEIAREL2xqLES0or+iRJr93lIt3q2/oKJEbZp0r/Kws7+gokRxFiP+xnG8v6CiRMTrmJmZmcm/oKIhBiAFIAQgBCAEIAQgBEQR2iLjOq2QP6JE6w12JEt7qT+gokRRPdCgZg2xP6CiRG4gTMXNRbc/oKJE/4MAkiRJwj+gokQNVVVVVVXVP6CiIQQgAUGAgPD+A08EQCACQQN0IgFByIPAAGorAwAgACAGIASgoiABQeiDwABqKwMAoSAAoaEiAJogACADQgBTGw8LIAAgACAGIASgoqEhAAsgAAvnAwMDfwF+BnwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyACQeK+JWoiAUEUdiADarciB0QAYJ9QE0TTP6IiCCAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAAgAEQAAAAAAADgP6KiIgWhvUKAgICAcIO/IgZEAAAgFXvL2z+iIgmgIgogCSAIIAqhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACAVe8vbP6IgB0Q2K/ER8/5ZPaIgACAGoETVrZrKOJS7PaKgoKCgDwsgACAAoUQAAAAAAAAAAKMhAAsgAAvOAwMDfwF+BXwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyAEQv////8PgyACQeK+JWoiAUH//z9xQZ7Bmv8Daq1CIIaEv0QAAAAAAADwv6AiACAAIABEAAAAAAAA4D+ioiIFob1CgICAgHCDvyIGRAAAIGVHFfc/oiIHIAFBFHYgA2q3IgigIgkgByAIIAmhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACBlRxX3P6IgACAGoEQAou8u/AXnPaKgoKAPCyAAIAChRAAAAAAAAAAAoyEACyAAC6UDAgV/AX4gASABYSAAIABhcUUEQCAAIAGgDwsgAb0iB0IgiKciAkGAgMCAfGogB6ciBXJFBEAgABAIDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkACQAJAIAdCIIinQf////8HcSIEIAenckUEQEQYLURU+yEJwCEBAkACQCADDgMAAAEDCyAADwtEGC1EVPshCUAPCyACQf////8HcSICIAVyRQ0CAkAgAkGAgMD/B0YEQCAEQYCAwP8HRw0BRNIhM3982QLAIQEgA0EDRg0CIANBA3RB2ILAAGorAwAPCyAEQYCAwP8HRiACQYCAgCBqIARJcg0CAnwgBgRARAAAAAAAAAAAIARBgICAIGogAkkNARoLIAAgAaOZEAgLIQECQAJAAkAgAw4DBAECAAsgAUQHXBQzJqahvKBEGC1EVPshCcCgDwsgAZoPC0QYLURU+yEJQCABRAdcFDMmpqG8oKEPC0QYLURU+yEJwCEBIANBA0YNACADQQN0QfCCwABqKwMAIQELIAEPC0QYLURU+yH5PyAApg8LRBgtRFT7Ifk/IACmC54DAwN/AX4CfAJAAkACQAJAIAC9IgRCAFMNACAEQiCIpyIBQYCAwABJDQAgAUH//7//B0sNA0GAgMD/AyECQYF4IQMgAUGAgMD/A0cEQCABIQIMAgsgBKcNAUQAAAAAAAAAAA8LIAC9Qv///////////wCDUARARAAAAAAAAPC/IAAgAKKjDwsgBEIAUw0BIABEAAAAAAAAUEOivSIEQiCIpyECQct3IQMLIAJB4r4laiIBQRR2IANqtyIFRAAA4P5CLuY/oiAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAVEdjx5Ne856j2iIAAgAEQAAAAAAAAAQKCjIgUgACAARAAAAAAAAOA/oqIiBiAFIAWiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAgBqGgoA8LIAAgAKFEAAAAAAAAAACjIQALIAALjgEBAn8gAUEQTwRAIABBACAAa0EDcSIDaiECIAMEQANAIABBADoAACAAQQFqIgAgAkkNAAsLIAIgASADayIBQXxxIgNqIQAgA0EBTgRAA0AgAkEANgIAIAJBBGoiAiAASQ0ACwsgAUEDcSEBCyABBEAgACABaiEBA0AgAEEAOgAAIABBAWoiACABSQ0ACwsLrAEAAkACQAJAIAFB/wdMBEAgAUGCeE4NAyAARAAAAAAAAGADoiEAIAFBuHBNDQEgAUHJB2ohAQwDCyAARAAAAAAAAOB/oiEAIAFB/g9LDQEgAUGBeGohAQwCCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBDAELIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSBtBgnBqIQELIAAgAUH/B2qtQjSGv6ILCAAgACABEA0LCAAgACABEAsLCAAgACABEAILBgAgABAGCwYAIAAQBwsGACAAEAgLBgAgABAFCwYAIAAQDAsGACAAEAQLBgAgABADCwYAIAAQCgsGACAAEAkLC+YKBQBBgIDAAAvwAgMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAAAABA+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1GC1EVPsh6T8YLURU+yHpv9IhM3982QJAAEH/gsAACymAGC1EVPshCUAAAAAAAADgPwAAAAAAAOC/AAAAAAAA8D8AAAAAAAD4PwBBsIPAAAsIBtDPQ+v9TD4AQcODwAALmQdAA7jiP0+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTxMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAAgCEAAqAAAAQzpcVXNlcnNcSm9uYXRoYW5cLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxvbmNlX2NlbGwtMS4yMC4yXHNyYy9saWIucnMAADwCEABiAAAACAMAABkAAAByZWVudHJhbnQgaW5pdAAAsAIQAA4AAAA8AhAAYgAAAHoCAAANAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAPACEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADwAhAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAmAMQABUAAACtAxAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc8wDEAAYAAAAZAEAAAkAAAAEAAAADAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAACQAAAAAAAAAIAAAABAAAAAoAAAALAAAADAAAAA0AAAAOAAAAEAAAAAQAAAAPAAAAEAAAABEAAAASAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAABMBBAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNoBBAAHAAAABkAAAAFAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAQfSKwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODEuMCAoZWViOTBjZGExIDIwMjQtMDktMDQpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0"), (e => e.charCodeAt(0)))
                          , t = yield WebAssembly.compile(e)
                          , n = (yield WebAssembly.instantiate(t)).exports;
                        Math = {
                            E: T_,
                            LN10: C_,
                            LN2: I_,
                            LOG2E: R_,
                            LOG10E: P_,
                            PI: B_,
                            SQRT1_2: D_,
                            SQRT2: L_,
                            abs: Math.abs,
                            acos: n.acos,
                            asin: n.asin,
                            atan: n.atan,
                            atan2: n.atan2,
                            ceil: Math.ceil,
                            cos: F_,
                            exp: n.exp,
                            floor: Math.floor,
                            log: n.log,
                            max: Math.max,
                            min: Math.min,
                            pow: n.pow,
                            random: Math.random,
                            round: Math.round,
                            sin: k_,
                            sqrt: n.sqrt,
                            tan: n.tan,
                            clz32: () => N_("clz32"),
                            imul: () => N_("imul"),
                            sign: Math.sign,
                            log10: n.log10,
                            log2: n.log2,
                            log1p: () => N_("log1p"),
                            expm1: () => N_("expm1"),
                            cosh: () => N_("cosh"),
                            sinh: () => N_("sinh"),
                            tanh: () => N_("tanh"),
                            acosh: () => N_("acosh"),
                            asinh: () => N_("asinh"),
                            atanh: () => N_("atanh"),
                            hypot: () => N_("hypot"),
                            trunc: Math.trunc,
                            cbrt: () => N_("cbrt"),
                            fround: Math.fround,
                            [Symbol.toStringTag]: "Math"
                        }
                    }
                    ))
                }();
                let t = new G_([]);
                const n = [];
                function i(e) {
                    switch (e.data.messageType) {
                    case X_.Init:
                        {
                            const n = e.data.isRealtime;
                            t = new G_(e.data.trackParts),
                            function(e) {
                                if (e)
                                    if (self.requestAnimationFrame) {
                                        function t() {
                                            l(),
                                            self.requestAnimationFrame(t)
                                        }
                                        t()
                                    } else
                                        setInterval(l, 1e3 / 60);
                                else
                                    setInterval(c)
                            }(n);
                            break
                        }
                    case X_.Verify:
                        !function(e) {
                            const n = sw.fromSaveString(e.data.trackData);
                            if (null == n)
                                throw new Error("Failed to load track");
                            const i = Sh.deserialize(e.data.carRecording);
                            if (null == i)
                                throw new Error("Failed to deserialize recording");
                            const r = n.getStartTransform();
                            if (null == r)
                                throw new Error("Track has no starting point");
                            const a = e.data.carId
                              , s = new E_(e.data.mountainVertices,new Zt(e.data.mountainOffset.x,e.data.mountainOffset.y,e.data.mountainOffset.z),t,n,e.data.carCollisionShapeVertices,e.data.carMassOffset,new K_(i),r);
                            s.start();
                            const o = new Xh(e.data.targetFrames);
                            for (; !s.hasFinished() && s.getTime().lessOrEqual(o); )
                                s.step();
                            const l = s.hasFinished() && s.getTime().equals(o);
                            postMessage({
                                messageType: X_.VerifyResult,
                                carId: a,
                                result: l
                            }),
                            s.dispose()
                        }(e);
                        break;
                    case X_.TestDeterminism:
                        postMessage({
                            messageType: X_.DeterminismResult,
                            isDeterminstic: r()
                        });
                        break;
                    case X_.CreateCar:
                        !function(e) {
                            const i = sw.fromSaveString(e.data.trackData);
                            if (null == i)
                                throw new Error("Failed to load track");
                            let r, a = null;
                            const s = e.data.carRecording;
                            if (null == s)
                                r = new ow,
                                a = [];
                            else {
                                const e = Sh.deserialize(s);
                                if (null == e)
                                    throw new Error("Failed to deserialize recording");
                                r = new K_(e)
                            }
                            const o = i.getStartTransform();
                            if (null == o)
                                throw new Error("Track has no starting point");
                            const l = e.data.carId
                              , c = new E_(e.data.mountainVertices,new Zt(e.data.mountainOffset.x,e.data.mountainOffset.y,e.data.mountainOffset.z),t,i,e.data.carCollisionShapeVertices,e.data.carMassOffset,r,o);
                            n.push({
                                id: l,
                                model: c,
                                userControls: a,
                                targetSimulationTime: null,
                                isPaused: !1
                            })
                        }(e);
                        break;
                    case X_.DeleteCar:
                        !function(e) {
                            const t = e.data.carId;
                            for (let e = 0; e < n.length; e++) {
                                const i = n[e];
                                if (i.id == t) {
                                    i.model.controls.dispose(),
                                    i.model.dispose(),
                                    n.splice(e, 1);
                                    break
                                }
                            }
                        }(e);
                        break;
                    case X_.StartCar:
                        !function(e) {
                            const t = e.data.carId;
                            for (const i of n)
                                if (i.id == t) {
                                    i.model.start();
                                    const t = e.data.targetSimulationTimeFrames;
                                    i.targetSimulationTime = null != t ? new Xh(t) : null;
                                    break
                                }
                        }(e);
                        break;
                    case X_.ControlCar:
                        !function(e) {
                            const t = performance.now()
                              , i = e.data.carId;
                            for (const r of n)
                                if (r.id == i) {
                                    if (null == r.userControls)
                                        throw new Error("Tried to control uncontrollable car");
                                    const n = Math.max(0, t - s);
                                    let i = r.model.getTime().numberOfFrames + n;
                                    if (r.model.hasStarted() || (i = 0),
                                    0 == r.userControls.length)
                                        r.userControls.push({
                                            frame: i,
                                            up: e.data.up,
                                            right: e.data.right,
                                            down: e.data.down,
                                            left: e.data.left,
                                            reset: e.data.reset
                                        });
                                    else {
                                        const t = r.userControls[r.userControls.length - 1].frame;
                                        i == t ? r.userControls[r.userControls.length - 1] = {
                                            frame: i,
                                            up: e.data.up,
                                            right: e.data.right,
                                            down: e.data.down,
                                            left: e.data.left,
                                            reset: e.data.reset
                                        } : i > t && r.userControls.push({
                                            frame: i,
                                            up: e.data.up,
                                            right: e.data.right,
                                            down: e.data.down,
                                            left: e.data.left,
                                            reset: e.data.reset
                                        })
                                    }
                                    break
                                }
                        }(e);
                        break;
                    case X_.PauseCar:
                        !function(e) {
                            const t = e.data.carId;
                            for (const i of n)
                                if (i.id == t) {
                                    i.isPaused = e.data.isPaused;
                                    break
                                }
                        }(e)
                    }
                }
                for (const e of cw)
                    i(e);
                function r() {
                    if (3.141592653589793 != Math.PI)
                        return console.error("Determinism check failed: Math.PI"),
                        !1;
                    if (1.4142135623730951 != Math.SQRT2)
                        return console.error("Determinism check failed: Math.SQRT2"),
                        !1;
                    if (.8325082155867481 != Math.cos(.587123751237))
                        return console.error("Determinism check failed: Math.cos"),
                        !1;
                    if (.530868917654027 != Math.sin(2.581961285))
                        return console.error("Determinism check failed: Math.sin"),
                        !1;
                    if (3678159.3874182813 != Math.pow(123, Math.PI))
                        return console.error("Determinism check failed: Math.pow"),
                        !1;
                    if (123 * Math.PI != 386.41589639154455)
                        return console.error("Determinism check failed: Multiply"),
                        !1;
                    if (123 / Math.PI != 39.152116000606256)
                        return console.error("Determinism check failed: Division"),
                        !1;
                    const t = new Zt(-.6827400326728821,.11212741583585739,2.6956899166107178)
                      , n = new Kt(-.615668535232544,.03904851898550987,.7859793305397034,.04079177975654602)
                      , i = new Hh;
                    i.createGroundPlane(),
                    i.activePhysicsAt(new Zt(0,0,0));
                    const r = new e.btTransform;
                    r.setIdentity();
                    const a = new e.btDefaultMotionState(r);
                    e.destroy(r);
                    const s = new e.btVector3(0,0,0)
                      , o = new e.btVector3(.1,.1,.1)
                      , l = new e.btBoxShape(o);
                    l.calculateLocalInertia(400, s),
                    e.destroy(o);
                    const c = new e.btRigidBodyConstructionInfo(400,a,l,s)
                      , h = new e.btRigidBody(c);
                    e.destroy(s),
                    e.destroy(c),
                    h.setActivationState(4),
                    i.world.addRigidBody(h);
                    const d = new e.btVehicleTuning
                      , u = new e.btDefaultVehicleRaycaster(i.world)
                      , f = new e.btRaycastVehicle(d,h,u);
                    f.setCoordinateSystem(0, 1, 2),
                    i.world.addAction(f);
                    const p = new e.btVector3(0,-1,0)
                      , m = new e.btVector3(-1,0,0);
                    for (const t of ["WheelFL", "WheelFR", "WheelBL", "WheelBR"]) {
                        let n;
                        if ("WheelFL" == t)
                            n = new e.btVector3(.627909,.27,1.3478);
                        else if ("WheelFR" == t)
                            n = new e.btVector3(-.627909,.27,1.3478);
                        else if ("WheelBL" == t)
                            n = new e.btVector3(.720832,.27,-1.52686);
                        else {
                            if ("WheelBR" != t)
                                throw new Error("Unidentified wheel");
                            n = new e.btVector3(-.720832,.27,-1.52686)
                        }
                        const i = "WheelFL" == t || "WheelFR" == t;
                        f.addWheel(n, p, m, .12, .331, d, i),
                        e.destroy(n)
                    }
                    e.destroy(p),
                    e.destroy(m);
                    const g = new e.btTransform;
                    g.setIdentity(),
                    h.setWorldTransform(g),
                    h.getMotionState().setWorldTransform(g),
                    e.destroy(g),
                    f.resetSuspension(),
                    f.setSteeringValue(0, 0),
                    f.setSteeringValue(0, 1);
                    const A = new e.btTransform;
                    A.setIdentity();
                    const _ = new e.btDefaultMotionState(A);
                    e.destroy(A);
                    const v = new e.btVector3(0,0,0)
                      , w = new e.btVector3(.1,.1,.1)
                      , y = new e.btBoxShape(w);
                    y.calculateLocalInertia(100, v),
                    e.destroy(w);
                    const x = new e.btRigidBodyConstructionInfo(100,_,y,v)
                      , b = new e.btRigidBody(x);
                    e.destroy(v),
                    e.destroy(x),
                    b.setActivationState(4),
                    i.world.addRigidBody(b);
                    const S = 1e5;
                    f.applyEngineForce(S, 2),
                    f.applyEngineForce(S, 3);
                    for (let e = 0; e < 999; e++)
                        i.step();
                    const E = new e.btTransform;
                    h.getMotionState().getWorldTransform(E);
                    const M = E.getOrigin()
                      , T = E.getRotation();
                    e.destroy(E);
                    const C = t.equals(new Zt(M.x(),M.y(),M.z()))
                      , I = n.equals(new Kt(T.x(),T.y(),T.z(),T.w()));
                    i.dispose(),
                    e.destroy(l),
                    e.destroy(h),
                    e.destroy(f),
                    e.destroy(y),
                    e.destroy(b);
                    const R = C || I;
                    return R || console.error("Determinism check failed: Simulation"),
                    R
                }
                function a(e) {
                    var t, n;
                    const i = e.id
                      , r = e.model
                      , a = r.controls.getControls(r.getTime().numberOfFrames);
                    r.step();
                    const s = r.getPosition()
                      , o = r.getQuaternion()
                      , l = r.getWheelPosition(0)
                      , c = r.getWheelPosition(1)
                      , h = r.getWheelPosition(2)
                      , d = r.getWheelPosition(3)
                      , u = r.getWheelQuaternion(0)
                      , f = r.getWheelQuaternion(1)
                      , p = r.getWheelQuaternion(2)
                      , m = r.getWheelQuaternion(3);
                    let g = null;
                    if (r.getWheelInContact(0)) {
                        g = {
                            position: r.getWheelContactPosition(0),
                            normal: r.getWheelContactNormal(0)
                        }
                    }
                    let A = null;
                    if (r.getWheelInContact(1)) {
                        A = {
                            position: r.getWheelContactPosition(1),
                            normal: r.getWheelContactNormal(1)
                        }
                    }
                    let _ = null;
                    if (r.getWheelInContact(2)) {
                        _ = {
                            position: r.getWheelContactPosition(2),
                            normal: r.getWheelContactNormal(2)
                        }
                    }
                    let v = null;
                    if (r.getWheelInContact(3)) {
                        v = {
                            position: r.getWheelContactPosition(3),
                            normal: r.getWheelContactNormal(3)
                        }
                    }
                    return {
                        id: i,
                        frames: r.getTime().numberOfFrames,
                        speedKmh: r.getSpeedKmh(),
                        hasStarted: r.hasStarted(),
                        finishFrames: null !== (n = null === (t = r.getFinishTime()) || void 0 === t ? void 0 : t.numberOfFrames) && void 0 !== n ? n : null,
                        nextCheckpointIndex: r.getNextCheckpointIndex(),
                        hasCheckpointToRespawnAt: r.hasCheckpointToRespawnAt(),
                        position: {
                            x: s.x,
                            y: s.y,
                            z: s.z
                        },
                        quaternion: {
                            x: o.x,
                            y: o.y,
                            z: o.z,
                            w: o.w
                        },
                        collisionImpulses: r.getCollisionImpulses(),
                        wheelContact: [g, A, _, v],
                        wheelSuspensionLength: [r.getWheelSuspensionLength(0), r.getWheelSuspensionLength(1), r.getWheelSuspensionLength(2), r.getWheelSuspensionLength(3)],
                        wheelSuspensionVelocity: [r.getWheelSuspensionVelocity(0), r.getWheelSuspensionVelocity(1), r.getWheelSuspensionVelocity(2), r.getWheelSuspensionVelocity(3)],
                        wheelRotation: [r.getWheelRotation(0), r.getWheelRotation(1), r.getWheelRotation(2), r.getWheelRotation(3)],
                        wheelDeltaRotation: [r.getWheelDeltaRotation(0), r.getWheelDeltaRotation(1), r.getWheelDeltaRotation(2), r.getWheelDeltaRotation(3)],
                        wheelSkidInfo: [r.getWheelSkidInfo(0), r.getWheelSkidInfo(1), r.getWheelSkidInfo(2), r.getWheelSkidInfo(3)],
                        wheelPosition: [{
                            x: l.x,
                            y: l.y,
                            z: l.z
                        }, {
                            x: c.x,
                            y: c.y,
                            z: c.z
                        }, {
                            x: h.x,
                            y: h.y,
                            z: h.z
                        }, {
                            x: d.x,
                            y: d.y,
                            z: d.z
                        }],
                        wheelQuaternion: [{
                            x: u.x,
                            y: u.y,
                            z: u.z,
                            w: u.w
                        }, {
                            x: f.x,
                            y: f.y,
                            z: f.z,
                            w: f.w
                        }, {
                            x: p.x,
                            y: p.y,
                            z: p.z,
                            w: p.w
                        }, {
                            x: m.x,
                            y: m.y,
                            z: m.z,
                            w: m.w
                        }],
                        brakeLightEnabled: r.isBrakeLightEnabled(),
                        controls: a
                    }
                }
                cw.length = 0,
                onmessage = i;
                let s = performance.now()
                  , o = 0;
                function l() {
                    const e = performance.now();
                    o += Math.max(0, Math.min(.1, (e - s) / 1e3)),
                    s = e;
                    const t = [];
                    for (; o > .001; ) {
                        o -= .001;
                        for (const e of n) {
                            if (null != e.targetSimulationTime)
                                throw new Error("Realtime simulation does not support targetSimulationTime");
                            const n = e.model.getTime().numberOfFrames;
                            if (e.model.hasStarted() && n < Sh.maxFrames && !e.isPaused) {
                                if (null != e.userControls)
                                    for (; e.userControls.length > 0 && e.userControls[0].frame <= n; ) {
                                        const t = e.userControls.shift();
                                        if (null != t) {
                                            const n = e.model.controls;
                                            if (!(n instanceof ow))
                                                throw new Error("Tried to control uncontrollable car");
                                            n.up = t.up,
                                            n.right = t.right,
                                            n.down = t.down,
                                            n.left = t.left,
                                            n.reset = t.reset
                                        }
                                    }
                                t.push(a(e))
                            }
                        }
                    }
                    t.length > 0 && postMessage({
                        messageType: X_.UpdateResult,
                        carStates: t
                    })
                }
                function c() {
                    const e = performance.now()
                      , t = [];
                    if (n.length > 0) {
                        let i;
                        do {
                            i = !0;
                            for (let e = 0; e < Math.max(1, Math.ceil(100 / n.length)); e++) {
                                for (const e of n)
                                    if (e.model.hasStarted()) {
                                        if (null == e.targetSimulationTime)
                                            throw new Error("Non-realtime simulation requires targetSimulationTime");
                                        e.model.getTime().numberOfFrames < Sh.maxFrames && e.model.getTime().lessThan(e.targetSimulationTime) && !e.isPaused && (t.push(a(e)),
                                        i = !1)
                                    }
                                if (i)
                                    break
                            }
                        } while (Math.max(0, performance.now() - e) / 1e3 < .01 && !i)
                    }
                    postMessage({
                        messageType: X_.UpdateResult,
                        carStates: t
                    })
                }
            }
            ))
        }
        ))
    }
    )()
}
)();
